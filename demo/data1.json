{
  "schema": {
    "name": "register-description-format",
    "version": "v0.2"
  },
  "root": {
    "display_name": "Europa Compute Element",
    "version": "0.0.1",
    "links": {
      "GitHub": "",
      "Specification": ""
    },
    "children": [
      "eio",
      "emem"
    ]
  },
  "elements": {
    "eio": {
      "display_name": "EIO",
      "version": "EIO_DROP_11.2.2-59-gdee58a6d",
      "links": {
        "GitHub": "https://github.jpl.nasa.gov/ecm-avs/eio",
        "Specification": "https://github.jpl.nasa.gov/ecm-avs/eio/blob/dee58a6d6d1fe3cd945775472c60c49768c51337/doc/EIO_Specification.docx"
      },
      "children": [
        "eio.system",
        "eio.radio",
        "eio.ul",
        "eio.ssiru",
        "eio.dl",
        "eio.fdu",
        "eio.tu",
        "eio.bc"
      ],
      "id": "eio",
      "name": "eio",
      "addr": 3235905536,
      "offset": 3235905536
    },
    "eio.system": {
      "id": "eio.system",
      "name": "system",
      "type": "blk",
      "addr": 3235905536,
      "offset": 0,
      "doc": "System Page Registers\nFurther divided system page to blocks to assist automated register generator tool.",
      "children": [
        "eio.system.board",
        "eio.system.ip",
        "eio.system.edac",
        "eio.system.tz",
        "eio.system.dma_boundary",
        "eio.system.system_page_rsvd_0"
      ]
    },
    "eio.system.board": {
      "id": "eio.system.board",
      "name": "board",
      "type": "blk",
      "addr": 3235905536,
      "offset": 0,
      "doc": "Board Registers\nThis section describes the registers related to the EIO’s physical FPGA and the board.  Board related registers are read only and are a reflection of board related settings.  For details of the board related settings please refer to the board documentation.\nStandard PCI registers are accessible via the PCI configuration cycles.",
      "children": [
        "eio.system.board.fpgaid",
        "eio.system.board.bdid",
        "eio.system.board.bdctrl",
        "eio.system.board.ipcia",
        "eio.system.board.pciaerr",
        "eio.system.board.pmas",
        "eio.system.board.dmabck",
        "eio.system.board.sre"
      ]
    },
    "eio.system.board.fpgaid": {
      "id": "eio.system.board.fpgaid",
      "name": "fpgaid",
      "type": "reg",
      "addr": 3235905536,
      "offset": 0,
      "doc": "FPGA ID Register\nAddress offset:\t\t\t0000h\nPOR/cPCI/DMA Soft Reset:\tuuuu uuuuh\t(u = unchanged)",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "fpgarev_major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the FPGA Programmed Revision, corresponds to the FPGA REV Column of the Change Log\nNote that decimal numbering will be used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 12,
          "lsb": 12,
          "name": "fpgarev_minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the FPGA Programmed Revision, corresponds to the FPGA REV Column of the Change Log\nNote that decimal numbering will be used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "fpgarev_patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the FPGA Programmed Revision, corresponds to the FPGA REV Column of the Change Log\nNote that decimal numbering will be used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.system.board.bdid": {
      "id": "eio.system.board.bdid",
      "name": "bdid",
      "type": "reg",
      "addr": 3235905540,
      "offset": 4,
      "doc": "Board ID Register\nThis register shows the jumper settings of the board that are designated for serial number or board types for easy software read purposes.  Since some hardware do not have direct software access their jumper set values are routed to EIO for your viewing pleasure.  The board type is also reflected from the board setup.  \nAddress offset:\t\t0004h\nPOR/PCI Reset:\t\t????h  (? = Set externally)",
      "fields": [
        {
          "nbits": 3,
          "lsb": 29,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 5,
          "lsb": 24,
          "name": "crcbdid",
          "access": "ro",
          "reset": 0,
          "doc": "CRCC_ID, Board ID for the CRC Card, refer to CRCC documentation as its outside EIO’s scope. Default will be what the CRCC board jumpers are set to."
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "bpbdid",
          "access": "ro",
          "reset": 0,
          "doc": "EBP_ID, Board ID for the Backplane, refer to Backplane documentation as its outside EIO’s scope.  Default will be what the Backplane board jumpers are set to."
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "pcubdid",
          "access": "ro",
          "reset": 0,
          "doc": "ECEPCU_ID, Board ID for the PCU Card, refer to PCU documentation as its outside EIO’s scope. Default will be what the PCU board jumpers are set to."
        },
        {
          "nbits": 2,
          "lsb": 6,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "eiobdid",
          "access": "ro",
          "reset": 0,
          "doc": "BD_ID,  Board ID for the EIO Board ID defined in the following way.\n[5:4] = Board Type\n            00 Breadboard, also missing jumpers will probably read this.\n            01 Prototype\n            10 EM\n            11 Flight\n[3:0] = Serial Number"
        }
      ]
    },
    "eio.system.board.bdctrl": {
      "id": "eio.system.board.bdctrl",
      "name": "bdctrl",
      "type": "reg",
      "addr": 3235905544,
      "offset": 8,
      "doc": "Board Control Register\nThis register is used to control board functions that do not fit into other interfaces. \nAddress offset:\t\t0008h\nPCI Reset:\t\t000uh  (u = unchanged)\nPOR Reset:\t\t0003h",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "Function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function code"
        },
        {
          "nbits": 26,
          "lsb": 2,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "srub_doe",
          "access": "rw",
          "reset": 1,
          "doc": "SRU-B Input Signal.  When SRU is not powered Software may turn this bit off to save negligible power on the EIO board.  Requires a function code value of 0xC to set or clear."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "srua_doe",
          "access": "rw",
          "reset": 1,
          "doc": "SRU-A Input Signal.  When SRU is not powered Software may turn this bit off to save negligible power on the EIO board.  Requires a function code value of 0xC to set or clear."
        }
      ]
    },
    "eio.system.board.ipcia": {
      "id": "eio.system.board.ipcia",
      "name": "ipcia",
      "type": "reg",
      "addr": 3235905548,
      "offset": 12,
      "doc": "Invalid PCI Access Address Register\nThe Invalid PCI Access Address Register captures and latches the PCI address of the first invalid access reported in the <PCIAERR_REG: PCI Access Error Register>\n\nThis register is cleared using the <PMAS_REG: PCI Access Control and Clear Register> discussed below.\nAddress offset:\t000Ch\nPOR reset value:\t0000_0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "invalid_pci_address",
          "access": "ro",
          "reset": 0,
          "doc": "PCI address of the first invalid access.  Used along with the Invalid PCI Access Register to determine the exact operation which caused the violation. To be implemented."
        }
      ]
    },
    "eio.system.board.pciaerr": {
      "id": "eio.system.board.pciaerr",
      "name": "pciaerr",
      "type": "reg",
      "addr": 3235905552,
      "offset": 16,
      "doc": "PCI Access Error Register\nThe PCI Access Error Register reports an invalid PCI Target access (e.g. PIO) to the EIO FPGA.\nNote:  An access of an address that is not within a defined BAR address range will result in a Master Abort and will not be reported in this register.  \nThis register can be used along with the Invalid PCI Address Register discussed in the next Section to determine the operation that caused the invalid PCI access.  Note that if multiple error bits are asserted, software will not be able to correlate an error with an address since only the address of the first detected error is captured in the <IPCIA_REG: Invalid PCI Access Address Register>.  Status bits are cleared using the <PMAS_REG: PCI Access Control and Clear Register> Section below.  \nNote:  The following values are returned to software when reading unimplemented, unpowered and reserved PCI addresses.\n-\tFor Unimplemented PCI addresses, the data returned is:  0xdead_c0de (Dead Code)\n\tAn Unimplemented PCI address is defined as the following: \nFor Registers (BAR 0):  Any address outside of a valid 8KiB Register Page, but within a valid BAR.\nFor Memory (SRAM, BRAM), any address outside of a defined memory address range, but within a valid BAR.\n-\tFor inaccessible PCI addresses, i.e. test only path in RMAP, data returned is: 0x0fff_c0de (Off Code)\n-\tFor Reserved (unused) register addresses. Data returned is: 0xdead_c0de (Dead Code)\nA Reserved or Unused register address is defined as a BAR 0 address that exists within a valid 8KiB Register Page, and is below 80h address range.\nAddress offset:\t\t0010h\nPOR reset value:\t\t0000_0000h",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "byte_write",
          "access": "rw",
          "reset": 0,
          "doc": "The PCI CBEs (Command Byte Enables) were not all asserted (indicating a sub Dword write).  This is allowed by PCI, but not allowed by Europa.  Note:  The PCI Interface will bit bucket the write data and take no further action (i.e. no target abort, retry, etc.). Unlike other cards EIO does not flag partial byte reads as error. To be implemented."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "res_read",
          "access": "rw",
          "reset": 0,
          "doc": "A read to a Reserved register address (BAR 0) was detected.\nNote:  Data returned = 0x0BADC0DE (0x0BAD for BC 15 bit register)"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "ro_write",
          "access": "rw",
          "reset": 0,
          "doc": "Read Only Write.  A write operation to a read only register or Reserved Register address was detected.  Note:  Reserved Register addresses are included in this status because these registers are read only by design.  Also, it would be a significant hardware complication to distinguish between a Reserved Register address write and a write to a valid read only register."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "to_read",
          "access": "rw",
          "reset": 0,
          "doc": "Test only path read.  A read operation to a test only path without being in test  device was detected.  RMAP TX enabled and TX not completed. RMAP RX address read more than the data size received in non-test mode.\nNote:  Data returned = 0x0FFFC0DE"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "to_write",
          "access": "rw",
          "reset": 0,
          "doc": "Test only path write.  A write operation to an test only location was detected."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "ui_read",
          "access": "rw",
          "reset": 0,
          "doc": "Unimplemented Read.  A read operation to unimplemented address space was detected. \nNote:  Data returned = 0xDEADC0DE."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "ui_write",
          "access": "rw",
          "reset": 0,
          "doc": "Unimplemented Write.  A write operation to unimplemented address space was detected."
        }
      ]
    },
    "eio.system.board.pmas": {
      "id": "eio.system.board.pmas",
      "name": "pmas",
      "type": "reg",
      "addr": 3235905556,
      "offset": 20,
      "doc": "PCI Access Control and Clear Register\nThe PCI Error Control Register allows software to clear all status bits in the PIO Access Error Register as well as the address captured in the §<IPCIA_REG: Invalid PCI Access Address Register.  Setting the Status Clear bit to “1” will generate an edge detected clear pulse to all status bits as well as the captured address.  Consequently, in order to execute another clear operation, software must first write a “0” before writing a “1” to the clear control bit.\nSoftware also uses this register to control when or if a Master Abort error is issued by an EIO FPGA DMA Engine in response to a slow target that cannot provide a response within the specified amount of time.  The control bits, Target TO 64 and Target TO Disable will configure the LRC PCI Initiator Interface (used by the DMA Engines) to wait 64 PCI clocks or wait indefinitely, respectively, for a Target response before generating a Master Abort.  This heritage feature was developed to support a slow, non-PCI compliant RAD750 Target Interface.\nWriting to this register requires use of the function code as described below.\n\nNote: Altering the timeout duration will make EIO PCI non-compliant.\nAddress offset:\t\t0014h\nPOR reset value: \t0000 0000h\ncPCI reset value: \t0000 000uh (unchanged)",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "wo",
          "reset": 0,
          "doc": "Function Code(3:0): This four bit function code will allow you to set and reset the control bits in this register:\tFunction_Code(3:0)\tFunction\n0110b\tAllows control bits in this register to be set to ‘1’.\n1001b\tAllows control bits in this register to be reset to ‘0’.\nWrite a 1 to the associated bit(s) below to invoke the desired Function_Code action. These bits read back as 0000."
        },
        {
          "nbits": 25,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "pci_status_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Clears all status bits as well as the address reported in the PIO Access Error Register and Invalid PCI Access Address Register accordingly.\nMust be set back to “0” before performing another clear operation."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "pci_to_dis",
          "access": "rw",
          "reset": 0,
          "doc": "PCI TIMEOUT DISABLE: When this bit is set, during a PCI master transaction s if DEVSEL is asserted by the TARGET the EIO will infinitely (∞) wait for a valid Target Response.  (Default timeout is 32 clocks after DEVSEL is asserted that the EIO will wait for a Target Response before issuing a Master Abort).  This function takes precedence over the PCI TIMEOUT 64 in the case when both bits are set."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "pci_to_64",
          "access": "rw",
          "reset": 0,
          "doc": "PCI TIMEOUT 64: When this bit is set, during a PCI master transaction s if DEVSEL is asserted by the TARGET the EIO will wait 64 clocks for a valid Target Response, if no response is received after 64 clocks the EIO will Master Abort.  (Default timeout is 32 clocks after DEVSEL is asserted that the EIO will wait for a Target Response before issuing a Master Abort)"
        }
      ]
    },
    "eio.system.board.dmabck": {
      "id": "eio.system.board.dmabck",
      "name": "dmabck",
      "type": "reg",
      "addr": 3235905560,
      "offset": 24,
      "doc": "DMA Boundary Check Register\nThis register indicates the error flags for DMA out of boundary.\nAddress offset:\t018h\t\t\t\t\t\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\t0000 0000h\t\nHardware implementation notes:\nWhen any of the boundary checks Bdry_Err is asserted. The EIO will do these steps below:\nSet DMABCK status register\nSet the HS2 interrupt register if the bit [31] of the DMABCK register is “1”\nPCI Master early burst termination (gracefully terminate without error)\nIn case of UL_DMA_Bdry_Err occurs\nThe Uplink module stops the current DMA and swap to the other buffer\nIn case of BC_DMA_Bdry_Err occurs (this is a 1553 Bus controller DMA operation)\nThe EIO will reset the 1553 Bus controller Module for both reading and writing to avoid any unexpected traffics on both 1553 and PCI buses.\nIn case of SA_DMA_Bdry_Err occurs\nDisables the SSIRU DMA go bit.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "intr_ena",
          "access": "rw",
          "reset": 0,
          "doc": "When set to 1, enables boundary check error status below and bdry status in HS2. "
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "set_sa_dma_bdry_err",
          "access": "rw",
          "reset": 0,
          "doc": "Read always returns 0. Writing ”1” to this bit will take the content of bit [2] ie write 2000_0010 to set SA_DMA_Bdry_Err & 0400_0000 to clear it "
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "set_ul_dma_bdry_err",
          "access": "rw",
          "reset": 0,
          "doc": "Read always returns 0. and Writing ”1” to this bit will take the content of bit [1] ie write 2000_0002 to set UL_DMA_Bdry_Err & 2000_0000 to clear it "
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "set_bc_dma_bdry_err",
          "access": "rw",
          "reset": 0,
          "doc": "Read always returns 0. and Writing ”1” to this bit will take the content of bit [0] ie write 1000_0001 to set BC_DMA_Bdry_Err & 1000_0000 to clear it "
        },
        {
          "nbits": 25,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "sa_dma_bdry_err",
          "access": "wo",
          "reset": 0,
          "doc": "SSIRU DMA boundary check error, only sets if bit 31 Is set.\nWrite 1 to set and 0 to clear when bit 30 is set."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "ul_dma_bdry_err",
          "access": "wo",
          "reset": 0,
          "doc": "Uplink DMA boundary check error, only sets here and in HS2 if bit 31 Is set. Will set corresponding  HS2 but will not clear HS2 bit if cleared here.\nWrite 1 to set and 0 to clear when bit 29 is set."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "bc_dma_bdry_err",
          "access": "wo",
          "reset": 0,
          "doc": "1553-BC DMA boundary check error, only sets here and HS2  if bit 31 Is set. \nWrite 1 to set and 0 to clear when bit 28 is set."
        }
      ]
    },
    "eio.system.board.sre": {
      "id": "eio.system.board.sre",
      "name": "sre",
      "type": "reg",
      "addr": 3235905564,
      "offset": 28,
      "doc": "Software Reset Register\nThis register is used to generate a system level software reset.\nThis register does not cuase a reset of its own on the EIO, but it gets passed to the flight computer via backplane for the flight computer to generate a PCI reset which in turn will reset EIO.\nAddress offset:\t\t001Ch\nPOR/cPCI reset value: \t0000 0000h\t(Reset by PCI Reset)",
      "fields": [
        {
          "nbits": 28,
          "lsb": 4,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "sw_rst",
          "access": "rw",
          "reset": 0,
          "doc": "Software Reset, any write of ‘1’ will generate a system reset. No associated function code. i.e. and all F’s to this register is the same as writing a 1 to this bit."
        },
        {
          "nbits": 3,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "eio.system.ip": {
      "id": "eio.system.ip",
      "name": "ip",
      "type": "blk",
      "addr": 3235905568,
      "offset": 32,
      "doc": "Interrupt and Health Registers",
      "children": [
        "eio.system.ip.iiprev",
        "eio.system.ip.hs1",
        "eio.system.ip.hs2",
        "eio.system.ip.ie1",
        "eio.system.ip.ie2",
        "eio.system.ip.ip_blk_rsvd_0"
      ]
    },
    "eio.system.ip.iiprev": {
      "id": "eio.system.ip.iiprev",
      "name": "iiprev",
      "type": "reg",
      "addr": 3235905568,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.system.ip.hs1": {
      "id": "eio.system.ip.hs1",
      "name": "hs1",
      "type": "reg",
      "addr": 3235905572,
      "offset": 4,
      "doc": "Health Status Register 1\nSystem status for EDAC and DMA functional modules are captured in this register.  The only bit that are able to generate a physical level interrupt are timing related interrupts such as RTI.  These are enabled via the IE register that follows.\nAddress offset:\t\t0024h\ncPCI reset value: \t\tuuuu uuuuh\t(u = unchanged, not affected by PCI Reset)\nPOR reset value: \t\t0000 0000h\n\n* Requires Clr_PI2_Ena or PI_SelfTst_A_Ena",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "clr_hs1_ena",
          "access": "wo",
          "reset": 0,
          "doc": "Clear Pending Status 1:  Set to 1 and set associated interrupt bits to be cleared to a 1.   When set to 1 during a write, control of Pending interrupt bits is allowed. 0 during Read.*"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "hs2_active",
          "access": "ro",
          "reset": 0,
          "doc": "Health Status 2 Register Active: When 1 it means that there is at least one bit in this HS1 Register that is set whose associated Health Status 1 bit is also set (signifying an active status). Intended as advance information to limit PCI reads required for servicing.  Cleared with clr_hs1_ena above.*"
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "hs1_active",
          "access": "ro",
          "reset": 0,
          "doc": "Health Status 1 Register Active: When 1 it means that there is at least one bit in this HS1 Register that is set whose associated Health Status 1 bit is also set (signifying an active status). Intended as advance information to limit PCI reads required for servicing.  Cleared with clr_hs1_ena above.*"
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "fdurti",
          "access": "rw",
          "reset": 0,
          "doc": "FDURTI.  This is an 8, 16, 32 or 64Hz indicator, synchronized with Space Craft Time.  Rate change is updated only at one second boundary.  Refer to Timing Unit documentation for details.*"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "subrti",
          "access": "rw",
          "reset": 0,
          "doc": "SubRTI.  This is a 64, 128, 256 or 512Hz indicator, synchronized with Space Craft Time.  Rate change is updated only at one second boundary at the same time RTI is updated.  Refer to Timing Unit documentation for details.*"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "rti",
          "access": "rw",
          "reset": 0,
          "doc": "RTI.  This is an 8, 16, 32 (default) or 64Hz interrupt, synchronized with Space Craft Time.  Rate change is updated only at one second boundary at the same time RTI is updated.  Refer to Timing Unit documentation for details.*"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "deadp",
          "access": "rw",
          "reset": 0,
          "doc": "DEAD PERIOD.  This is an 8, 16, 32 (default) or 64Hz indicator that occurs prior to RTI interrupt.  Refer to Table 22 - DEADP Active Pulse Period. For details.*"
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "xrti",
          "access": "rw",
          "reset": 0,
          "doc": "XRTI.  Set when cross string RTI is detected.*"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "dtstart",
          "access": "rw",
          "reset": 0,
          "doc": "Dead Time Start detected by the RT (most likely EMEM) through 1553 commands.*"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "swarti",
          "access": "rw",
          "reset": 0,
          "doc": "SWARTI.  This is a programmable Software Advanced RTI.  Refer to Timing Unit documentation for details.*"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "reset_pending",
          "access": "rw",
          "reset": 0,
          "doc": "A reset is pending!  A forced reset will occur as soon as 62.5ms (15.62ms in drop 9.0 and earlier)*"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "fdu_csronline_tmr",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller’s Online TMR indicator, set when the three CSR lines do not match.  Refer to FDU documentation for details*"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "fdu_csrprime_tmr",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller’s Prime TMR indicator, set when the three CSR lines do not match.  Refer to FDU documentation for details*"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "fdu_lbonline_tmr",
          "access": "rw",
          "reset": 0,
          "doc": "EIO Loop Back Online TMR indicator, set when the three LB lines do not match.*\nRefer to FDU documentation for details"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "fdu_lbprime_tmr",
          "access": "rw",
          "reset": 0,
          "doc": "EIO Loop Back Prime TMR indicator, set when the three LB lines do not match.*\nRefer to FDU documentation for details"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "fdu_csronline",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller’s Online change of state indicator.*"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "fdu_csrprime",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller’s Prime change of state indicator.*"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "fdu_online",
          "access": "rw",
          "reset": 0,
          "doc": "EIO Online change of state indicator.*"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "fdu_prime",
          "access": "rw",
          "reset": 0,
          "doc": "EIO Prime change of state indicator.*"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "BC_DbErInt",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller Double Bit Error Interrupt"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "BC_SbErInt",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller Single Bit Error Interrupt"
        },
        {
          "nbits": 2,
          "lsb": 4,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "Pong_DbErInt",
          "access": "rw",
          "reset": 0,
          "doc": "Pong Double Bit Error Interrupt"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "Pong_SbErInt",
          "access": "rw",
          "reset": 0,
          "doc": "Pong Single Bit Error Interrupt"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "Ping_DbErInt",
          "access": "rw",
          "reset": 0,
          "doc": "Ping Double Bit Error Interrupt"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "Ping_SbErInt",
          "access": "rw",
          "reset": 0,
          "doc": "Ping Single Bit Error Interrupt"
        }
      ]
    },
    "eio.system.ip.hs2": {
      "id": "eio.system.ip.hs2",
      "name": "hs2",
      "type": "reg",
      "addr": 3235905576,
      "offset": 8,
      "doc": "Health Status Register 2\nSystem status for Uplink, Downlink and 1553BC functional modules are captured in this register.  1553 status must be cleared via 1553BC registers.\nAddress offset:\t\t0028h\ncPCI reset value: \t\tuuuu uuuuh\t(u = unchanged, not affected by PCI Reset)\nPOR reset value: \t\t0000 0000h\n\n* Requires Clr_PI2_Ena or PI_SelfTst_A_Ena",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "clr_pi2_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Clear Pending Status 2:  Set to 1 and set associated indicator bits to be cleared to a 1.   When set to 1 during a write, control of Pending indicator bits is allowed. 0 during Read.*"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "upl_overrun_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Buffer Overrun Error: Set to 1 if the Uplink buffer overruns*"
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "upl_fsw_relay_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink FSW Relay Error: Set to 1 if FSW attempts to write to the Non-Volatile relays while a previous write is still in progress*"
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "upl_gnd_relay_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink GND Relay Error: Set to 1 if GND attempts to write to the Non-Volatile relays while a previous write is still in progress*"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "upl_hcd_cmd_exec",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink HCD Command Executed: Set after execution of a hardware command (i.e. 144ms after receiving a good hardware command)*"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "upl_sfc_rel_done",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink SFC Relay Write Done: Set when finished executing an FSW-originated Non-Volatile relay cmd*"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "upl_lck_thresh",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Lock Counter Threshold: Set when any lock counter reaches the value 1000000b*"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "upl_acq_ign",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Acquisition sequence detected on non active port (A-D) and ignored.  See ULSTAT for the specific channel.*"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "sa_dma_bdry_err",
          "access": "rw",
          "reset": 0,
          "doc": "SSIRU DMA boundary check error indicator. See DMABCK Register.  *"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "ul_dma_bdry_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA boundary check error indicator. See DMABCK Register.  *"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "bc_dma_bdry_err",
          "access": "rw",
          "reset": 0,
          "doc": "BC DMA boundary check error indicator. See DMABCK Register.  *"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "Dwnlk_badheader",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Bad Header Indicator"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "dwnlk_timestamp",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Time Correlation Packet sent.  (e.g., read Downlink Frame Start Time)*"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "dwnlk_xmitdone",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Transmit Done: Hardware sets to 1 when frame is done transmitting*"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "ul_nvspi_nack_err",
          "access": "rw",
          "reset": 0,
          "doc": "NVSPI MRAM CRC relay bus interface returned NACK for CRC command*"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "ul_nvspi_comm_err",
          "access": "rw",
          "reset": 0,
          "doc": "NVSPI MRAM CRC relay bus interface error*"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "bcm_dma_err",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller DMA error (see BC DMA status Register for specific error)*"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "ul_dma_overrun",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA overrun (DMA completes before CLTU is done)*"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "ul_dma_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA error (see UL DMA status Register for specific error)*"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "ul_dma_cmplt",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA complete or buffer switched due to Lost Lock, watchdog.*"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "dl_dma_underrun",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA underrun (DMA completes before the frame is done)"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "dl_dma_err",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA error (see 5.6.2.4 DL DMA status Register bits [19:17] for specific error)*"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "dl_dma_cmplt",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA complete*"
        },
        {
          "nbits": 3,
          "lsb": 5,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "bava",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Access Violation Attempt.  Both bus inhibits are asserted when the software attempts to communicate on the 1553 bus during the dead time indicated by DTSTART or DEADP.  Note that DTSTART or DEADP do not by themselves inhibit the transmitters but the BAVA error flag does.*"
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "stdint_1553",
          "access": "rw",
          "reset": 0,
          "doc": "1553 Standard Interrupt: Asserted (logic 1) when one or more events in either the BCM #9 Standard Interrupt Enable Register or BCM Command Block occur. This bit is clearable at the IP level.*\nSource of this bit is driving source of  BCRTM_SIE and cleared by writing 1 to this bit and bit[31]"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "hpint_1553",
          "access": "rw",
          "reset": 0,
          "doc": "1553 High Priority Interrupt: The High-Priority Interrupt is asserted (to logic 1) upon occurrence of events enabled in the BCM #7 High Priority Interrupt Enable Register. This bit is clearable at the IP level.\nSource of this bit is driving source of  BCRTM_HIE and cleared by writing 1 to this bit and bit[31]. *"
        }
      ]
    },
    "eio.system.ip.ie1": {
      "id": "eio.system.ip.ie1",
      "name": "ie1",
      "type": "reg",
      "addr": 3235905584,
      "offset": 16,
      "doc": "Interrupt Enable Register\nInterrupt Enable registers provide the connection between various hardware events and the PCI interrupt signal that is propagated across the backplane to the system interrupt controller. These registers do not prevent the event from turning on the status bit in the Health Status Registers.  Only some bits from the Health Status Register 1’s respective bits in the Interrupt Enable Register, i.e. RTI enable and maybe reset pending will be used for the Europa Clipper Flight Software to form a single PCI interrupt. All potential events that cause a PCI interrupt are disabled (masked) when the board is reset. \nSoftware enables (unmasks) hardware events captured in the Health Status registers by writing a 1 to the respective enable bits in the Interrupt Enable register. Software disables an interrupt by writing a 0. \nAddress offset:\t\t\t0030h\nPOR/PCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "hs_selftst_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Health Status 1 Self Test Enable: Software must set this bit to allow test software to set Health Status bits.  0 at reset."
        },
        {
          "nbits": 3,
          "lsb": 28,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "fdurti_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt on every FDURTI Enable"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "subrti",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt on every SubRTI Enable"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "rti_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt on every RTI Enable"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "deadp_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt on every DEADP Enable"
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "xrti_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt when cross string RTI is detected."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "dtstart_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt when Dead Time Start detected."
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "swarti_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Interrupt on every SWARTI Enable"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "reset_pending_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Reset Pending Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "FDU_CSROnline_TMR_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller Online TMR interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "FDU_CSRPrime_TMR_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller Prime TMR interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "FDU_LBOnline_TMR_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Loop Back Online TMR interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "FDU_LBPrime_TMR_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Loop Back Prime TMR interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "FDU_CSROnline_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller  Online change of state interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "FDU_CSRPrime_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Cross String Controller  Prime change of state interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "FDU_LBOnline_ena",
          "access": "rw",
          "reset": 0,
          "doc": "EIO is Online change of state interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "FDU_LBPrime_ena",
          "access": "rw",
          "reset": 0,
          "doc": "EIO is Prime change of state interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "bc_dberint_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller Double Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "ab_sberint_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller Single Bit Error Interrupt Enable"
        },
        {
          "nbits": 2,
          "lsb": 4,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "pong_dberint_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Pong Double Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "pong_sberint_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Pong Single Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "ping_dberint_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Ping Double Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "ping_sberint_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Ping Single Bit Error Interrupt Enable"
        }
      ]
    },
    "eio.system.ip.ie2": {
      "id": "eio.system.ip.ie2",
      "name": "ie2",
      "type": "reg",
      "addr": 3235905588,
      "offset": 20,
      "doc": "Interrupt Enable Register 2\nInterrupt Enable registers provide the connection between various hardware events and the PCI interrupt signal that is propagated across the backplane to the system interrupt controller. These registers do not prevent the event from turning on the status bit in the Health Status Registers.  Only some bits from the Health Status Register 1’s respective bits in the Interrupt Enable Register 1, i.e. RTI enable and maybe reset pending will be used for the Europa Clipper Flight Software to form a single PCI interrupt.  All potential events that cause a PCI interrupt are disabled (masked) when the board is reset. \nSoftware enables (unmasks) hardware events captured in the Health Status registers by writing a 1 to the respective enable bits in the Interrupt Enable register. Software disables an interrupt by writing a 0. \nAddress offset:\t\t\t0034h\nPOR/PCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "Hs2_selftst_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Health Status 2 Self Test Enable: Software must set this bit to allow test software to set Health Status 2 bits.  0 at reset."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "Upl_Overrun_Err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Buffer Overrun Error Enable"
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "Upl_FSW_Relay_Err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink FSW Relay Error Enable"
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "Upl_GND_Relay_Err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink GND Relay Error Enable"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "Upl_HCD_Cmd_Exec_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink HCD Command Executed Enable"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "Upl_SFC_Rel_Done_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink SFC Relay Write Done Enable"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "Upl_Lck_Thresh_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Lock Counter Threshold Enable"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "Upl_ACQ_IGN_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink acquisition sequence ignored Enable"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "DL_DMA_Bdry_Err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA Boundary Check Error  Enable"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "UL_DMA_Bdry_Err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA Boundary Check Error  Enable"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "BC_DMA_Bdry_Err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553 DMA Boundary Check Error Enable"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "DwnLk_BadHdr_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Bad Header Error Enable"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "DwnLk_Timestamp_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Time Stamp Enable"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "DwnLk_XmitDone_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Transmit Done Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "ul_nvspi_nack_err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "NVSPI MRAM CRC relay bus interface returned NACK for CRC command Int. Enable"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "ul_nvspi_comm_err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "NVSPI MRAM CRC relay bus interface error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "BC_dma_err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller DMA master abort status Enable"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "UL_dma_overrun_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA Overrun Enable"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "UL_dma_err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA error Enable"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "UL_dma_cmplt_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA complete Enable"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "DL_dma_underrun_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA Underrun Enable"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "DL_dma_err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA error Enable"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "DL_dma_cmplt_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA complete Enable"
        },
        {
          "nbits": 3,
          "lsb": 5,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "BAVA_ena",
          "access": "rw",
          "reset": 0,
          "doc": "BAVA interrupt Enable (does not affect the inhibit functionality)"
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "stdint_1553_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553 Standard Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "hpint_1553_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553 High Priority Interrupt: The High-Priority Interrupt is asserted (to logic 1) upon occurrence of events enabled in the BCM #7 High Priority Interrupt Enable Register. This bit is clearable at the IP level.\nSource of this bit is driving source of  BCRTM_HIE and cleared by writing 1 to this bit and bit[31]. *"
        }
      ]
    },
    "eio.system.ip.ip_blk_rsvd_0": {
      "id": "eio.system.ip.ip_blk_rsvd_0",
      "name": "ip_blk_rsvd_0",
      "type": "mem",
      "addr": 3235905592,
      "offset": 24,
      "doc": ""
    },
    "eio.system.edac": {
      "id": "eio.system.edac",
      "name": "edac",
      "type": "blk",
      "addr": 3235905600,
      "offset": 64,
      "doc": "Internal RAM EDAC Registers\nThis section describes the registers needed for internal RAM error detection and correction activity.  All internal RAM EDAC enable bits are controlled from external CRC signal.  When set, EDAC mechanism is enabled, and all RAMs are protected.  The corresponding interrupt status and interrupt enable bits are located in the interrupt control registers. Refer to §9.1 for EDAC setup details.\n\n\nSee §0 & §5.5.1.6 For SRAM EDAC Registers not covered under the internal EDAC registers.",
      "children": [
        "eio.system.edac.edacctl",
        "eio.system.edac.edacint",
        "eio.system.edac.edacers",
        "eio.system.edac.edacbc",
        "eio.system.edac.edacping",
        "eio.system.edac.edacpong"
      ]
    },
    "eio.system.edac.edacctl": {
      "id": "eio.system.edac.edacctl",
      "name": "edacctl",
      "type": "reg",
      "addr": 3235905600,
      "offset": 0,
      "doc": "EDAC Control Register\nThis control register allows manipulation of EDAC mechanism.  For “test mode enable”, “Select” and EDAC_Dis bits it is required that EIO is in “FLIGHT TEST MODE”.  FLIGHT TEST MODE is achieved through the FLIGHT_TEST_MODE bit which is located in §5.2.4.1.  If EDAC_INH is cleared all other bits are cleared.  If an interface’s software Disable is on Test and Slct bits of the corresponding interface are cleared.\nAddress offset:\t\t0040h\ncPCI reset value: \t\t0000 000? u000 0000 0000 0000 0000 0000b\t(? = External signal)\nPOR value: \t\t0000 000? 0000 0000 0000 0000 0000 0000b\t(? = External signal)\n\nRW‡\tRequires Function Code, EX_EDAC_Dis bit cleared and sram_slftst_enb from the SEDAC register bit set to write; ignored and cleared otherwise.\nRW†\tRequires Function Code, EX_EDAC_Dis bit cleared to write; ignored and cleared otherwise.\nRW††\tRequires Function Code, both corresponding EDAC_Dis bits cleared and RAM_SlfChk_Ena in DC_REG is set to write; ignored and cleared otherwise.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "wo",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1010 Allow test bit, Test and/or select bit to be enabled. (set to 1)\n0101 Allow test bit, Test and/or select bit to be disabled (reset to 0)\n0110 Allow Software EDAC_Dis bits to clr (This enables EDAC)\n1001 Allow Software EDAC_Dis bits to set. (This disables EDAC)\n1100 Allow sram_sel_reg to be written.\n\nFunction Code (3:0):  Four separate functions may be directed on the remaining bits depending on the state of these bits during the write to this register.   These bits read back as “0000”.  Write a 1 to the associated bit(s) below to invoke the desired Function Code action."
        },
        {
          "nbits": 7,
          "lsb": 21,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "bp_edac_inh",
          "access": "ro",
          "reset": 0,
          "doc": "'From Backplane:  EDAC Inhibit (BP_ECE_EIO_EDAC_INH)\n1 = All EDAC circuits on the EIO FPGA can be disabled by software \n0 = All EDAC circuits on the EIO FPGA cannot be disabled by software"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "sram_sel_reg",
          "access": "rw",
          "reset": 0,
          "doc": "SRAM Select. Selects between SRAM 0 or SRAM 1, must use function code above while writing. Reset with POR to SRAM 0.\nWhen set to “0”, SRAM 0 is selected.\nWhen set to “1”, SRAM 1 is selected."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "sram_edac_dis",
          "access": "rw",
          "reset": 0,
          "doc": "When set to “1”, disables SRAM EDAC, which means data read out of SRAM is raw and uncorrected.  This bit does NOT require FLT_TEST_MODE to be active.\nWhen set to “0”, EDAC is enabled (unless the EDAC_INHIBIT backplane discrete is enabled). †"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "sram_edac_test",
          "access": "rw",
          "reset": 0,
          "doc": "When set to “1” bypasses the SRAM EDAC syndrome generator circuit if the sram_slftst_enb from the SEDAC register is set.  Setting this bit to “1” when the sram_slftst_enb is not set has no effect on the EDAC circuit (i.e. syndrome generator circuit is not bypassed).  When successfully asserted, the EDAC syndrome bits stored in SRAM will be directly written whenever software writes 32 bit data to SRAM. The value written to the syndrome bits will be equal to the 7 least significant bits of the 32 bit data written to SRAM.  See Register description above for details.\n\nWhen set to “0” the EDAC circuit is not in test mode and functions normally regardless of the state of the sram_slftst_enb input. ‡"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "sram_syn_sel",
          "access": "rw",
          "reset": 0,
          "doc": "When set to “1”, hardware returns/writes the 7 bit syndrome value (all other bits are 0) associated with the SRAM address being read.\nWhen set to “0”, hardware returns/writes the 32 bit data value.\nNote:  Assertion of this bit (“1”) will have effect only if both the sram_slftst_enb from the SEDAC register and the SRAM_EDAC_Test_Ena bit are asserted.  Otherwise, hardware treats this bit as “0”. ‡"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "bc_edac_dis",
          "access": "rw",
          "reset": 0,
          "doc": "Software controlled EDAC Enable/Disable.  Ignored when External EDAC Dis. above is set."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "bc_test",
          "access": "rw",
          "reset": 0,
          "doc": "BC EDAC test mode enable. Only data or syndrome bits are read/written, based on Slct below."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "bc_slct",
          "access": "rw",
          "reset": 0,
          "doc": "BC EDAC Select: When set data will be written to syndrome bits, otherwise to data bits."
        },
        {
          "nbits": 5,
          "lsb": 7,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "pong_edac_dis",
          "access": "rw",
          "reset": 0,
          "doc": "Software controlled EDAC Enable/Disable.  Ignored when External EDAC Dis. above is set. †"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "pong_test",
          "access": "rw",
          "reset": 0,
          "doc": "Pong EDAC test mode enable. Only data or syndrome bits are read/written, based on Slct below. ††"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "pong_slct",
          "access": "rw",
          "reset": 0,
          "doc": "Pong EDAC Select: When set data will be written to syndrome bits, otherwise to data bits. ††"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "ping_edac_dis",
          "access": "rw",
          "reset": 0,
          "doc": "Software controlled EDAC Enable/Disable. Ignored when External EDAC Dis. above is set. †"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "ping_test",
          "access": "rw",
          "reset": 0,
          "doc": "Ping EDAC test mode enable. Only data or syndrome bits are read/written, based on Slct below. ††"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "ping_slct",
          "access": "rw",
          "reset": 0,
          "doc": "Ping EDAC Select: When set data will be written to syndrome bits, otherwise to data bits. ††"
        }
      ]
    },
    "eio.system.edac.edacint": {
      "id": "eio.system.edac.edacint",
      "name": "edacint",
      "type": "reg",
      "addr": 3235905608,
      "offset": 8,
      "doc": "EDAC Error Counter Status Control\nThis register controls how many single bit errors are allowed to occur before an event is generated.  \nAddress offset:\t\t\t0048h\t\t\t\t\t\nPOR/cPCI reset value: \t\t07E0 1FBFh",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function Code (3:0):  To save software from doing a read modify write, the Function Code bits will indicate which Function’s count should be changed.\n\nFunction_Code(3:0) Function\n1001 Allow Ping Counter Control to be modified\n0110 Allow Pong Counter Control to be modified\n0101 Allow BC Counter Control to be modified\n\nThese bits read back as 0000."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 6,
          "lsb": 21,
          "name": "bc_errintctrl",
          "access": "rw",
          "reset": 63,
          "doc": "BC memory single bit error count at which health status should be generated.\nRequires correct Function Code bits above to write."
        },
        {
          "nbits": 8,
          "lsb": 13,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 6,
          "lsb": 7,
          "name": "pong_errintctrl",
          "access": "rw",
          "reset": 63,
          "doc": "Pong memory single bit error count at which health status should be generated.\nRequires correct Function Code bits above to write."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "ping_errintctl",
          "access": "rw",
          "reset": 63,
          "doc": "Ping memory single bit error count at which health status should be generated.\nRequires correct Function Code bits above to write."
        }
      ]
    },
    "eio.system.edac.edacers": {
      "id": "eio.system.edac.edacers",
      "name": "edacers",
      "type": "reg",
      "addr": 3235905612,
      "offset": 12,
      "doc": "EDAC Error Status and Control Register\nThis register holds the count value of EDAC single bit errors that were detected & corrected.  For reference it also shows the corresponding EDAC logic’s double bit error indicator from the Pending Interrupt register.  A health status event will be generated once the number of single bit error corrected reach the value of EDAC Error Counter Control Register §0.  The Error counters do not roll over and will reach and stay at the maximum value of 3fh if not cleared by software.  EDAC single bit errors will be counted without indication of syndrome or data bits.  The error counter does not roll over and will hold its maximum value.  To generate an intentional single bit interrupt, set the count equal to the interrupt control value of the corresponding interface.\nNOTE: Writing to this register when any of the counts are equal to the corresponding trigger value in EDACINT an health status is generated, even if the WRITE action is meant to clear an existing status.\nAddress offset:\t\t\t004Ch\t\t\t\t\t\ncPCI reset value: \t\t\t0uuu uuuuh ( u = unchanged)\nPOR reset value: \t\t\t0000 0000h\n\nRW‡  Requires correct Function Code bits to write.\nRW*  Write “1” to clear  and writing “0” has no effect.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "wo",
          "reset": 0,
          "doc": "Function Code (3:0):  To save software from doing a read modify write, the Function Code bits will indicate which Function’s count should be changed.\n\nFunction_Code(3:0) Function\n0101 Allow BC Counter to be modified\n1001 Allow Ping Counter to be modified\n0110 Allow Pong Counter to be modified\n\n\nThese bits read back as 0000"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "bc_dberr",
          "access": "rw",
          "reset": 0,
          "doc": "BC RAM double bit error  RW*"
        },
        {
          "nbits": 6,
          "lsb": 21,
          "name": "bc_sberrct",
          "access": "rw",
          "reset": 0,
          "doc": "BC RAM single bit error counter  RW‡"
        },
        {
          "nbits": 7,
          "lsb": 14,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "pong_dberr",
          "access": "rw",
          "reset": 0,
          "doc": "Pong RAM double bit error  RW*"
        },
        {
          "nbits": 6,
          "lsb": 7,
          "name": "pong_sberrct",
          "access": "rw",
          "reset": 0,
          "doc": "Pong RAM single bit error counter  RW‡"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "ping_dberr",
          "access": "rw",
          "reset": 0,
          "doc": "Ping RAM double bit error  RW*"
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "ping_sberrct",
          "access": "rw",
          "reset": 0,
          "doc": "Ping RAM single bit error counter  RW‡"
        }
      ]
    },
    "eio.system.edac.edacbc": {
      "id": "eio.system.edac.edacbc",
      "name": "edacbc",
      "type": "reg",
      "addr": 3235905616,
      "offset": 16,
      "doc": "BC EDAC Error Address Registers\nThese registers save the physical address of the last RAM access that caused an EDAC error.  Each RAM interface, namely BC Buffer (12 bits), Downlink Ping buffer (9 bit), Downlink Pong buffer (9 bit) has a separate address register.  RMAP RAM only has Parity. Single bit error addresses will be overwritten with new single bit error addresses.  Double bit error addresses will not be overwritten till the corresponding error bit in the originating module is cleared.\nAddress offset for BC Ram (EDACBCADR):\t0050h\n\ncPCI reset value:\t\t0000 0uuuh\t(u = unchanged)\nPOR reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 0,
          "doc": "Single bit or double bit error address location.  Double bit error addresses are not overwritten unless corresponding interrupt bit is cleared.\nAddress width for each ram interface is:\n\tBC buffer; 12 bits wide"
        }
      ]
    },
    "eio.system.edac.edacping": {
      "id": "eio.system.edac.edacping",
      "name": "edacping",
      "type": "reg",
      "addr": 3235905620,
      "offset": 20,
      "doc": "EDAC Error Address Registers\nThese registers save the physical address of the last RAM access that caused an EDAC error.  Each RAM interface, namely BC buffer (12 bits), Downlink Ping buffer (9 bit), Downlink Pong buffer (9 bit) has a separate address register.  RMAP RAM only has Parity. Single bit error addresses will be overwritten with new single bit error addresses.  Double bit error addresses will not be overwritten till the corresponding error bit in the originating module is cleared.\nAddress offset for Ping Ram (EDACPI):\t0054h\nAddress offset for Pong Ram (EDACPO):\t0058h \n\ncPCI reset value:\t\t0000 0uuuh\t(u = unchanged)\nPOR reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 23,
          "lsb": 9,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 9,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 0,
          "doc": "Single bit or double bit error address location.  Double bit error addresses are not overwritten unless corresponding interrupt bit is cleared.\nAddress width for each ram interface is:\n\tDownlink Ping buffer; 9 bits wide\n\tDownlink Pong buffer; 9 bits wide"
        }
      ]
    },
    "eio.system.edac.edacpong": {
      "id": "eio.system.edac.edacpong",
      "name": "edacpong",
      "type": "reg",
      "addr": 3235905624,
      "offset": 24,
      "doc": "EDAC Error Address Registers\nThese registers save the physical address of the last RAM access that caused an EDAC error.  Each RAM interface, namely BC buffer (12 bits), Downlink Ping buffer (9 bit), Downlink Pong buffer (9 bit) has a separate address register.  RMAP RAM only has Parity. Single bit error addresses will be overwritten with new single bit error addresses.  Double bit error addresses will not be overwritten till the corresponding error bit in the originating module is cleared.\nAddress offset for Ping Ram (EDACPI):\t0054h\nAddress offset for Pong Ram (EDACPO):\t0058h \n\ncPCI reset value:\t\t0000 0uuuh\t(u = unchanged)\nPOR reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 23,
          "lsb": 9,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 9,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 0,
          "doc": "Single bit or double bit error address location.  Double bit error addresses are not overwritten unless corresponding interrupt bit is cleared.\nAddress width for each ram interface is:\n\tDownlink Ping buffer; 9 bits wide\n\tDownlink Pong buffer; 9 bits wide"
        }
      ]
    },
    "eio.system.tz": {
      "id": "eio.system.tz",
      "name": "tz",
      "type": "blk",
      "addr": 3235905632,
      "offset": 96,
      "doc": "TZ and GND Test Registers",
      "children": [
        "eio.system.tz.tzstr"
      ]
    },
    "eio.system.tz.tzstr": {
      "id": "eio.system.tz.tzstr",
      "name": "tzstr",
      "type": "reg",
      "addr": 3235905636,
      "offset": 4,
      "doc": "TZ and Test Mode Connection Status\nThis register shows the state of the external pins that either power the Time Zero signals or indicate that test mode functionality is allowed.  This is to prevent any accidental selection of test mode for any of the individual modules on the board.  See §18.2 for further explanation of special test modes.\nAddress offset:\t\t0064h \t\t\t\t\t\t\t\ncPCI reset value: \t???0 00?0 0000 0111 ???? 1100 ??u? ???? (? = set externally)\nPOR reset value: \t???0 00?0 0000 0111 ???? 1100 ??1? ???? (? = set externally)",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "tz_uplink_select",
          "access": "ro",
          "reset": 0,
          "doc": "Set if in GND_TEST_MODE and bits tz_cmd_enable is set. When set, TZ Uplink is selected as the command source to HCD when auto-select is off, and as one of the 3 sources during auto-select."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "gnd_test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "Set if TZ_TEST_ENABLE & TZ_PGOOD on the FPGA, reflected below and controlled by GSE are set. This is an indicator to software that the TZ interface is connected to the spacecraft and ground testing functions should be available for use. This signal also gets distributed via the backplane to other boards."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "flt_test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "This FPGA_TEST_MODE_ENA connects to connects to a CRC1. By itself, this bit being set does not affect the operation of the hardware. If set, EDAC “testmode” read-only bit fields become writable. Should software write to those bit fields at that time, it is possible that the operation of the hardware will change."
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "tz_hw_test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "FPGA sim black box special test mode.  Set if bits TZ_PRESENT, TZ_TEST_ENABLEn, TZ_PGOOD, HW_TEST_MODE input pins are set and register bit hw_test_mode_ena are set.\nThe value of this bit DOES affect hardware operation even without further software action."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "radio_bb_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select to route TxBB signals to TZ rather than the EIO Downlink, also enables RXBB_Ena."
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "sse_test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "Set if in GND_TEST_MODE and bits sse_present is set. Allows sending SSIRU data via the SSE port."
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "lv_ovp_rst",
          "access": "rw",
          "reset": 0,
          "doc": "Launch Vehicle Over Voltage Power circuit reset.  This is a discrete and needs to be written twice, once on, and once off. If held high the circuit will be in reset state at all times.  Tristated by LV Output Disabled and has no effect in flight."
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "lv_ovp",
          "access": "ro",
          "reset": 0,
          "doc": "Launch Vehicle Over Voltage indicator.  Software needs to toggle above bit to clear the circuit."
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "tz_out_spare2",
          "access": "rw",
          "reset": 0,
          "doc": "Output TZ_OUT_SPARE2 follows the state of this bit if gse_pgood is on, tristate-ed if not."
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "tz_out_spare1",
          "access": "rw",
          "reset": 0,
          "doc": "Output TZ_OUT_SPARE1 follows the state of this bit if gse_pgood is on, tristate-ed if not."
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "gse_swen_out",
          "access": "ro",
          "reset": 0,
          "doc": "Actual gse_swen output.  GSE_SWEN bit below validated with TZ_PRESENT."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "pcu_pwrgood",
          "access": "ro",
          "reset": 0,
          "doc": "PCU power good status, if software is able to read this bit then for sure this bit is on like the other two below."
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "p1p8v_pgood",
          "access": "ro",
          "reset": 0,
          "doc": "1.8V power is required for the EM/FLT board SRAM’s to function.  Software does not control this bit and should report this fatal error for most likely SRAM’s are not functioning."
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "p1p5v_pgood",
          "access": "ro",
          "reset": 0,
          "doc": "If this bit is not set, make sure eio is plugged in and the cup holder tray is closed. FPGA core 1.5V power status."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "sse_present",
          "access": "ro",
          "reset": 0,
          "doc": "Duplicate of SSIRU SSE_SSIRU_Sel indicator (Note: It requires TZ power on the board)"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "iso_pgood",
          "access": "ro",
          "reset": 0,
          "doc": "Isolated 3.3V power good indicator for the LV signals."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "gse_pgood",
          "access": "ro",
          "reset": 0,
          "doc": "GSE power good indicator. Together with other signals enables GND_TEST_MODE above that also gets distributed to other boards."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "lv_pgood",
          "access": "ro",
          "reset": 0,
          "doc": "LV power good indicator."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "lv_eo",
          "access": "rw",
          "reset": 1,
          "doc": "This bit controls the signal lv_oe_n which follows LV_PGOOD and used for prototype boards only. On by default but a good practice to disable for flight even though it only goes to a test pad for flight.  This bit along with iso_swen is required to see LV_PGOOD reflected in the lv_pgood register. It also tristates all FPGA LV signals if not enabled."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "iso_swen",
          "access": "rw",
          "reset": 0,
          "doc": "This bit directly controls the board output signal ISO_SWEN.  This bit is enabled by default because its required for the EIO board to pass the state of LV_PGOOD and ISO_PGOOD to the FPGA and hence the bits above. It’s a good practice to disable this bit after separation for flight.  Proto board also requires lv_oe to be set."
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "hw_test_mode_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Enable Hardware test mode. Only effective if in GND_TEST_MODE."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "hw_test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "Input pin HW_TEST_MODE which has no physical connection on the board but on the FPGA, used only for simulation."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "tz_in_spare",
          "access": "ro",
          "reset": 0,
          "doc": "This bit follows the state of FPGA input TZ_IN_SPARE when in GND_TEST_MODE"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "gse_swen",
          "access": "rw",
          "reset": 1,
          "doc": "This bit controls the GSE Switch Enable whish is required for TZ operation.  This bit is set by default to allow hardware to see the presence of TZ power.  Software should set this bit to 0, which will turn off the ability to see TZ Power and any TZ signal control or status during flight."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "tz_cmd_enable",
          "access": "ro",
          "reset": 0,
          "doc": "This is an input pin on the FPGA, controlled by GSE. Together with GND_TEST_MODE forces the selection of TZ Uplink when auto-select is off. (See TZ_UPLINK_SELECT above) At launch, the TZ umbilical is cut. In order to ensure the HCD does not continue to force the selection of the TZ Uplink channel after launch, there are 2 inputs, each of which must be set, in combination with auto-select-off in order for that override to take place."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "tz_oe",
          "access": "rw",
          "reset": 1,
          "doc": "This bit controls the signal tz_oe_n which follows TZ_PRESENT and used for prototype boards only.  On following TZ_PRESENT or TZ_ALIVE and enables the TZ output signals. Good practice to disable for flight.  This bit is required to see TZ_PGOOD reflected in the tz_pgood register.  It also tristates all FPGA TZ, SFC and BB signals when not enabled."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "tz_test_enable",
          "access": "ro",
          "reset": 0,
          "doc": "This is a low active input pin called TZ_TEST_ENABLEn on the FPGA, controlled by GSE. Together with other signals enables GND_TEST_MODE above that also gets distributed to other boards."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "tz_pgood",
          "access": "ro",
          "reset": 0,
          "doc": "This is an input pin called TZ_PGOOD on the FPGA, controlled by GSE. Together with other signals in this register enables GND_TEST_MODE above, that also gets distributed to other boards."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "tz_present",
          "access": "ro",
          "reset": 0,
          "doc": "This is an input pin called TZ_PRESENT or TZ_ALIVE on the FPGA, controlled by GSE. Together with other signals enables GND_TEST_MODE above, that also gets distributed to other boards.  Note that this signal is negated on the Prototype boards."
        }
      ]
    },
    "eio.system.dma_boundary": {
      "id": "eio.system.dma_boundary",
      "name": "dma_boundary",
      "type": "blk",
      "addr": 3235905640,
      "offset": 104,
      "doc": "DMA Boundary Check Registers\nA boundary checking logic was added to the following DMAs: uplink, 1553 BC, SSIRU. The boundary checking logic consists of software controlled lower and upper boundary registers, a 32 bits comparator and an interrupt bit. The DMA engines will stop and generate error flags and interrupts when They detect an out of boundary condition.\nThe registers are located in the System functional group in the memory map.",
      "children": [
        "eio.system.dma_boundary.uldlo",
        "eio.system.dma_boundary.uldup",
        "eio.system.dma_boundary.bcdlo",
        "eio.system.dma_boundary.bcdup",
        "eio.system.dma_boundary.sadlo",
        "eio.system.dma_boundary.sadup"
      ]
    },
    "eio.system.dma_boundary.uldlo": {
      "id": "eio.system.dma_boundary.uldlo",
      "name": "uldlo",
      "type": "reg",
      "addr": 3235905640,
      "offset": 0,
      "doc": "DMA Lower Address Boundary Registers\nThis register is set by software to indicate the lower address boundary for the Uplink DMA access.\nUplink DMA Lower Address Boundary (ULDLO) Address offset:\t068h \nBC DMA Lower Address Boundary (BCDLO) Address offset:\t\t070h\nSSIRU DMA Lower Address Boundary (SADLO) Address offset:\t078h \n\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "rw",
          "reset": 0,
          "doc": "Lower address boundary for DMA access."
        }
      ]
    },
    "eio.system.dma_boundary.uldup": {
      "id": "eio.system.dma_boundary.uldup",
      "name": "uldup",
      "type": "reg",
      "addr": 3235905644,
      "offset": 4,
      "doc": "DMA Upper Address Boundary Register\nThis register is set by software to indicate the upper address boundary for the DMA access.\nUplink DMA Lower Address Boundary (ULDUP) Address offset:\t06Ch \nBC DMA Lower Address Boundary (BCDUP) Address offset:\t\t074h\nSSIRU DMA Lower Address Boundary (SAUP) Address offset:\t07Ch \n\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\tFFFF_FFFCh",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "rw",
          "reset": 4294967292,
          "doc": "Upper address boundary for DMA access."
        }
      ]
    },
    "eio.system.dma_boundary.bcdlo": {
      "id": "eio.system.dma_boundary.bcdlo",
      "name": "bcdlo",
      "type": "reg",
      "addr": 3235905648,
      "offset": 8,
      "doc": "DMA Lower Address Boundary Registers\nThis register is set by software to indicate the lower address boundary for the Uplink DMA access.\nUplink DMA Lower Address Boundary (ULDLO) Address offset:\t068h \nBC DMA Lower Address Boundary (BCDLO) Address offset:\t\t070h\nSSIRU DMA Lower Address Boundary (SADLO) Address offset:\t078h \n\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "rw",
          "reset": 0,
          "doc": "Lower address boundary for DMA access."
        }
      ]
    },
    "eio.system.dma_boundary.bcdup": {
      "id": "eio.system.dma_boundary.bcdup",
      "name": "bcdup",
      "type": "reg",
      "addr": 3235905652,
      "offset": 12,
      "doc": "DMA Upper Address Boundary Register\nThis register is set by software to indicate the upper address boundary for the DMA access.\nUplink DMA Lower Address Boundary (ULDUP) Address offset:\t06Ch \nBC DMA Lower Address Boundary (BCDUP) Address offset:\t\t074h\nSSIRU DMA Lower Address Boundary (SAUP) Address offset:\t07Ch \n\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\tFFFF_FFFCh",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "rw",
          "reset": 4294967292,
          "doc": "Upper address boundary for DMA access."
        }
      ]
    },
    "eio.system.dma_boundary.sadlo": {
      "id": "eio.system.dma_boundary.sadlo",
      "name": "sadlo",
      "type": "reg",
      "addr": 3235905656,
      "offset": 16,
      "doc": "DMA Lower Address Boundary Registers\nThis register is set by software to indicate the lower address boundary for the Uplink DMA access.\nUplink DMA Lower Address Boundary (ULDLO) Address offset:\t068h \nBC DMA Lower Address Boundary (BCDLO) Address offset:\t\t070h\nSSIRU DMA Lower Address Boundary (SADLO) Address offset:\t078h \n\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "rw",
          "reset": 0,
          "doc": "Lower address boundary for DMA access."
        }
      ]
    },
    "eio.system.dma_boundary.sadup": {
      "id": "eio.system.dma_boundary.sadup",
      "name": "sadup",
      "type": "reg",
      "addr": 3235905660,
      "offset": 20,
      "doc": "DMA Upper Address Boundary Register\nThis register is set by software to indicate the upper address boundary for the DMA access.\nUplink DMA Lower Address Boundary (ULDUP) Address offset:\t06Ch \nBC DMA Lower Address Boundary (BCDUP) Address offset:\t\t074h\nSSIRU DMA Lower Address Boundary (SAUP) Address offset:\t07Ch \n\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR: \t\tFFFF_FFFCh",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "rw",
          "reset": 4294967292,
          "doc": "Upper address boundary for DMA access."
        }
      ]
    },
    "eio.system.system_page_rsvd_0": {
      "id": "eio.system.system_page_rsvd_0",
      "name": "system_page_rsvd_0",
      "type": "mem",
      "addr": 3235905664,
      "offset": 128,
      "doc": ""
    },
    "eio.radio": {
      "id": "eio.radio",
      "name": "radio",
      "type": "blk",
      "addr": 3235913728,
      "offset": 8192,
      "doc": "RADIO Interface Registers\nEIO FPGA supports up to 2 Space Wire Frontier Radios.  Each radio has its own separate group of Space Wire Control & Status registers.  \nSpace Wire Instrument Control and Status register sets, Radio Space Wire A & Radio Space Wire B, have the same function and bit definitions.  Therefore, only Space Wire Instrument-1 Control and Status registers are described in detail.  The address offset is relative to each instrument group base is listed in table above.",
      "children": [
        "eio.radio.spwiprev",
        "eio.radio.spwfes",
        "eio.radio.spwsea",
        "eio.radio.spwecra",
        "eio.radio.spwpica",
        "eio.radio.spwtica",
        "eio.radio.spwrca",
        "eio.radio.spwrsa",
        "eio.radio.spwera",
        "eio.radio.spwseb",
        "eio.radio.spwecrb",
        "eio.radio.spwpicb",
        "eio.radio.spwticb",
        "eio.radio.spwrcb",
        "eio.radio.spwrsb",
        "eio.radio.spwerb",
        "eio.radio.radio_page_rsvd_0"
      ]
    },
    "eio.radio.spwiprev": {
      "id": "eio.radio.spwiprev",
      "name": "spwiprev",
      "type": "reg",
      "addr": 3235913728,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.radio.spwfes": {
      "id": "eio.radio.spwfes",
      "name": "spwfes",
      "type": "reg",
      "addr": 3235913732,
      "offset": 4,
      "doc": "SPW Link FIFO Error Status Register\nThis register provides the Space Wire core’s FIFO EDAC correction syndrome status.  Please see the Goddard Space Flight Center SpaceWire Node Specification 561-SPEC-002  Revision E. for details.  A write of 0 to the fields will generate a pulse to clear the status.\nAddress offset SPWFES:\t\t2004h\ncPCI Reset:\tuuuu uuuuh\t(u = unchanged)\nPOR Reset:\t0000 0000h\t(u = unchanged)\n\n\nTable 6 EDAC Error Syndrome Definition",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 4,
          "lsb": 24,
          "name": "rxswrderrsynb",
          "access": "rw",
          "reset": 0,
          "doc": "Status of the most recent space wire core B receive switch fifo edac error correction syndrome per Table 6. Use err_fifo_clr to clear. Use rxswwrderrsyn to inject errors."
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rxlkrderrsynb",
          "access": "rw",
          "reset": 0,
          "doc": "Status of the most recent space wire core B receive link fifo edac error correction syndrome per Table 6. Use err_fifo_clr to clear. Use rxlkwrerrsyn to inject errors."
        },
        {
          "nbits": 4,
          "lsb": 16,
          "name": "txrderrsynb",
          "access": "rw",
          "reset": 0,
          "doc": "Status of the most recent space wire core B transmit fifo edac error correction syndrome per Table 6. Use err_fifo_clr to clear. Use txwrerrsyn to inject errors."
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "rxswrderrsyna",
          "access": "rw",
          "reset": 0,
          "doc": "Status of the most recent space wire core A receive switch fifo edac error correction syndrome per Table 6. Use err_fifo_clr to clear. Use rxswwrderrsyn to inject errors."
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "rxlkrderrsyna",
          "access": "rw",
          "reset": 0,
          "doc": "Status of the most recent space wire core A receive link fifo edac error correction syndrome per Table 6. Use err_fifo_clr to clear. Use rxlkwrerrsyn to inject errors."
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "txrderrsyna",
          "access": "rw",
          "reset": 0,
          "doc": "Status of the most recent space wire core A transmit fifo edac error correction syndrome per Table 6. Use err_fifo_clr to clear. Use txwrerrsyn to inject errors."
        }
      ]
    },
    "eio.radio.spwsea": {
      "id": "eio.radio.spwsea",
      "name": "spwsea",
      "type": "reg",
      "addr": 3235913736,
      "offset": 8,
      "doc": "Radio SpW Status and Error Register\nEIO supports two identical Space Wire radios this register is duplicated for each interface.\nAddress offset Radio A:\t2008h\nAddress offset Radio B:\t2028h\nPCI Reset: \tuuuu_uuuu (u = unchanged)\nPOR Reset:\t0000 0000h\n\n*SPW, Space Wire Core direct signals.",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 3,
          "lsb": 24,
          "name": "parity_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "ParityErrCnt = count of number of odd parity errors (latched at 7) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "esc_err",
          "access": "ro",
          "reset": 0,
          "doc": "Escape Error  (“1” when ESC is followed by something other than FCT or Data, Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "fct_err1",
          "access": "ro",
          "reset": 0,
          "doc": "FlowControlErr1 (“1” when Rx more N-Char (data, EOP, EEP) than credits, Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "fct_err2",
          "access": "ro",
          "reset": 0,
          "doc": "FlowControlErr2 (“1” when Rx more credits than allowed, Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "data_rx",
          "access": "ro",
          "reset": 0,
          "doc": "DataChrReceived = “1” when node receives one N-Char after a link reset (Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "fct_rx",
          "access": "ro",
          "reset": 0,
          "doc": "FlowCntrlReceived = “1” when 1st FCT arrives.  Clears with link reset (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "null_rx",
          "access": "ro",
          "reset": 0,
          "doc": "NullChrReceived =”1” when 1st Null received since link reset.  Clears with link rest (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "pticksent",
          "access": "ro",
          "reset": 0,
          "doc": "Pulses high for 1 clock after timecode is transmitted.  Indicates another time code can be sent.  Useful for test (not expected to be needed with 1 Hz timecodes) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 3,
          "lsb": 12,
          "name": "state",
          "access": "ro",
          "reset": 1,
          "doc": "Radio SPW Status State.\n“001” indicates “ERROR_RESET” state,\n“010” indicates “ERROR_WAIT” state,\n“011” indicates “READY” state.\n“100” indicates “STARTED” state.\n“101” indicates “PRE-CONNECTING” state.\n“110” indicates “CONNECTING” state.\n“111” indicates “RUN” state.\nIt is observed that Radio SPW stays in READY state when the Radio SPW Enable bit is 0. Instrument is in Run state when the Space Wire flow control is successfully established."
        },
        {
          "nbits": 2,
          "lsb": 10,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "linkdown",
          "access": "ro",
          "reset": 1,
          "doc": "Current Space Wire Core Link Indicator. Immediately at power on there is no link, but should be established momentarily."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "rsvd_4",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "lrst_cnt_ovr",
          "access": "ro",
          "reset": 0,
          "doc": "Link Reset Count Overflow. Number of Link Reset events. Counter does not roll over."
        },
        {
          "nbits": 7,
          "lsb": 0,
          "name": "lrst_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Link Reset Count.  Number of Link Reset events.  Counter does not roll over.  Count cleared by writing 0x00 to this register.  Does not count the power on initial no link."
        }
      ]
    },
    "eio.radio.spwecra": {
      "id": "eio.radio.spwecra",
      "name": "spwecra",
      "type": "reg",
      "addr": 3235913740,
      "offset": 12,
      "doc": "Radio SpW Error Clear/Inject Register\nEIO supports two identical Space Wire radios this register is duplicated for each interface.\nAddress Offset Radio A:\t200Ch\nAddress Offset Radio B:\t202Ch\nPCI Reset:\tuuuu uuuuh\nPOR Reset:\t0000 0000h\n\n\n†Requires bit 31 to set and clear.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "set_clr_bit",
          "access": "rw",
          "reset": 0,
          "doc": "The value of this bit will be written to all control bits with a “1” assigned.  (e.g. writing 0x8000_0400 to this register will set bit 10 to “1” and writing 0x0000_0400 will set the bit to “0”. (Does not apply to bits [23:12])"
        },
        {
          "nbits": 3,
          "lsb": 28,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "txparerrinject",
          "access": "rw",
          "reset": 0,
          "doc": "TxParityErrInject rising edge is used to inject a parity error at the transmitter of the link, to be seen by the receiver at the other end. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "rxswwrerrinj",
          "access": "rw",
          "reset": 0,
          "doc": "RxSwitchWrErrInj can be used to inject EDAC errors status as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "rxlkwrerrinj",
          "access": "rw",
          "reset": 0,
          "doc": "RxLinkWrErrInj can be used to inject EDAC errors using rxlkwrerrsyn. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "txwrerrinj",
          "access": "rw",
          "reset": 0,
          "doc": "TxWrErrInj can be used to inject EDAC errors as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rxswwrerrsyn",
          "access": "rw",
          "reset": 0,
          "doc": "RxSwitchWrErrInj can be used to inject EDAC errors as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec."
        },
        {
          "nbits": 4,
          "lsb": 16,
          "name": "rxlkwrerrsyn",
          "access": "rw",
          "reset": 0,
          "doc": "RxLinkWrErrSyn[3:0] report EDAC error information as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec."
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "txwrerrsyn",
          "access": "rw",
          "reset": 0,
          "doc": "TxWrErrSyn[3:0] can be used to inject EDAC errors as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec."
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "err_fifo_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Clears error in Rx Link FIFO (RxLinkErrSyn), error in Rx Switch FIFO (RxSwitchErrSyn) & Clears error in Tx Switch FIFO (TxRdErrSyn)"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "lrst_ovr_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Link Reset Overflow Clear.  Software writes a 1 to clear the Link Reset Overflow.  Software should writes a 0 to re-enable the Link Reset Count. †"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "lrst_ct_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Link Reset Count Clear.  Software writes a 1 to clear the Link Reset Count.  Software should writes a 0 to re-enable the Link Reset Count. †"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "statusclear",
          "access": "rw",
          "reset": 0,
          "doc": "Used to clear the latched values in parity_cnt, esc_err, fct_err1, and fct_err2†"
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "link_start",
          "access": "rw",
          "reset": 1,
          "doc": "Enables the link SpW FSM. †"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "enable",
          "access": "rw",
          "reset": 1,
          "doc": "Radio SWP Enable bit.  This bit is enabled by default to accept Uplink commands. †"
        }
      ]
    },
    "eio.radio.spwpica": {
      "id": "eio.radio.spwpica",
      "name": "spwpica",
      "type": "reg",
      "addr": 3235913744,
      "offset": 16,
      "doc": "Radio SPW Packet Identifier Count\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  This counter counts the number of SPW packets of different Packet Identifier (P.I.).  Only two P.I. are expected but all are counted.  This register also includes count of Illegal CCSDS Packets [31:24]\nAddress Offset Radio A:\t2010h\nAddress Offset Radio B:\t2030h\nPCI Reset:\tuuuu uuuuh\nPOR:\t0000 0000h",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "ccsds_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "P.I.=0x02 Count\nRadio CCSDS Packet count.  All packets marked with Packet Identifier 0x02.  i.e. Downlink Requests, Uplink or other undefined Transaction ID.  This counter does not roll over.  Count cleared by writing 0x0000_0000 to this register."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rmap_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "P.I.=0x01 Count\nRadio RMAP Status Message and/or Command Response Count.  Packet Identifier 0x01.  This counter does not roll over.  Count cleared by writing 0x0000_0000 to this register."
        }
      ]
    },
    "eio.radio.spwtica": {
      "id": "eio.radio.spwtica",
      "name": "spwtica",
      "type": "reg",
      "addr": 3235913748,
      "offset": 20,
      "doc": "Radio SPW Transaction Identifier Count\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  This counter counts the number of SPW packets of Transaction ID 0x55.\nAddress Offset Radio A:\t2014h\nAddress Offset Radio B:\t2034h\nPCI Reset:\tuuuu uuuuh\nPOR Reset:\t0000 0000h",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "ulfr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Radio CCSDS Uplink/Lander Return Packet Transaction ID 0x15 Received Count.  This counter does not roll over.  Count cleared by writing 0x0000 to this register."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "dlfr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Valid Downlink Frame Request Transaction ID 0x55 Packet Count.  This counter does not roll over.  Count cleared by writing 0x0000 to this register."
        }
      ]
    },
    "eio.radio.spwrca": {
      "id": "eio.radio.spwrca",
      "name": "spwrca",
      "type": "reg",
      "addr": 3235913752,
      "offset": 24,
      "doc": "Radio SPW RMAP Command Control\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  \nAddress Offset Radio A (SPWRCA):\t2018h\nAddress Offset Radio B (SPWRCB):\t2038h\nPOR/PCI Reset:\t\t0000 1000h \n\n\n*Requires function code to write.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1010 Allow send_cmd control\n0101 Allow cmd_sent control\n1001 Allow rmap_byte control\n1100 Allow send_cmd and rmap_bytes control\n0110 Allow send_cmd, cmd_sent and rmap_bytes control\n\nFunction Code (3:0):  These bits read back as “0000”.  Write a 1 or 0 to the associated bit(s) below to set or clear the bit."
        },
        {
          "nbits": 14,
          "lsb": 14,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 6,
          "lsb": 8,
          "name": "rmap_bytes",
          "access": "rw",
          "reset": 16,
          "doc": "Number of bytes to send to the radio from the RMAP TX buffer.  Note EIO does not verify if byte count matches the actual RMAP Packets specified byte count.  Default byte count is set to 16 bytes as the minimum required RMAP command on this project.  See Radio Spec for details.*"
        },
        {
          "nbits": 3,
          "lsb": 5,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "cmd_sent",
          "access": "rw",
          "reset": 0,
          "doc": "The RMAP command in the RMAP transmit command was sent.  Write one to clear.*"
        },
        {
          "nbits": 3,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "send_cmd",
          "access": "rw",
          "reset": 0,
          "doc": "Send Command that is in RMAP buffer.  Number of bytes to send is extracted from the RMAP packet.  Bit is cleared once command is sent, PRIME is lost or SpW Link is lost.. Can not be sent if string is not PRIME or if there is no Spw Link.*"
        }
      ]
    },
    "eio.radio.spwrsa": {
      "id": "eio.radio.spwrsa",
      "name": "spwrsa",
      "type": "reg",
      "addr": 3235913756,
      "offset": 28,
      "doc": "Radio SPW RMAP Status Control\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  This register is used for controlling the EIO buffers that store RMAP status or response packets received from the radios.\nAddress Offset Radio A:\t201Ch\nAddress Offset Radio B:\t203Ch\nPOR/PCI Reset:\t0000 0000h \n\n\n*Requires function code to modify.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1010 Allow buff_rdy control\n0110 Allow overflow control\n0101 Allow pci_ena control\n\nFunction Code (3:0):  Use specific pattern to manipulate the desired bits.  These bits read back as “0000”.  Write a 1 or 0 to the associated bit(s) below to set or clear the bit."
        },
        {
          "nbits": 14,
          "lsb": 14,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "pci_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Enable software writes to the RMAP receive buffer.  If clear software writes to the receive buffer are ignored.  If set software may write to the buffer, radio is prevented from writing to the buffer. * Requires FLT_TEST_MODE  to be enabled."
        },
        {
          "nbits": 9,
          "lsb": 4,
          "name": "byte_count",
          "access": "ro",
          "reset": 0,
          "doc": "The number of Bytes received in the latest packet and stored in the buffer. *"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "over_flow",
          "access": "rw",
          "reset": 0,
          "doc": "Buffers is not enabled and a new packet from radio was received and discarded.  Write 1 to clear."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "buff_rdy",
          "access": "rw",
          "reset": 0,
          "doc": "RMAP receive buffer is ready.  If set eio has received a RMAP status packet and software may read the buffer.  Software needs to clear this bit to allow writes to the receive buffers. Write one to clear*"
        }
      ]
    },
    "eio.radio.spwera": {
      "id": "eio.radio.spwera",
      "name": "spwera",
      "type": "reg",
      "addr": 3235913760,
      "offset": 32,
      "doc": "Radio SPW Error Counters\nThis register is used to count unexpected errors from the radio space wire interface, no errors are expected in normal operation and should be reported to flight software.\nAddress Offset Radio A:\t2020h\nAddress Offset Radio B:\t2040h\nPCI Reset:\t0000 0000 0000 000u uuuu uuuu uuuu uuuub (u = unchanged)\nPOR Reset:\t0000 0000h",
      "fields": [
        {
          "nbits": 15,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "dlrerr",
          "access": "rw",
          "reset": 0,
          "doc": "If this is the selected radio for downlink, dlfr_err will indicate a dlfr was received with frames_requested != 1.\nIf this is not-the selected radio for downlink, dlfr_err will indicate a dlfr was received on the non-selected radio."
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "tierr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "This counts the number of Illegal CCSDS Packets that are not forwarded to FSW.  The Packet Identifier for this transaction is still 0x02 but the Transaction Identifier is illegal and the count is not included in the Transaction Identifier Count Register below.  This counter is not expected to increment and any count detected here is an error and needs to be reported. Write 0x0000 to clear."
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "pierr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "P.I.= Other Count\nRadio Unsupported or undefined Packet Identifier Packet Count.  This counter does not roll over.  Count cleared by writing 0x0000 to this register.  This counter is not expected to increment and any count detected here is an error and needs to be reported. This counter will also count if a packet of only 2 bytes are received with a correct P.I."
        }
      ]
    },
    "eio.radio.spwseb": {
      "id": "eio.radio.spwseb",
      "name": "spwseb",
      "type": "reg",
      "addr": 3235913768,
      "offset": 40,
      "doc": "Radio SpW Status and Error Register\nEIO supports two identical Space Wire radios this register is duplicated for each interface.\nAddress offset Radio A:\t2008h\nAddress offset Radio B:\t2028h\nPCI Reset: \tuuuu_uuuu (u = unchanged)\nPOR Reset:\t0000 0000h\n\n*SPW, Space Wire Core direct signals.",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 3,
          "lsb": 24,
          "name": "parity_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "ParityErrCnt = count of number of odd parity errors (latched at 7) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "esc_err",
          "access": "ro",
          "reset": 0,
          "doc": "Escape Error  (“1” when ESC is followed by something other than FCT or Data, Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "fct_err1",
          "access": "ro",
          "reset": 0,
          "doc": "FlowControlErr1 (“1” when Rx more N-Char (data, EOP, EEP) than credits, Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "fct_err2",
          "access": "ro",
          "reset": 0,
          "doc": "FlowControlErr2 (“1” when Rx more credits than allowed, Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "data_rx",
          "access": "ro",
          "reset": 0,
          "doc": "DataChrReceived = “1” when node receives one N-Char after a link reset (Latched) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "fct_rx",
          "access": "ro",
          "reset": 0,
          "doc": "FlowCntrlReceived = “1” when 1st FCT arrives.  Clears with link reset (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "null_rx",
          "access": "ro",
          "reset": 0,
          "doc": "NullChrReceived =”1” when 1st Null received since link reset.  Clears with link rest (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "pticksent",
          "access": "ro",
          "reset": 0,
          "doc": "Pulses high for 1 clock after timecode is transmitted.  Indicates another time code can be sent.  Useful for test (not expected to be needed with 1 Hz timecodes) (SPW*)"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 3,
          "lsb": 12,
          "name": "state",
          "access": "ro",
          "reset": 1,
          "doc": "Radio SPW Status State.\n“001” indicates “ERROR_RESET” state,\n“010” indicates “ERROR_WAIT” state,\n“011” indicates “READY” state.\n“100” indicates “STARTED” state.\n“101” indicates “PRE-CONNECTING” state.\n“110” indicates “CONNECTING” state.\n“111” indicates “RUN” state.\nIt is observed that Radio SPW stays in READY state when the Radio SPW Enable bit is 0. Instrument is in Run state when the Space Wire flow control is successfully established."
        },
        {
          "nbits": 2,
          "lsb": 10,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "linkdown",
          "access": "ro",
          "reset": 1,
          "doc": "Current Space Wire Core Link Indicator. Immediately at power on there is no link, but should be established momentarily."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "rsvd_4",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "lrst_cnt_ovr",
          "access": "ro",
          "reset": 0,
          "doc": "Link Reset Count Overflow. Number of Link Reset events. Counter does not roll over."
        },
        {
          "nbits": 7,
          "lsb": 0,
          "name": "lrst_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Link Reset Count.  Number of Link Reset events.  Counter does not roll over.  Count cleared by writing 0x00 to this register.  Does not count the power on initial no link."
        }
      ]
    },
    "eio.radio.spwecrb": {
      "id": "eio.radio.spwecrb",
      "name": "spwecrb",
      "type": "reg",
      "addr": 3235913772,
      "offset": 44,
      "doc": "Radio SpW Error Clear/Inject Register\nEIO supports two identical Space Wire radios this register is duplicated for each interface.\nAddress Offset Radio A:\t200Ch\nAddress Offset Radio B:\t202Ch\nPCI Reset:\tuuuu uuuuh\nPOR Reset:\t0000 0000h\n\n\n†Requires bit 31 to set and clear.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "set_clr_bit",
          "access": "rw",
          "reset": 0,
          "doc": "The value of this bit will be written to all control bits with a “1” assigned.  (e.g. writing 0x8000_0400 to this register will set bit 10 to “1” and writing 0x0000_0400 will set the bit to “0”. (Does not apply to bits [23:12])"
        },
        {
          "nbits": 3,
          "lsb": 28,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "txparerrinject",
          "access": "rw",
          "reset": 0,
          "doc": "TxParityErrInject rising edge is used to inject a parity error at the transmitter of the link, to be seen by the receiver at the other end. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "rxswwrerrinj",
          "access": "rw",
          "reset": 0,
          "doc": "RxSwitchWrErrInj can be used to inject EDAC errors status as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "rxlkwrerrinj",
          "access": "rw",
          "reset": 0,
          "doc": "RxLinkWrErrInj can be used to inject EDAC errors using rxlkwrerrsyn. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "txwrerrinj",
          "access": "rw",
          "reset": 0,
          "doc": "TxWrErrInj can be used to inject EDAC errors as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec. Requires FLT_TEST_MODE†"
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rxswwrerrsyn",
          "access": "rw",
          "reset": 0,
          "doc": "RxSwitchWrErrInj can be used to inject EDAC errors as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec."
        },
        {
          "nbits": 4,
          "lsb": 16,
          "name": "rxlkwrerrsyn",
          "access": "rw",
          "reset": 0,
          "doc": "RxLinkWrErrSyn[3:0] report EDAC error information as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec."
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "txwrerrsyn",
          "access": "rw",
          "reset": 0,
          "doc": "TxWrErrSyn[3:0] can be used to inject EDAC errors as described in section 4.5 of the Goddard SpaceWire Node FPGA Core spec."
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "err_fifo_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Clears error in Rx Link FIFO (RxLinkErrSyn), error in Rx Switch FIFO (RxSwitchErrSyn) & Clears error in Tx Switch FIFO (TxRdErrSyn)"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "lrst_ovr_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Link Reset Overflow Clear.  Software writes a 1 to clear the Link Reset Overflow.  Software should writes a 0 to re-enable the Link Reset Count. †"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "lrst_ct_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Link Reset Count Clear.  Software writes a 1 to clear the Link Reset Count.  Software should writes a 0 to re-enable the Link Reset Count. †"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "statusclear",
          "access": "rw",
          "reset": 0,
          "doc": "Used to clear the latched values in parity_cnt, esc_err, fct_err1, and fct_err2†"
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "link_start",
          "access": "rw",
          "reset": 1,
          "doc": "Enables the link SpW FSM. †"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "enable",
          "access": "rw",
          "reset": 1,
          "doc": "Radio SWP Enable bit.  This bit is enabled by default to accept Uplink commands. †"
        }
      ]
    },
    "eio.radio.spwpicb": {
      "id": "eio.radio.spwpicb",
      "name": "spwpicb",
      "type": "reg",
      "addr": 3235913776,
      "offset": 48,
      "doc": "Radio SPW Packet Identifier Count\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  This counter counts the number of SPW packets of different Packet Identifier (P.I.).  Only two P.I. are expected but all are counted.  This register also includes count of Illegal CCSDS Packets [31:24]\nAddress Offset Radio A:\t2010h\nAddress Offset Radio B:\t2030h\nPCI Reset:\tuuuu uuuuh\nPOR:\t0000 0000h",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "ccsds_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "P.I.=0x02 Count\nRadio CCSDS Packet count.  All packets marked with Packet Identifier 0x02.  i.e. Downlink Requests, Uplink or other undefined Transaction ID.  This counter does not roll over.  Count cleared by writing 0x0000_0000 to this register."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rmap_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "P.I.=0x01 Count\nRadio RMAP Status Message and/or Command Response Count.  Packet Identifier 0x01.  This counter does not roll over.  Count cleared by writing 0x0000_0000 to this register."
        }
      ]
    },
    "eio.radio.spwticb": {
      "id": "eio.radio.spwticb",
      "name": "spwticb",
      "type": "reg",
      "addr": 3235913780,
      "offset": 52,
      "doc": "Radio SPW Transaction Identifier Count\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  This counter counts the number of SPW packets of Transaction ID 0x55.\nAddress Offset Radio A:\t2014h\nAddress Offset Radio B:\t2034h\nPCI Reset:\tuuuu uuuuh\nPOR Reset:\t0000 0000h",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "ulfr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Radio CCSDS Uplink/Lander Return Packet Transaction ID 0x15 Received Count.  This counter does not roll over.  Count cleared by writing 0x0000 to this register."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "dlfr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Valid Downlink Frame Request Transaction ID 0x55 Packet Count.  This counter does not roll over.  Count cleared by writing 0x0000 to this register."
        }
      ]
    },
    "eio.radio.spwrcb": {
      "id": "eio.radio.spwrcb",
      "name": "spwrcb",
      "type": "reg",
      "addr": 3235913784,
      "offset": 56,
      "doc": "Radio SPW RMAP Command Control\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  \nAddress Offset Radio A (SPWRCA):\t2018h\nAddress Offset Radio B (SPWRCB):\t2038h\nPOR/PCI Reset:\t\t0000 1000h \n\n\n*Requires function code to write.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1010 Allow send_cmd control\n0101 Allow cmd_sent control\n1001 Allow rmap_byte control\n1100 Allow send_cmd and rmap_bytes control\n0110 Allow send_cmd, cmd_sent and rmap_bytes control\n\nFunction Code (3:0):  These bits read back as “0000”.  Write a 1 or 0 to the associated bit(s) below to set or clear the bit."
        },
        {
          "nbits": 14,
          "lsb": 14,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 6,
          "lsb": 8,
          "name": "rmap_bytes",
          "access": "rw",
          "reset": 16,
          "doc": "Number of bytes to send to the radio from the RMAP TX buffer.  Note EIO does not verify if byte count matches the actual RMAP Packets specified byte count.  Default byte count is set to 16 bytes as the minimum required RMAP command on this project.  See Radio Spec for details.*"
        },
        {
          "nbits": 3,
          "lsb": 5,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "cmd_sent",
          "access": "rw",
          "reset": 0,
          "doc": "The RMAP command in the RMAP transmit command was sent.  Write one to clear.*"
        },
        {
          "nbits": 3,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "send_cmd",
          "access": "rw",
          "reset": 0,
          "doc": "Send Command that is in RMAP buffer.  Number of bytes to send is extracted from the RMAP packet.  Bit is cleared once command is sent, PRIME is lost or SpW Link is lost.. Can not be sent if string is not PRIME or if there is no Spw Link.*"
        }
      ]
    },
    "eio.radio.spwrsb": {
      "id": "eio.radio.spwrsb",
      "name": "spwrsb",
      "type": "reg",
      "addr": 3235913788,
      "offset": 60,
      "doc": "Radio SPW RMAP Status Control\nEIO supports two identical Space Wire radios this register is duplicated for each interface.  This register is used for controlling the EIO buffers that store RMAP status or response packets received from the radios.\nAddress Offset Radio A:\t201Ch\nAddress Offset Radio B:\t203Ch\nPOR/PCI Reset:\t0000 0000h \n\n\n*Requires function code to modify.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1010 Allow buff_rdy control\n0110 Allow overflow control\n0101 Allow pci_ena control\n\nFunction Code (3:0):  Use specific pattern to manipulate the desired bits.  These bits read back as “0000”.  Write a 1 or 0 to the associated bit(s) below to set or clear the bit."
        },
        {
          "nbits": 14,
          "lsb": 14,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "pci_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Enable software writes to the RMAP receive buffer.  If clear software writes to the receive buffer are ignored.  If set software may write to the buffer, radio is prevented from writing to the buffer. * Requires FLT_TEST_MODE  to be enabled."
        },
        {
          "nbits": 9,
          "lsb": 4,
          "name": "byte_count",
          "access": "ro",
          "reset": 0,
          "doc": "The number of Bytes received in the latest packet and stored in the buffer. *"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "over_flow",
          "access": "rw",
          "reset": 0,
          "doc": "Buffers is not enabled and a new packet from radio was received and discarded.  Write 1 to clear."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "buff_rdy",
          "access": "rw",
          "reset": 0,
          "doc": "RMAP receive buffer is ready.  If set eio has received a RMAP status packet and software may read the buffer.  Software needs to clear this bit to allow writes to the receive buffers. Write one to clear*"
        }
      ]
    },
    "eio.radio.spwerb": {
      "id": "eio.radio.spwerb",
      "name": "spwerb",
      "type": "reg",
      "addr": 3235913792,
      "offset": 64,
      "doc": "Radio SPW Error Counters\nThis register is used to count unexpected errors from the radio space wire interface, no errors are expected in normal operation and should be reported to flight software.\nAddress Offset Radio A:\t2020h\nAddress Offset Radio B:\t2040h\nPCI Reset:\t0000 0000 0000 000u uuuu uuuu uuuu uuuub (u = unchanged)\nPOR Reset:\t0000 0000h",
      "fields": [
        {
          "nbits": 15,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "dlrerr",
          "access": "rw",
          "reset": 0,
          "doc": "If this is the selected radio for downlink, dlfr_err will indicate a dlfr was received with frames_requested != 1.\nIf this is not-the selected radio for downlink, dlfr_err will indicate a dlfr was received on the non-selected radio."
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "tierr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "This counts the number of Illegal CCSDS Packets that are not forwarded to FSW.  The Packet Identifier for this transaction is still 0x02 but the Transaction Identifier is illegal and the count is not included in the Transaction Identifier Count Register below.  This counter is not expected to increment and any count detected here is an error and needs to be reported. Write 0x0000 to clear."
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "pierr_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "P.I.= Other Count\nRadio Unsupported or undefined Packet Identifier Packet Count.  This counter does not roll over.  Count cleared by writing 0x0000 to this register.  This counter is not expected to increment and any count detected here is an error and needs to be reported. This counter will also count if a packet of only 2 bytes are received with a correct P.I."
        }
      ]
    },
    "eio.radio.radio_page_rsvd_0": {
      "id": "eio.radio.radio_page_rsvd_0",
      "name": "radio_page_rsvd_0",
      "type": "mem",
      "addr": 3235913796,
      "offset": 68,
      "doc": ""
    },
    "eio.ul": {
      "id": "eio.ul",
      "name": "ul",
      "type": "blk",
      "addr": 3235921920,
      "offset": 16384,
      "doc": "Uplink, Uplink DMA, and HCD registers",
      "children": [
        "eio.ul.uliprev",
        "eio.ul.ulstat",
        "eio.ul.ulcfg",
        "eio.ul.ulpor",
        "eio.ul.ulctrl",
        "eio.ul.lckcnt",
        "eio.ul.udiprev",
        "eio.ul.uldcms",
        "eio.ul.uldstra",
        "eio.ul.uldenda",
        "eio.ul.uldptra",
        "eio.ul.uldstrb",
        "eio.ul.uldendb",
        "eio.ul.uldptrb",
        "eio.ul.hciprev",
        "eio.ul.crcctrl",
        "eio.ul.nvmask",
        "eio.ul.vmask",
        "eio.ul.nvcrclc",
        "eio.ul.nvcrc",
        "eio.ul.vcrc",
        "eio.ul.hcdstat",
        "eio.ul.ul_page_rsvd_0"
      ]
    },
    "eio.ul.uliprev": {
      "id": "eio.ul.uliprev",
      "name": "uliprev",
      "type": "reg",
      "addr": 3235921920,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.ul.ulstat": {
      "id": "eio.ul.ulstat",
      "name": "ulstat",
      "type": "reg",
      "addr": 3235921924,
      "offset": 4,
      "doc": "Uplink Status Register\nThis register provides real-time status and some statistics for the uplink module.\n\nAddress offset:\t\t\t4004h \ncPCI / uplink module reset value:\t???? ?uuu 0uuu 0uuu 0uuu uuuu u000 0000b (u = unchanged)\nPOR reset value: \t\t\t???? ?000 0000 0000 0000 0000 0000 0000b (? = set externally)\n\n\n* Only if last channel decoded was TZ, in case of autoselect.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "tz_cmd_lockn",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates LOCK acquired on TZ input channel. Active low. "
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "a_cmd_lockn",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates LOCK acquired on input channel A. Active low. "
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "b_cmd_lockn",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates LOCK acquired on input channel B. Active low. "
        },
        {
          "nbits": 2,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 24,
          "name": "hcd_src",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates which channel the HCD is attempting to decode. Note: In auto detect mode these bits will indicate the last channel decoded. This value is reset to 000 once the TZ commanding is disabled. *\n000 = A, 001 = B, 1XX = TZ; bit 25 is always 0. "
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "up_overrun",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates Uplink buffer was overrun, this bit will clear when Uplink is in search mode and DMA is re-enabled. "
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "flip_bit",
          "access": "ro",
          "reset": 0,
          "doc": "Reflects the current state of FLIP_BIT, which indicates the polarity of the incoming codeblocks. As it is possible for this value to change, it is appended as part of the status word attached to each codeblock. The bit provided here is more for debugging purposes than actual use during flight. "
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "sfcrlybufinuse",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates that a previous software write to the CRCs is still in progress "
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "gndrlybufinuse",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates that a previous ground command to change the CRCs is still in progress "
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "overrun_error",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Buffer Overrun Error: Set to “1” if the Uplink buffer overruns. Write “1” to clear and Write “0” has no effect."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "search",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the HCD is in the SEARCH state, and is searching for the acquisition sequence. "
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "decode",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the HCD is in the DECODE state (acquisition sequence detected, now receiving codeblocks) "
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "decodecmd",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the HCD is in the DECODECMD state (attempting to decode hardware commands) "
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "cb_count_mask",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a ‘1’ to this bit allows software to modify the CB_COUNT field"
        },
        {
          "nbits": 8,
          "lsb": 7,
          "name": "cb_count",
          "access": "rw",
          "reset": 0,
          "doc": "Number of codeblocks received. Hardware increments this every time a codeblock is received. This has no relation to the number of codeblocks software has received over DMA. If DMA is turned off, this counter will continue to increment even though codeblocks are being lost. Rollover."
        },
        {
          "nbits": 3,
          "lsb": 4,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "a_acq_ign",
          "access": "rw",
          "reset": 0,
          "doc": "Indicates the acquisition sequence was detected and ignored on this channel since the bit was last cleared. Either the HCD was in auto-select mode and already processing codeblocks on another channel, or software had forced the selection of a different port. Write a ‘1’ to clear this bit."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "b_acq_ign",
          "access": "rw",
          "reset": 0,
          "doc": "Same as A_ACQ_IGN"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.ulcfg": {
      "id": "eio.ul.ulcfg",
      "name": "ulcfg",
      "type": "reg",
      "addr": 3235921928,
      "offset": 8,
      "doc": "Uplink Configuration Register\nThis register provides information as to the configuration of the uplink module and the attached radios.\n\nAddress offset:\t\t\t4008h \t\ncPCI / uplink module reset value:\tuuuu 0000 uuuu uuuu ?u0u 0uuu uuuu uuuub (u = unchanged)\nPOR reset value: \t\t\t0000 0000 ???? 0000 ?000 0??? ???? ????b (? = set externally)\n\n\n* The content of bit 11 will be written to bits 12 if any of the corresponding bits are selected.\n** Requires function code bits to write",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "A value of hex A here is required to Enable or Disable De Randomization.  Reads back 0."
        },
        {
          "nbits": 4,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "crc_por",
          "access": "ro",
          "reset": 0,
          "doc": "External inputs that are hardwired on the EIO board. These bits control the default state of the volatile CRC bits on POR. Each bit here represents 8 CRC bits. Only change after POR. "
        },
        {
          "nbits": 4,
          "lsb": 16,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "secdedn_nected",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the type of error correction to use. The method used to change this value is system dependent, but typically would be controlled by one of the volatile CRC bits.\nA ‘0’ corresponds to Single Error Correct Double Error Detect\nA ‘1’ corresponds to No Error Correct Triple Error Detect "
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "ul_rst",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink Module Reset: Functionally different from the rest. Used only to reset the Uplink Control Module. Must write 1 with Fillbit to reset Uplink logic. Will always read back as ‘0’. See §12.1.1 for more detail. *"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "derandomize",
          "access": "rw",
          "reset": 0,
          "doc": "Disable pseudo de-rerandomization. By default the Command Decoder expects a randomized codeblock, turn on this bit to not derandomized the codeblocks. Requires a value of A in function_code bits above to modify this bit.**   Europa expects all commands to be psudorandomized and so this bit should remain “0” so EIO will de-randomize them.\nDANGER!!! A wrong selection will cause a valid command from \nearth not to execute. See De-Randomization §12.1.3.7 for details.\nNote that this register is not cleared with PCI reset."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "fillbit",
          "access": "rw",
          "reset": 0,
          "doc": "The content of this bit will be written to the selected bit 12; reads back “0”"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "string_id",
          "access": "ro",
          "reset": 0,
          "doc": "A hardwired value on the chassis that indicates if this is string “1=A” or “0=B”. This value is used by the HCD to determine if a hardware command is to be executed by this string. "
        },
        {
          "nbits": 10,
          "lsb": 0,
          "name": "spacecraft_id",
          "access": "ro",
          "reset": 0,
          "doc": "A hardwired value on the chassis that indicates the 10-bit spacecraft ID. This value is used by the HCD to determine if a hardware command is to be executed. "
        }
      ]
    },
    "eio.ul.ulpor": {
      "id": "eio.ul.ulpor",
      "name": "ulpor",
      "type": "reg",
      "addr": 3235921932,
      "offset": 12,
      "doc": "Uplink UNMASK_POR Status Register\nThis register provides information as to the current board setting of the UNMASK_POR value of each CRC.\nNOTE: UNMASK BITS ARE VOLATILE and only upon POR will be set to the jumper settings by bank below.\nAddress offset:\t\t\t400Ch \t\ncPCI / uplink module reset value:\t000u 000uh (u = unchanged)\nPOR reset value: \t\t\t000? 000?h (? = set externally)",
      "fields": [
        {
          "nbits": 12,
          "lsb": 20,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 4,
          "lsb": 16,
          "name": "nvunmask_por",
          "access": "ro",
          "reset": 0,
          "doc": "External inputs that are hardwired on the EIO board. These bits control the default state of the non-volatile unmask bits on POR. Each bit here represents 8 mask bits. They are named “mask” but confusingly if they are set they allow modification of bits by software."
        },
        {
          "nbits": 12,
          "lsb": 4,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "vunmask_por",
          "access": "ro",
          "reset": 0,
          "doc": "External inputs that are hardwired on the EIO board. These bits control the default state of the volatile unmask bits on POR. Each bit here represents 8 mask bits. They are named “mask” but confusingly if they are set they allow modification of bits by software."
        }
      ]
    },
    "eio.ul.ulctrl": {
      "id": "eio.ul.ulctrl",
      "name": "ulctrl",
      "type": "reg",
      "addr": 3235921936,
      "offset": 16,
      "doc": "Uplink Control Register\nThis register can be used to reset the radios and select which radio to receive codeblocks from.\n\nAddress offset:\t\t\t4010h \ncPCI / uplink module reset value:\t0uuu uuuu uuuu uuuu uuuu 0000 0000 01uub (u = unchanged)\t\nPOR reset value: \t\t\t0000 0000 0000 0000 0000 0000 0000 0100b\n\n* Requires PORT_SEL_MASK to be set for writes.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nvcrc_dc_mask",
          "access": "wo",
          "reset": 0,
          "doc": "Write a ‘1’ to this bit to enable writes to NVCRC_Delay_Count (bits 30:13). Reads back “0.” "
        },
        {
          "nbits": 19,
          "lsb": 12,
          "name": "nvcrc_delay_count",
          "access": "rw",
          "reset": 0,
          "doc": "When writing to the non-volatile CRCs, this counter is used to time the control signals. Each CRC bit should be held active for 9ms, followed by 9ms with no signals asserted. This counter is compared to 0x60AE0 to achieve that delay. During simulation, it may be useful to shorten this delay, which can be accomplished by writing to this field (for example, write 0x60AEA for a very short delay) Note that you will have to write to this register a total of 16 times per CRC command you wish to speed up. This can only be written to when TZ_HW_TEST_MODE is enabled."
        },
        {
          "nbits": 8,
          "lsb": 4,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "port_sel_mask",
          "access": "rw",
          "reset": 0,
          "doc": "Write a ‘1’ to this bit to enable bits 2:0. Reads back “0.”"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "auto_sel_en",
          "access": "rw",
          "reset": 1,
          "doc": "Write a ‘1’ to this bit to enable auto-select, or ‘0’ to enable control of the selected channel. This bit is forced to a 1 anytime the string is considered unhealthy. *"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "port_sel",
          "access": "rw",
          "reset": 0,
          "doc": "When AUTO_SEL_EN is ‘0’, writes to this location with PORT_SEL_MASK enabled, forces the HCD to decode the specified channel and TZ overrides this selection.. Refer to 12.2.2 for mapping. Reads back what was written. *"
        }
      ]
    },
    "eio.ul.lckcnt": {
      "id": "eio.ul.lckcnt",
      "name": "lckcnt",
      "type": "reg",
      "addr": 3235921940,
      "offset": 20,
      "doc": "Uplink Lock Counter\nThis register tracks the number of times lock has been acquired on each of the uplink channels.  Note that if a lock transition occurs on the same PCI clock cycle that software writes to this register, that lock transition will be ignored and the associated lock counter will not increment.  At any reset if the LOCK signal is detected, the count will be shown as 1.  An Upl_Lck_Thresh staus is generated when the specific Lock counter reaches the mid count.  When this occurs, the software should clear the most significant bit of the counter allowing hardware to continue counting without the possibility of lost count.  Note: Lock signals counted are counted \n\nAddress offset:\t\t\t4014h \ncPCI:\t0uuu uuuu 0uuuu uuuu 0000 0000 0000b\nPOR / uplink module reset value:\t0000 0000 0000 0000 0000 0000 0000 0000b",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "a_fill",
          "access": "wo",
          "reset": 0,
          "doc": "When writing to UL_A_LCK_CNT, this acts as a fill bit and each of the counter bits acts as an enable bit. For each bit in the UL_A_LCK_CNT field that is set to ‘1’, the corresponding bit in the counter will be set to the value of this fill bit. "
        },
        {
          "nbits": 7,
          "lsb": 24,
          "name": "ul_a_lck_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Incremented every time A_CMD_LCK transitions from high to low. This counter will rollover. An Upl_Lck_Thresh interrupt is generated when this counter reaches the value 1000000b. See description of the A_FILL field for a description of how to write to this field."
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "b_fill",
          "access": "wo",
          "reset": 0,
          "doc": "When writing to UL_B_LCK_CNT, this acts as a fill bit and each of the counter bits acts as an enable bit. For each bit in the UL_B_LCK_CNT field that is set to ‘1’, the corresponding bit in the counter will be set to the value of this fill bit. "
        },
        {
          "nbits": 7,
          "lsb": 16,
          "name": "ul_b_lck_cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Incremented every time B_CMD_LCK transitions from high to low. This counter will rollover. An Upl_Lck_Thresh interrupt is generated when this counter reaches the value 1000000b. See description of the B_FILL field for a description of how to write to this field."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.udiprev": {
      "id": "eio.ul.udiprev",
      "name": "udiprev",
      "type": "reg",
      "addr": 3235921968,
      "offset": 48,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.ul.uldcms": {
      "id": "eio.ul.uldcms",
      "name": "uldcms",
      "type": "reg",
      "addr": 3235921972,
      "offset": 52,
      "doc": "Uplink DMA Status Control Register\nAddress offset:\t\t\t4034h\t\t\t\t\t\ncPCI Reset value:\t\t\tuuuu_uuu4h\nPOR/Uplink Soft Reset value: \t0000 0004h\n\nRW†\tWrite ‘1’ to clear, writing ‘0’ has no effect.\nRW††\tWrite ‘1’ to clear.  When bit 30 is set dma error bit[15:13] will take whatever value is written to them, setting the DMA error bits will generate a dma_err_int in HS2\nRW**\tWrite ‘1’ to clear, writing ‘0’ has no effect; Will set UL_dma_cmplt interrupt in HS2 when occurs.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "ena_config",
          "access": "rw",
          "reset": 0,
          "doc": "The content of this bit is reflected to bit 0 and 1 if, bit 0 or/and bit 1 are selected"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "test_mode",
          "access": "rw",
          "reset": 0,
          "doc": "When set dma error bit[15:13] will take whatever value is written to them.\nNOTE: RESET FOR NORMAL OPERATION"
        },
        {
          "nbits": 3,
          "lsb": 27,
          "name": "bufb_src",
          "access": "rw",
          "reset": 0,
          "doc": "† Indicates the source of the CLTU in buffer B:1XX = T-Zero\n000 = A \n001 = B\n010 = Unused (was C)\n011 = Unused (was D)"
        },
        {
          "nbits": 2,
          "lsb": 25,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "bufb_vld",
          "access": "rw",
          "reset": 0,
          "doc": "† Indicates destination buffer B contains at least one uplink frame codeblocks.  Buffer is switched only if full or if there is a boundary check error. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "bufB_wd_exp",
          "access": "rw",
          "reset": 0,
          "doc": "** Watchdog expired during decode while receiving the CLTU in buffer B (so it is only a partial CLTU)"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "bufA_wd_exp",
          "access": "rw",
          "reset": 0,
          "doc": "** Watchdog expired during decode while receiving the CLTU in buffer A (so it is only a partial CLTU)"
        },
        {
          "nbits": 3,
          "lsb": 19,
          "name": "bufa_src",
          "access": "rw",
          "reset": 0,
          "doc": "† Indicates the source of the CLTU in buffer A: 1XX = T-Zero\n000 = A \n001 = B\n010 = Unused (was C)\n011 = Unused (was D)"
        },
        {
          "nbits": 2,
          "lsb": 17,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "bufa_vld",
          "access": "rw",
          "reset": 0,
          "doc": "† Indicates destination buffer A contains at least one uplink frame codeblocks.  Buffer is switched only if full or if there is a boundary check error. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "dma_perr",
          "access": "rw",
          "reset": 0,
          "doc": "†† DMA data parity error status. Sets when data parity error is detected in DMA data. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "dma_t_abt",
          "access": "rw",
          "reset": 0,
          "doc": "†† DMA target abort status. Sets when PCI Target Abort occurs during DMA transfer. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "dma_m_abt",
          "access": "rw",
          "reset": 0,
          "doc": "†† DMA master abort status. Sets when PCI Master Abort occurs during DMA transfer. Write ‘1’ to clear."
        },
        {
          "nbits": 8,
          "lsb": 5,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "ul_dma_overrun",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink DMA overrun (DMA completes before CLTU is done) or It swapped to the other buffer due to end of current buffer"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "cur_buf",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the currently selected buffer. (0 = buffer A, 1 = buffer B). Will update only if bit 0, 1 or both are set, otherwise it shows the last buffer. "
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "last_valid_buf",
          "access": "ro",
          "reset": 1,
          "doc": "Indicates the last valid buffer. (0 = buffer A, 1 = buffer B) "
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "dma_enab",
          "access": "rw",
          "reset": 0,
          "doc": "Writing “1” to this bit will take the content of bit 31 and enables DMA buffer A or B respectively. ie write 80000002 to set dma_enaB, & 00000002 to clear it; 80000001 to set dma_enaA, & 00000001 to clear it. 80000003 to enable both and 00000003 to clear them."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "dma_enaa",
          "access": "rw",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.uldstra": {
      "id": "eio.ul.uldstra",
      "name": "uldstra",
      "type": "reg",
      "addr": 3235921976,
      "offset": 56,
      "doc": "Uplink DMA Start Address Register\nThis register is set by software to indicate the start address of each buffer that Uplink DMA should transfer data to.\nAddress offset:\t\t\t4038h/4044h\t\t\t\t\t\ncPCI Reset:\t\t\tuuuu uuuuh\t(u = unchanged)\nPOR/Uplink Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "strt_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Start Address for DMA buffer.\nThis address is loaded into address pointer when the buffer is ready (go bit set and vld bit cleared)\nNote: If “go” bit is already set the value will not take effect till “go” bit is reset and set again."
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.uldenda": {
      "id": "eio.ul.uldenda",
      "name": "uldenda",
      "type": "reg",
      "addr": 3235921980,
      "offset": 60,
      "doc": "Uplink DMA End Address Register\nThis register is set by software to indicate the end address of each buffer that Uplink DMA should stop data transfer and switch to the other buffer.\nNOTE: This register should be set such that the buffer can accommodate the longest CLTU which is mission specific.\nThe longest allowed frame is 1024 bytes, and including the status footer appended to each codeblock, this buffer should be 1776 bytes.  If smaller, an overrun condition may occur, depending on the actual size of the frames received.\nAddress offset:\t\t\t403Ch/4048h\ncPCI Reset:\t\t\tuuuu uuuuh\t(u = unchanged)\nPOR/Uplink Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "end_addr",
          "access": "rw",
          "reset": 0,
          "doc": "End Address for DMA buffer. (Normally should be Uplink DMA Start_Address plus 600h)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.uldptra": {
      "id": "eio.ul.uldptra",
      "name": "uldptra",
      "type": "reg",
      "addr": 3235921984,
      "offset": 64,
      "doc": "Uplink DMA Pointer Address Register\nThis register indicates the next address of the buffer that the Uplink DMA will transfer data to.  This pointer will update even after overrun. \nAddress offset:\t\t\t4040h/404Ch\t\t\t\t\t\ncPCI Reset value:\t\t\tuuuu_uuuuh\nPOR/Uplink Soft Reset value: 0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "ptr_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Pointer for next address for DMA buffer\nHardware increments this register per data transfer until Uplink CLTU is done or there is a double bit error, or when the end address is reached. "
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.uldstrb": {
      "id": "eio.ul.uldstrb",
      "name": "uldstrb",
      "type": "reg",
      "addr": 3235921988,
      "offset": 68,
      "doc": "Uplink DMA Start Address Register\nThis register is set by software to indicate the start address of each buffer that Uplink DMA should transfer data to.\nAddress offset:\t\t\t4038h/4044h\t\t\t\t\t\ncPCI Reset:\t\t\tuuuu uuuuh\t(u = unchanged)\nPOR/Uplink Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "strt_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Start Address for DMA buffer.\nThis address is loaded into address pointer when the buffer is ready (go bit set and vld bit cleared)\nNote: If “go” bit is already set the value will not take effect till “go” bit is reset and set again."
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.uldendb": {
      "id": "eio.ul.uldendb",
      "name": "uldendb",
      "type": "reg",
      "addr": 3235921992,
      "offset": 72,
      "doc": "Uplink DMA End Address Register\nThis register is set by software to indicate the end address of each buffer that Uplink DMA should stop data transfer and switch to the other buffer.\nNOTE: This register should be set such that the buffer can accommodate the longest CLTU which is mission specific.\nThe longest allowed frame is 1024 bytes, and including the status footer appended to each codeblock, this buffer should be 1776 bytes.  If smaller, an overrun condition may occur, depending on the actual size of the frames received.\nAddress offset:\t\t\t403Ch/4048h\ncPCI Reset:\t\t\tuuuu uuuuh\t(u = unchanged)\nPOR/Uplink Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "end_addr",
          "access": "rw",
          "reset": 0,
          "doc": "End Address for DMA buffer. (Normally should be Uplink DMA Start_Address plus 600h)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.uldptrb": {
      "id": "eio.ul.uldptrb",
      "name": "uldptrb",
      "type": "reg",
      "addr": 3235921996,
      "offset": 76,
      "doc": "Uplink DMA Pointer Address Register\nThis register indicates the next address of the buffer that the Uplink DMA will transfer data to.  This pointer will update even after overrun. \nAddress offset:\t\t\t4040h/404Ch\t\t\t\t\t\ncPCI Reset value:\t\t\tuuuu_uuuuh\nPOR/Uplink Soft Reset value: 0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "ptr_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Pointer for next address for DMA buffer\nHardware increments this register per data transfer until Uplink CLTU is done or there is a double bit error, or when the end address is reached. "
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ul.hciprev": {
      "id": "eio.ul.hciprev",
      "name": "hciprev",
      "type": "reg",
      "addr": 3235922016,
      "offset": 96,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.ul.crcctrl": {
      "id": "eio.ul.crcctrl",
      "name": "crcctrl",
      "type": "reg",
      "addr": 3235922020,
      "offset": 100,
      "doc": "CRC Control Register\nNote: This is for Critical Relay Control, Writing to this register will affect hardware in a major way!\n\nThis register has NOTHING to do with Cyclic Redundancy Checking.  You need to understand the SYSTEM effects before manipulating this register!\n\nThis register allows you to set and clear CRC bits that are unmasked.  (CRITICAL Relay Controller)\nNote, bits [31:17] & [14:11] must be set to “0”, otherwise the register write will be silently ignored, and i.e. no errors will be generated.\n\nAddress offset:\t\t\t4064h \t\t\t\t\t\t\t\ncPCI / uplink module reset value:\tuuuu uuuu uuuu uuuu uuuu uuuu uuuu uuuub (u = unchanged)\nPOR reset value: \t\t\t0000 0000 0000 0000 0000 0000 0000 0000b",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "key1",
          "access": "rw",
          "reset": 0,
          "doc": "All bits must be “0” if not the register write will be ignored."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "set_clrn",
          "access": "rw",
          "reset": 0,
          "doc": "Write a ‘1’ to set CRC bits, write a ‘0’ to clear them, reads back 0."
        },
        {
          "nbits": 4,
          "lsb": 11,
          "name": "key0",
          "access": "rw",
          "reset": 0,
          "doc": "All bits must be “0” if not the register write will be ignored."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "nv_voln",
          "access": "rw",
          "reset": 0,
          "doc": "Write a ‘1’ to modify non-volatile CRCs (63:32), write a ‘0’ to modify volatile CRCs (31:0). Reads back 0."
        },
        {
          "nbits": 2,
          "lsb": 8,
          "name": "bank",
          "access": "rw",
          "reset": 0,
          "doc": "Specifies which set of 8 CRCs to modify. For example if NV_VOLn is ‘0’ and this is ‘00’, then CRCs (7:0) will be modified. Reads back 0."
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "enable",
          "access": "rw",
          "reset": 0,
          "doc": "Of the bank of 8 CRCs selected, specifies which individual CRCs to modify. A ‘1’ in a bit position will cause the corresponding CRC to be modified (assuming the CRC is unmasked). The CRC will be set if SET_CLRn is ‘1’ and cleared if it is ‘0’. A ‘0’ in a bit position will ensure that CRC bit is not changed. Reads back 0."
        }
      ]
    },
    "eio.ul.nvmask": {
      "id": "eio.ul.nvmask",
      "name": "nvmask",
      "type": "reg",
      "addr": 3235922024,
      "offset": 104,
      "doc": "UNMASK(63:32) Readback Register\nThis register allows you to read the values of the 32 mask bits associated with the non-volatile CRCs (63:32).  These bits can only be changed by ground and are volatile.  On POR, these bits are set according to hardwired inputs CRC_MASK_POR. If a bit is set, that means the corresponding Non-Volatile CRC is controllable by software writes to the CRCCTRL register.  If the bit is not set, the write to CRCCTRL for the corresponding CRC will be ignored.\nBits 31:24 reset to the value of the input CRC_MASK_POR(7)\nBits 23:16 reset to the value of the input CRC_MASK_POR(6)\nBits 15:8   reset to the value of the input CRC_MASK_POR(5)\nBits 7:0     reset to the value of the input CRC_MASK_POR(4)\nAddress offset:\t\t\t4068h\t\ncPCI / uplink module reset value:\tuuuu uuuu uuuu uuuu uuuu uuuu uuuu uuuub (u = unchanged)\nPOR reset value: \t\t\t???? ???? ???? ???? ???? ???? ???? ????b (? = set externally)",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "crc_unmask_upper",
          "access": "ro",
          "reset": 0,
          "doc": "Bits set in the HCD via ground command. If a bit is ‘1’, the corresponding CRC bit is considered “unmasked” and can be modified by software command. If ‘0’, writes to register CRCCTRL will have no effect on the corresponding CRC bit. \n“1” for any bit means software control of that corresponding CRC is allowed; “0” for any bit means software control of corresponding CRC is not allowed and requires Hardware Command to control the CRC or to allow control of that CRC by setting the corresponding unmask bit."
        }
      ]
    },
    "eio.ul.vmask": {
      "id": "eio.ul.vmask",
      "name": "vmask",
      "type": "reg",
      "addr": 3235922028,
      "offset": 108,
      "doc": "UNMASK(31:0) Readback Register\nThis register allows you to read the values of the 32 mask bits associated with the volatile CRCs (31:0).  These bits can only be changed by ground (i.e. Hardware Commands).  On POR, these bits are set according to hardwired inputs.  If a bit is set, that means the corresponding Volatile CRC is controllable by software writes to the CRCCTRL register.  If the bit is not set, the write to CRCCTRL for the corresponding CRC will be ignored. \nBits 31:24 reset to the value of the input CRC_MASK_POR(3)\nBits 23:16 reset to the value of the input CRC_MASK_POR(2)\nBits 15:8   reset to the value of the input CRC_MASK_POR(1)\nBits 7:0     reset to the value of the input CRC_MASK_POR(0)\nAddress offset:\t\t\t406Ch\t\ncPCI / uplink module reset value:\tuuuu uuuu uuuu uuuu uuuu uuuu uuuu uuuub (u = unchanged)\nPOR reset value: \t\t\t???? ???? ???? ???? ???? ???? ???? ????b (? = set externally)",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "crc_unmask_lower",
          "access": "ro",
          "reset": 0,
          "doc": "Bits set in the HCD via ground command. If a bit is ‘1’, the corresponding CRC bit is considered “unmasked” and can be modified by software command. If ‘0’, writes to register CRCCTRL will have no effect on the corresponding CRC bit. \n“1” for any bit means software control of that corresponding CRC is allowed; “0” for any bit means software control of corresponding CRC is not allowed and requires Hardware Command to control the CRC or to allow control of that CRC by setting the corresponding unmask bit."
        }
      ]
    },
    "eio.ul.nvcrclc": {
      "id": "eio.ul.nvcrclc",
      "name": "nvcrclc",
      "type": "reg",
      "addr": 3235922032,
      "offset": 112,
      "doc": "Nonvolatile CRC Last Commanded State\nPer EIO requirement EIO FPGA will maintain this register following the initial software update.\nFollowing a POR software should read the current values of the non-volatile relays and update this register for better housekeeping.\n\nThe relay status is distributed to two cards:\n8 physical relays are located on the CRCC card and reflected in the EIO’s NVCRC_REG. \nThe remaining CRC’s are stored in MRAM on the EMEM card.\n\nFollowing the initial software setup EIO will update the status of these relays per the commanded state.  Upon receipt of a valid non-volatile CRC relay command from any source this register will update to the commanded state of the relay.  The relay commands are duplicated here instantaneously and do not require a relay settling time.\nFollowing the initial software setup these register values should match the corresponding 8 relay readings in the NVCRC_REG and the EMEM’s MRAM register bits.  If a mismatch is detected by flight software it should report the discrepancy.  Note, since these values are only stored in the FPGA a POR will clear all bits, hence the initial setup requirement.\nTo prevent an accidental write the NVCRCLC_en bit in the HCDSTAT register has to be set. Remove the bit upon completion to protect this register from accidental writes.\n\n\nAddress offset:\t\t\t4070h\t\ncPCI / uplink module reset value:\tuuuu uuuu uuuu uuuu uuuu uuuu uuuu uuuub (u = unchanged)\nPOR reset value: \t\t\t0000 0000h\n(Software should set the actual value\n\n*Requires NVCRCLC_en in HCDSTAT register for writes.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "lc_crc_bits",
          "access": "rw",
          "reset": 0,
          "doc": "Readback the values of the last commanded non-volatile CRCs. These bits will clear after a POR, so the commanded value will NOT match the actual value. It is up to software to read the values from the NVCRC register below and EMEM MRAM registers and write the values here.*\nTo prevent accidental writes the register bit NVCRCLC_en in the CRCCTRL register needs to be enabled."
        }
      ]
    },
    "eio.ul.nvcrc": {
      "id": "eio.ul.nvcrc",
      "name": "nvcrc",
      "type": "reg",
      "addr": 3235922036,
      "offset": 116,
      "doc": "Nonvolatile CRC Readback\nThis register allows you to read the values of only the 8 non-volatile CRCs which are connected to physical relays.  The remaining non-volatile CRCs are read via the EMEM board for they are stored on MRAM.  Note that the values of the 8 non-volatile relays should match the values on the EME board’s MRAM register for they are also set and cleared on the EMEM board automatically.  There may be a delay between the activity.\n\nAddress offset:\t\t\t4074h\t\ncPCI / uplink module reset value:\t0000 0000 u000 0000 0uuu uuu0 0000 00uub (u = unchanged)\nPOR reset value: \t\t\t0000 0000 ?000 0000 0??? ???0 0000 00??b (? = set externally)\n\n* Boot Bank Selection CRC. Automatically changes its value per the boot bank order.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "These bits are only stored on the EMEM board’s MRAM. Reads back 0 here. "
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "nvcrc55",
          "access": "ro",
          "reset": 0,
          "doc": "Readback the values of the non-volatile CRCs that are connected to physical relays. These bits can be modified (if they are unmasked) by writes to register CRCCTRL with NV_VOLn set to ‘1’. The non-volatile CRCs retain their value through power cycles, assuming that the associated physical relay exists. The physical availability of those relays is not known by the EIO for the relays are not housed on the board. Software must acquire this information via other means. Relays that do not physically exist will readback as ‘0’. Software should wait a minimum of 144ms between changing the relays and reading them back from this register. Software can also choose to wait for the SFC Relay Write Done interrupt. Note that the relays may “bounce” for a while after being changed, so it may take more than 144ms before the correct value can be read.\nThe same commands are also sent to the EMEM and so the values here should match MRAM. If they do not, the values here are considered primary, but discrepancies should be reported by software. "
        },
        {
          "nbits": 8,
          "lsb": 15,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "These bits are only stored on the EMEM board’s MRAM. Reads back 0 here. "
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "nvcrc46",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. "
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "nvcrc45",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. This bit is specifically designed for Boot Bank watchdog control, bit 2 of 2. See §12.1.8*"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "nvcrc44",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. "
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "nvcrc43",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. "
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "nvcrc42",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. This bit is specifically designed for Boot Bank watchdog control, bit 1 of 2. See §12.1.8*"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "nvcrc41",
          "access": "ro",
          "reset": 0,
          "doc": "This bit is an MRAM bit and reported from EMEM.  It is was used to validate GSE_SWEN, and required for GND_TEST_MODE, but no longer is."
        },
        {
          "nbits": 7,
          "lsb": 2,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "These bits are only stored on the EMEM board’s MRAM. Reads back 0 here. "
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nvcrc33",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. "
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nvcrc32",
          "access": "ro",
          "reset": 0,
          "doc": "See bit 23 above for NVCRC55 description. "
        }
      ]
    },
    "eio.ul.vcrc": {
      "id": "eio.ul.vcrc",
      "name": "vcrc",
      "type": "reg",
      "addr": 3235922040,
      "offset": 120,
      "doc": "Volatile CRC(31:0) Readback Register\nThis register allows you to read the values of the 32 volatile CRCs. \n\nOn POR, these bits are set according to hardwired inputs.  \nBits 31:24 reset to the value of the input CRC_POR(3)\nBits 23:16 reset to the value of the input CRC_POR(2)\nBits 15:8   reset to the value of the input CRC_POR(1)\nBits 7:0     reset to the value of the input CRC_POR(0)\n\nAddress offset:\t\t\t4078h\t\ncPCI / uplink module reset value:\tuuuu uuuu uuuu uuuu uuuu uuuu uuuu uuuub (u = unchanged)\nPOR reset value: \t\t\t???? ???? ???? ???? ???? ???? ???? ????b (? = set externally)",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "crc_bits",
          "access": "ro",
          "reset": 0,
          "doc": "Reads back the values of the volatile CRCs. These bits can be modified (if they are unmasked) by writes to register CRCCTRL with NV_VOLn set to ‘0’. Software can sample this value immediately after modifying these CRC bits. "
        }
      ]
    },
    "eio.ul.hcdstat": {
      "id": "eio.ul.hcdstat",
      "name": "hcdstat",
      "type": "reg",
      "addr": 3235922044,
      "offset": 124,
      "doc": "Hardware Command Decoder Status\nAddress offset:\t\t407Ch\ncPCI Reset value:\t\t0000 00uuh\nPOR: \t\t\t0000 0000h\nThe same two sources signals that are setting the ip2[29:26] are used to drive HCDSTAT[3:0] independently, and they are cleared independently by setting the HCDSTAT[31] =1 and  HCDSTAT[n]=1 (n=0,1,2,3,4,5)\n2- incase of the hardware tries to set it again and the software tries to clear it, Hardware Wins.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "clear_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Write “1” and write 1 in any bit 0,1,2,3 to clear that bit"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "nvcrclc_en",
          "access": "rw",
          "reset": 0,
          "doc": "Enable writing to the NVCRCLC register. This should be used following POR to synchronize the actual CRC bits with the last commanded bits.  Cleared by PCI or POR resets."
        },
        {
          "nbits": 22,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "nvspi_nack_err",
          "access": "rw",
          "reset": 0,
          "doc": "Nonvolatile MRAM memory command communication error. A NACK was received following a CRC command, when an ACK was expected.  Partial or no command might have been received by EMEM’s MRAM controller."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "nvspi_comm_err",
          "access": "rw",
          "reset": 0,
          "doc": "Nonvolatile MRAM memory command communication error. A NACK was received or no ACK was received.  Partial or no command might have been received by EMEM’s MRAM controller.\nWriting 1 to bit [31] and “1” to bit[6] will clear this bit"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "bbw_relay_err",
          "access": "rw",
          "reset": 0,
          "doc": "Boot Bank Watchdog Relay Error: Set to 1 if BBW attempts to write to the relays while a previous write is still in progress. Writing 1 to bit [31] and “1” to bit[5] will clear this bit."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "bbw_rel_done",
          "access": "rw",
          "reset": 0,
          "doc": "Boot Bank Write Done: Set when finished executing a Boot Bank Watchdog originated relay switch.\nWriting 1 to bit [31] and “1” to bit[4] will clear this bit."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "fsw_relay_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink FSW Non-Volatile Relay Error: Set to 1 if FSW attempts to write to the relays while a previous write is still in progress. Writing 1 to bit [31] and “1” to bit[3] will clear this bit"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "gnd_relay_err",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink GND Non-Volatile Relay Error: Set to 1 if GND attempts to write to the relays while a previous write is still in progress. Writing 1 to bit [31] and “1” to bit[2] will clear this bit"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "hcd_cmd_exe",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink HCD Command Executed: Set after execution of a hardware command\nWriting 1 to bit [31] and “1” to bit[1] will clear this bit"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "sfc_rel_done",
          "access": "rw",
          "reset": 0,
          "doc": "Uplink SFC Relay Write Done: Set when finished executing an FSW-originated Non-Volatile relay cmd\nWriting 1 to bit [31] and “1” to bit[0] will clear this bit"
        }
      ]
    },
    "eio.ul.ul_page_rsvd_0": {
      "id": "eio.ul.ul_page_rsvd_0",
      "name": "ul_page_rsvd_0",
      "type": "mem",
      "addr": 3235922048,
      "offset": 128,
      "doc": ""
    },
    "eio.ssiru": {
      "id": "eio.ssiru",
      "name": "ssiru",
      "type": "blk",
      "addr": 3235930112,
      "offset": 24576,
      "doc": "SSIRU and SSIRU DMA Registers",
      "children": [
        "eio.ssiru.siprevid",
        "eio.ssiru.ssiructra",
        "eio.ssiru.ssirufifor",
        "eio.ssiru.ssirufifow",
        "eio.ssiru.sedaca",
        "eio.ssiru.sramser",
        "eio.ssiru.sadcms",
        "eio.ssiru.sadstr1",
        "eio.ssiru.sadend1",
        "eio.ssiru.sadptr1",
        "eio.ssiru.ssiru_page_rsvd_0"
      ]
    },
    "eio.ssiru.siprevid": {
      "id": "eio.ssiru.siprevid",
      "name": "siprevid",
      "type": "reg",
      "addr": 3235930112,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.ssiru.ssiructra": {
      "id": "eio.ssiru.ssiructra",
      "name": "ssiructra",
      "type": "reg",
      "addr": 3235930116,
      "offset": 4,
      "doc": "SSIRU Control Register\nAddress offset:\t\t6004h\ncPCI Reset:\t0u?u uuuuh (u = unchanged, ? = external)\nPOR/SSIRU Soft Reset:\t00?0 0000h (? = external)\n\n*Requires corresponding function code bits [31:28]",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "functioncode",
          "access": "rw",
          "reset": 0,
          "doc": "Reads back 0. To prevent accidental and need for read modify writes the following keys are required to change the bit settings.\n\t0111\tAllows bit 27 alone to be modified (SSE Strobe)\n\t1110\tAllows bit 25 alone to be modified (FIFO Pointer Reset)\n\t1100\tAllows bit 24 alone to be modified (SSIRU A/B input selection)\n\t1111\tAllows bit 18 alone to be modified (SSIRU Soft Reset)\n\t0011\tClear bit 17 (FIFO Overflow)\n\t0110\tClear bits 15:4 (Counters)\n\t1011\tAllow bit 3 alone to be modified (SSIRU B Reset discrete)\n\t1001\tAllow bit 2 & 27 to be modified (SSIRU B and SSE Strobe)\n\t1010\tAllow bit 1 alone to be modified (SSIRU A Reset discrete)\n\t0101\tAllow bit 0 & 27 to be modified (SSIRU A and SSE Strobe)"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "sse_strbrw",
          "access": "rw",
          "reset": 0,
          "doc": "Enable and disable SSIRU SEE 100 Hz Strobe. * It enables SSE 100Hz Strobe if SSE_present & tz_present are active at the 1 second boundary. If SSE_present & tz_present are active, reads back a 1 when written a 1. Reads back 0 immediately after writing a 0 or when there is no tz_present or sse_present. Unlike A and B strobes this bit does not have a separate status bit and will read back what is written.\nNOTE 1: Actual strobing action will start at 1 second boundary, disable takes effect immediately.\nNOTE 2: The function code for bit 0 & 2 are shared for this bit so software does not need to make a separate independent transaction to turn on SSE strobing.\nNOTE 3: Due to Note 2 software needs to mirror the write content of bit 0 or 2 into bit 27 if the intention is to keep SSE strobe state in sync with SSIRU A and/or B.\nNOTE 4: SSE may use stand-alone function code to modify bit 27 without modifying bits 0 or 2."
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "sa_sb_selrb",
          "access": "rw",
          "reset": 0,
          "doc": "Readback of selection of SSIRU A or SSIRU B, initiated by bit 24 below, change will take effect at the next 1 second boundary. Not reset by PCI reset."
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "fifo_ptr_rst",
          "access": "rw",
          "reset": 0,
          "doc": "FIFO Pointer Reset. This zeros out the ssiru fifo push/pull pointers. Unlike PCI Reset that decrements 25 records instead.  If there are data packets in the SRAM buffer, invoking this reset causes the SRAM buffer data to never be DMAed, effectively “flushing” the fifo."
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "sa_sb_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Selects between SSIRU A or SSIRU B.  Not reset by PCI reset. Note: This bit has no effect on the strobe enables below, or the strobe generation. No auto strobe switching."
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "buffa_src",
          "access": "ro",
          "reset": 0,
          "doc": "Status of accumulated bits 20 through 22 below. Selects the source of Buff A input to be the SSE rather than SSIRUA. "
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "sse_ssiru_sel",
          "access": "ro",
          "reset": 0,
          "doc": "Status of external input SSE_SSIRU_Sel for “Buff A” source selection. Requires SSE_Present and GND_TEST_MODE below to have any affect. "
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "sse_present",
          "access": "ro",
          "reset": 0,
          "doc": "Status of SSE_Present external input. Indication of SSIRU SSE live connection and enables the echo port of selected “Buff A” source. "
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "gnd_test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "Status of GND_TEST_MODE form the TZSTR Register. "
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "sb_strb",
          "access": "ro",
          "reset": 0,
          "doc": "SSIRU B 100 Hz Strobe status. Does not reset with PCI reset. If this is the interface that sa_sb_sel is selecting then a PCI reset will cause the fifo read pinter to decrement by 25 records. See SSIRU section for details."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "sa_rst",
          "access": "rw",
          "reset": 0,
          "doc": "EIO internal SSIRU logic Soft Reset.  Does not reset the external SSIRU instrument. SSIRU DMA, STROBE A and B need to be disabled prior to using the Soft Reset. Requires Function Code 0xF above, reads back 0. Note it will NOT cause a 25-record read pointer adjust as in PCI reset. *"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "fovr",
          "access": "rw",
          "reset": 0,
          "doc": "SSIRU SRAM overflow indicator data older than 4 minutes will be overwritten with new data. *"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "sa_strb",
          "access": "ro",
          "reset": 0,
          "doc": "SSIRU A 100 Hz Strobe status. Does not reset with PCI reset. If this is the interface that sa_sb_sel is selecting then a PCI reset will cause the fifo read pinter to decrement by 25 records. See SSIRU section for details."
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "nackcnt",
          "access": "rw",
          "reset": 0,
          "doc": "Count of rejected Bias packets (0xFC) echoed and discarded. Valid only in ground test mode. Cleared with function code above. *"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "ackcnt",
          "access": "rw",
          "reset": 0,
          "doc": "Count of Acknowledged Bias packets (0xFC) echoed and discarded. Valid only in ground test mode. Cleared with function code above. *"
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "npkt",
          "access": "rw",
          "reset": 0,
          "doc": "Number of SSIRU packets received, good or bad. Cleared with function code above. *"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "go_nuc_b",
          "access": "rw",
          "reset": 0,
          "doc": "So called “Global Nuclear Detect Input” on the SSIRU B. NOTE that EIO will not generate a pulse. The state of this bit will be reflected on the EIO boards output to SSIRU. A value of 1 will cause a HIGH state and a value of 0 will cause a LOW state. ALSO NOTE that it may take up to 7.5 or more seconds before the SSIRU can be fully functional again. SEE THE IMU SPEC FOR ITS FUNTIONAL DETAILS.*"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "sb_strbw",
          "access": "rw",
          "reset": 0,
          "doc": "Enable and disable SSIRU B 100 Hz Strobe. Enable will take effect next 1 second boundary, disable takes effect immediately. Clears on GO_NUC high to low toggle. Required function code above to write.\nOn flight boards this will also enable the port B transmit signals and combined A/B receive signal buffers. *"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "go_nuc_a",
          "access": "rw",
          "reset": 0,
          "doc": "So called “Global Nuclear Detect Input” on the SSIRU A. NOTE that EIO will not generate a pulse. The state of this bit will be reflected on the EIO boards output to SSIRU. A value of 1 will cause a HIGH state and a value of 0 will cause a LOW state. ALSO NOTE that it may take up to 7.5 or more seconds before the SSIRU can be fully functional again. SEE THE IMU SPEC FOR ITS FUNTIONAL DETAILS.*"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "sa_strbw",
          "access": "rw",
          "reset": 0,
          "doc": "Enable and disable SSIRU A 100 Hz Strobe. Enable will take effect next 1 second boundary, disable takes effect immediately. Clears on GO_NUC high to low toggle. Required function code above to write.\nOn flight boards this will also enable the port A transmit signals and combined A/B receive signal buffers.  *"
        }
      ]
    },
    "eio.ssiru.ssirufifor": {
      "id": "eio.ssiru.ssirufifor",
      "name": "ssirufifor",
      "type": "reg",
      "addr": 3235930120,
      "offset": 8,
      "doc": "SSIRU FIFO Read Address Pointer (SSIRUFIFOR)\nAddress offset:\t\t\t6008h\ncPCI reset value: \t\t\tuuuu uuuuh ( u = unchanged)\nPOR/SSIRU Soft reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "sfifor",
          "access": "ro",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ssiru.ssirufifow": {
      "id": "eio.ssiru.ssirufifow",
      "name": "ssirufifow",
      "type": "reg",
      "addr": 3235930124,
      "offset": 12,
      "doc": "SSIRU FIFO Write Address Pointer (SSIRUFIFOW)\nAddress offset:\t\t\t600Ch\ncPCI reset value: \t\t\tuuuu uuuuh ( u = unchanged)\nPOR/SSIRU Soft reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "sfifow",
          "access": "ro",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ssiru.sedaca": {
      "id": "eio.ssiru.sedaca",
      "name": "sedaca",
      "type": "reg",
      "addr": 3235930128,
      "offset": 16,
      "doc": "SSIRU EDAC Error Status\nThis register holds the count value of EDAC single bit errors that were detected & corrected.  For reference it also shows the corresponding EDAC logic’s double bit error indicator from the System Health Status register.  The Error counters roll over and will set the overflow bit at maximum value of 7fh if not cleared by software.  EDAC single bit errors will be counted without indication of syndrome or data bits.  To generate an intentional single bit or double bit error, refer to §9.3.3.\nAddress offset:\t\t6010h\ncPCI reset value: \t\t0000 0uuuh ( u = unchanged)\nPOR reset value: \t\t0000 0000h\n\n* Requires corresponding function code bits [31:28]",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function Code (3:0): To save software from doing a read modify write, the Function Code bits will indicate which Function’s count should be changed.\nFunction_Code(3:0)\tFunction\n\t0101\tClear Error Address Register\n\t1001\tClear Double Bit Error\n\t0110\tClear Single Bit Error Counter and Over Flow\n\t1010\tAllow setting and clearing of sram_slftst bit 12\nThese bits read back as 0000."
        },
        {
          "nbits": 15,
          "lsb": 13,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "sram_slftst_enb",
          "access": "rw",
          "reset": 0,
          "doc": "To allow access to SRAM which will clear SSIRU DMA ENB and will drop SSIRU data packets. *"
        },
        {
          "nbits": 3,
          "lsb": 9,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "ssdberr",
          "access": "ro",
          "reset": 0,
          "doc": "SSIRU SRAM EDAC’s Double Bit Error detected. Clearing shadowed system health status register bit doe not clear this bit. *"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "ssberrctovr",
          "access": "ro",
          "reset": 0,
          "doc": "SSIRU SRAM EDAC’s Single Bit Error Counter Overflow. *"
        },
        {
          "nbits": 7,
          "lsb": 0,
          "name": "ssberrct",
          "access": "ro",
          "reset": 0,
          "doc": "SSIRU SRAM EDAC’s Single Bit Error Counter. This counter rolls over after setting the overflow above *"
        }
      ]
    },
    "eio.ssiru.sramser": {
      "id": "eio.ssiru.sramser",
      "name": "sramser",
      "type": "reg",
      "addr": 3235930132,
      "offset": 20,
      "doc": "SRAM Most Recent SBE Error Address\nThis register shows the most recent corrected Single Bit Error’s local address, i.e. not the PCI mapped address. To clear this register use Function Code 0101 in SEDAC register.\nAddress offset:\t6014h\ncPCI reset value: \t\t\t\t\t0x00uu_uuuu ( u = unchanged)\nPOR reset/SEDAC Funtion Code 0101 value:\t0x0000_0000\n\n* Requires corresponding function code bits of SEDAC_REG[31:28]",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "sramser",
          "access": "ro",
          "reset": 0,
          "doc": "This address represents the most recent corrected SBE error address. It may be the same as the First SBE Error address that follows if no other SBE errors occurred.\nThis register does not clear during PCI reset but POR. \nAlso can be cleared with function code 0101 in the SEDAC register. *"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "The 2 LSBs of the address are fixed at 0 due to DWord access of this byte address range."
        }
      ]
    },
    "eio.ssiru.sadcms": {
      "id": "eio.ssiru.sadcms",
      "name": "sadcms",
      "type": "reg",
      "addr": 3235930136,
      "offset": 24,
      "doc": "SSIRU DMA Status Control Register\nAddress offset:\t6018h\ncPCI Reset value:\t0uuu uuu0h (u = unchanged)\nPOR/SSIRU Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "ena_config",
          "access": "rw",
          "reset": 0,
          "doc": "The content of this bit is reflected to bit 0 if, bit 0 is selected. Example 8000_0001, sets dma_ena"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "test_mode",
          "access": "rw",
          "reset": 0,
          "doc": "When set dma error bit[15:13] will take whatever value is written to them.\nNOTE: FOR TESTING SOFTWARE REACTION, CLEAR FOR NORMAL OPERATION."
        },
        {
          "nbits": 13,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "buf_vld",
          "access": "rw",
          "reset": 0,
          "doc": "Indicates at least one SSIRU packet was DMA’ed. Write ‘1’ to clear , writing ‘0’ has no effect."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "dma_perr",
          "access": "rw",
          "reset": 0,
          "doc": "DMA data parity error status. Sets when data parity error is detected in DMA data. Write ‘1’ to clear.  When bit 30 is set dma error bit[15:13] will take whatever value is written to them."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "dma_t_abt",
          "access": "rw",
          "reset": 0,
          "doc": "DMA target abort status. Sets when PCI Target Abort occurs during DMA transfer. Write ‘1’ to clear.  When bit 30 is set dma error bit[15:13] will take whatever value is written to them."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "dma_m_abt",
          "access": "rw",
          "reset": 0,
          "doc": "DMA master abort status. Sets when PCI Master Abort occurs during DMA transfer. Write ‘1’ to clear.  When bit 30 is set dma error bit[15:13] will take whatever value is written to them."
        },
        {
          "nbits": 7,
          "lsb": 6,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "dma_overrun",
          "access": "rw",
          "reset": 0,
          "doc": "SSIRU DMA overrun (DMA completes before packet is done). Indicates fifo stopped unaligned with packet boundary when DMA completed.  (Not an indication of whole frame SRAM buffer)"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "dma_complete",
          "access": "rw",
          "reset": 0,
          "doc": "SSIRU DMA End Address has been reached. No more data will be transferred, till dma is enabled"
        },
        {
          "nbits": 3,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "dma_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Writing “1” to this bit will take the content of bit 31 and enables DMA buffer ,i.e. 80000001 to set dma_ena, & 00000001 to clear it. This bit will be cleared and wont set in FLT TEST MODE. \nNOTE that if DMA is disabled in the middle of a retry the last double word will still be transferred and needs to be accommodated."
        }
      ]
    },
    "eio.ssiru.sadstr1": {
      "id": "eio.ssiru.sadstr1",
      "name": "sadstr1",
      "type": "reg",
      "addr": 3235930140,
      "offset": 28,
      "doc": "SSIRU DMA Start Address Register\nThis register is set by software to indicate the start address of the buffer that SSIRU A/B DMA should transfer data to.\nAddress offset:\t601Ch\ncPCI Reset:\tuuuu uuuuh (u = unchanged)\nPOR/SSIRU Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "strt_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Start Address for DMA buffer.\nThis address is loaded into address pointer when the buffer is ready (go bit set and vld bit cleared)\nNote: If “go” bit is already set the value will not take effect till “dma_ena” bit is reset and set again."
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ssiru.sadend1": {
      "id": "eio.ssiru.sadend1",
      "name": "sadend1",
      "type": "reg",
      "addr": 3235930144,
      "offset": 32,
      "doc": "SSIRU DMA End Address Register\nThis register is set by software to indicate the end address of each buffer that SSIRU A/B DMA should stop data transfer and switch to the other buffer.\nNOTE: This register should be set such that the buffer can accommodate the longest collection of packets within the selected time interval which is mission specific.\n\nAddress offset:\t6020h\ncPCI Reset value:\tuuuu uuuuh\t(u = unchanged)\nPOR/SSIRU Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "end_addr",
          "access": "rw",
          "reset": 0,
          "doc": "End Address for DMA buffer. (Normally should be length of 20 packets)\nDMA is considered complete and dma_complete bit in the SDCMS is set once this address has been written to."
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ssiru.sadptr1": {
      "id": "eio.ssiru.sadptr1",
      "name": "sadptr1",
      "type": "reg",
      "addr": 3235930148,
      "offset": 36,
      "doc": "SSIRU DMA Pointer Address Register\nThis register indicates the next address of the buffer that the SSIRU A/B DMA will transfer data to.  This pointer will update even after overrun. \nAddress offset:\t6024h\ncPCI:\tuuuu uuuuh\nPOR/SSIRU Soft Reset value: \t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "ptr_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Pointer for next address for DMA buffer\nHardware increments this register per data transfer until end of received data packets or when the end address is reached. "
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.ssiru.ssiru_page_rsvd_0": {
      "id": "eio.ssiru.ssiru_page_rsvd_0",
      "name": "ssiru_page_rsvd_0",
      "type": "mem",
      "addr": 3235930152,
      "offset": 40,
      "doc": ""
    },
    "eio.dl": {
      "id": "eio.dl",
      "name": "dl",
      "type": "blk",
      "addr": 3235938304,
      "offset": 32768,
      "doc": "Downlink and Downlink DMA Registers",
      "children": [
        "eio.dl.dliprevid",
        "eio.dl.dpr",
        "eio.dl.dc",
        "eio.dl.dfs",
        "eio.dl.dfstm",
        "eio.dl.dfstl",
        "eio.dl.brd",
        "eio.dl.bfr",
        "eio.dl.tzasm",
        "eio.dl.ddiprev",
        "eio.dl.dldadr",
        "eio.dl.dldmal",
        "eio.dl.dldcms",
        "eio.dl.dl_page_rsvd_0"
      ]
    },
    "eio.dl.dliprevid": {
      "id": "eio.dl.dliprevid",
      "name": "dliprevid",
      "type": "reg",
      "addr": 3235938304,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.dl.dpr": {
      "id": "eio.dl.dpr",
      "name": "dpr",
      "type": "reg",
      "addr": 3235938308,
      "offset": 4,
      "doc": "Downlink Reset Register\nThis register is used to reset Downlink.\nThe associated DMA must also be enabled to allow data to flow.\nAddress offset:\t\t8004h\nPOR/cPCI reset value: \t0000 0000h\t(Reset by PCI Reset)\n\n* Requires Function_code.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "function_code",
          "access": "rw",
          "reset": 0,
          "doc": "Function Code(3:0): Three separate functions may be directed on the remaining bits depending on the state of these bits during the write to this register, except soft reset register:\n\tFunction_Code(3:0)\tFunction\n0010b\tAllows DL to be enabled\n0100b\tAllows DL to be disabled\n1100b\tAllows DL to restart\n1001b\tAllows DL to reset\nWrite a 1 to the associated bit(s) below to invoke the desired Function_Code action. These bits read back as 0000."
        },
        {
          "nbits": 25,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "dl_rstart",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Restart. See Downlink §13.0 for detailed explanation of this bit.*"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "dl_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Enable. See Downlink §13.0 for detailed explanation of this bit.*\nNote: It has been observed that EIO repeats the last frame sent following a downlink disable & re-enable. See: AVSE-JIRA-1822"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "dl_rst",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Reset. See Downlink §13.0 for detailed explanation of this bit.*"
        }
      ]
    },
    "eio.dl.dc": {
      "id": "eio.dl.dc",
      "name": "dc",
      "type": "reg",
      "addr": 3235938312,
      "offset": 8,
      "doc": "Downlink Configuration Status Register\nSome important states are controlled via this register including:\nDownlink Radio A/B select\nDriver (RS422 or LVDS) Enable control for\nTZ Telemetry Downlink \nLaunch Vehicle Telemetry Downlink\nA test mode enable bit, RAM_SlfChk_Ena, which allows PCI access of the Ping-Pong RAMs\n\n\nAddress offset:\t8008h \t\t\nPOR/cPCI & Downlink Module reset value: \t030C 0000h\t(Bit 4 reset state may not be visible)\n\t\n\n* Requires Bit Key.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "mode_bit_key",
          "access": "rw",
          "reset": 0,
          "doc": "Need to set to 1 during write to enable programming of Turbo_LS. 0 at reset and during Reads."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "slfchk_bit_key",
          "access": "rw",
          "reset": 0,
          "doc": "Need to set to 1 during write to enable programming of RAM_SlfChk_Ena. 0 at reset and during Reads."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "portselect_bit_key",
          "access": "rw",
          "reset": 0,
          "doc": "Need to set to 1 during write to enable programming of, LV_RS422_Ena, TZ_RS422_Ena, or ChanA/B_Sel. 0 at reset and during Reads."
        },
        {
          "nbits": 3,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "blank_frame_active",
          "access": "ro",
          "reset": 1,
          "doc": "Blank Frame Active: 1 when blank frames are being transmitted. 0 when Ping/Pong data frames are being transmitted. "
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "channel_active",
          "access": "ro",
          "reset": 1,
          "doc": "TBD "
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "lv_rs422_ena",
          "access": "rw",
          "reset": 1,
          "doc": "Launch Vehicle RS422 Enable: 1 at reset (enabled). This bit is used to physically enable the external board RS422 driver for LV downlink telemetry (data and clock). Requires PortSelect_Ena bit set/clear this bit. When set board signal LV_TLM_EN will go high and enable transmission of telemetry data to the Launch Vehicle.\nLV_OE in the TZSTR is required to control the external signal LV_TLM_EN.\nAlso this bit and/or tz_rs_422_ena is required for the EIO’s LV serial interface telemetry to be activated (Note: This is the same telemetry data but not the Radio Space Wire Interface)\nThis AND tz_rs422_ena need to be off (zero) for Radio Only Operation."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "tz_rs422_ena",
          "access": "rw",
          "reset": 1,
          "doc": "Time Zero RS422 Enable: 1 at reset (enabled). This bit is used to physically enable the external board RS422 driver for TZ downlink telemetry (data and clock). Requires PortSelect_Ena bit set/clear this bit. When set board signal TZ_TLM_EN will go high and enable transmission of telemetry data to the Ground Support/Test Equipment.\nTZ_OE in the TZSTR is required to control the external signal TZ_TLM_EN.\nAlso this bit and/or lv_rs_422_ena is required for the EIO’s TZ serial interface telemetry to be activated (Note: This is the same telemetry data but not the Radio Space Wire Interface)\nThis AND lv_rs422_ena need to be off (zero) for the Radio Only Operation."
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "ram_slfchk_ena",
          "access": "rw",
          "reset": 0,
          "doc": "RAM Self Check Enable: 0 at reset. When set to 1 PCI access allowed for Ping-Pong RAM (i.e., for self check purposes). When reset or programmed to 0, PCI accesses to Ping-Pong will be ignored for write data and returns “0”’s on read. No errors are generated. To set, write a 1 with EncInt_Ena (bit 30) also set to 1. This bit cannot be controlled unless downlink module is disabled (via Soft Reset and Enable). Write 0 for normal operations. *"
        },
        {
          "nbits": 7,
          "lsb": 10,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "dl_chan_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Channel A or B Select. Channel A selected by default i.e. 0. B is selected by writing 1 with the PortSelect_Ena bit also set. *"
        },
        {
          "nbits": 2,
          "lsb": 7,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "bad_header",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink Bad Header Error bit. Set to 1 when logic detects a bad header\nWrite “1” to clear , writing “0” has no effect. See Turbo_LS bit below."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "rsvd_4",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "bf_reg_sent",
          "access": "ro",
          "reset": 0,
          "doc": "Blank Frame Register Sent: Status only bit when “1” indicates that the current data in the Blank Frame Register has been read by DL Engine to prepare for transmission, a “0” indicates that the data of the Blank Frame Register has not been sent. Hardware will set this bit when the register load happens and clear this bit when the register is written by PCI. Reset will clear this bit. This bit is only valid following a reset and only when TZ_TEST_GND in enabled. This register is sent twice at the beginning of a frame. Register is set when the first byte is transmitted.\nNote: by the time software reads this register after reset this bit will be already set. "
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "turbo_ls",
          "access": "rw",
          "reset": 0,
          "doc": "Turbo Long/Short: 0 at reset (for short). By setting to 1 (with bit 31 Mode_Ena also set), software tells hardware that Turbo encoding modes on the radio is being used. This bit doesn’t set the radio mode, it only checks the DMA byte count matches to the selected mode and sets the bad header bit above if it does not match. *"
        },
        {
          "nbits": 3,
          "lsb": 0,
          "name": "rsvd_5",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.dl.dfs": {
      "id": "eio.dl.dfs",
      "name": "dfs",
      "type": "reg",
      "addr": 3235938316,
      "offset": 12,
      "doc": "Downlink Frame Status Register\nAn indication of the number of frames and bytes sent as well as a count of the pending bytes to send is provided.\nAddress offset:\t\t\t\t\t800Ch \t\t\t\t\t\t\t\nPOR/cPCI and Downlink Module reset value: \t0000 0000 h\n\nRW* Requires WenPB",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "wen_fs",
          "access": "rw",
          "reset": 0,
          "doc": "Write Enable Frame Sent: Set to 1 to enable programming of Frames_Sent(6:0) during write. 0 on read."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "wen_cb",
          "access": "rw",
          "reset": 0,
          "doc": "Write Enable Current Bytes: Set to 1 to enable programming of CurrentBytes(10:0) during write. 0 on read."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "wen_pb",
          "access": "rw",
          "reset": 0,
          "doc": "Write Enable Pending Frames to Send: Set to 1 to enable programming of Pbytes_Send (6:0) during write. 0 on read."
        },
        {
          "nbits": 7,
          "lsb": 22,
          "name": "frames_sent",
          "access": "rw",
          "reset": 0,
          "doc": "* Frames Sent(6:0): Total number of downlink frames (Non-Blank) that have been sent since downlink module was last reset, disabled (blank frames) or this field was set to 0 by software. Rolls over at 127d= 7Fh. 0 at reset. Update if desired by asserting Wen_FS bit during write. Includes repeat frames.\nNote: this field indicates the frame count being processed and the last frame may not have actually been  sent.  Software should verify the frame count with the radio, for that’s the ultimate interface aware of the frame transmission."
        },
        {
          "nbits": 11,
          "lsb": 11,
          "name": "currentbytes",
          "access": "rw",
          "reset": 0,
          "doc": "* Current Bytes (Non-Blank): This counter is for TZ interface only:\nTurbo Mode: Counts from 0 to (Number of Bytes to Send x (Turbo Rate)-1 – 1). Example: for the rate ⅓ short frame, Number of Bytes to Send equals 224d. Current Bytes (10:0) will count from 0 to 671. 0 during period ASM is being clocked.\nThis field is reset by Downlink module reset. Max value is 7FFh (1023). 0 at reset. Update if desired by asserting Wen_CB bit during write."
        },
        {
          "nbits": 11,
          "lsb": 0,
          "name": "pbytes_to_send",
          "access": "rw",
          "reset": 0,
          "doc": "* Pending Bytes to Send(10:0): \nSet to pending Number of Bytes to Send once downlink is enabled. Freezes at last Number of Bytes to Send if software has stopped sending “new” frames:\nReset will set to short frame (1760 bits) with BCh data bytes and RS interleave 1. Update if desired by asserting Wen_PB bit during write."
        }
      ]
    },
    "eio.dl.dfstm": {
      "id": "eio.dl.dfstm",
      "name": "dfstm",
      "type": "reg",
      "addr": 3235938320,
      "offset": 16,
      "doc": "Downlink Frame Start Time Register MSW\nThis register records the value of “space craft time most significant double word” register at telemetry frame’s bit one radiation time.  If this frame includes an ASM, the tag corresponds to the first bit of the ASM.  This may be used to support “time packet” creation and subsequent spacecraft to Ground time correlation.\nAddress offset:\t\t\t\t\t8010h \t\t\t\t\nPOR/cPCI and Downlink Module reset value: \t0000 0000h\n\nRW#  Cannot be written when  Downlink is Enabled (Non-Blank Frame).",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "dfst_msw",
          "access": "rw",
          "reset": 0,
          "doc": "* Downlink Frame Start Time (51:20): Downlink Telemetry Bit 1 transmission start time’s most significant double word. Least Significant Bit has a 1 second resolution. The next register contains the sub second value. Software does not need to write to this register, this register will be updated by Hardware."
        }
      ]
    },
    "eio.dl.dfstl": {
      "id": "eio.dl.dfstl",
      "name": "dfstl",
      "type": "reg",
      "addr": 3235938324,
      "offset": 20,
      "doc": "Downlink Frame Start Time Register LSW\nThis register records the value of “space craft time least significant double word” register at telemetry frame’s bit one radiation time.  If this frame includes an ASM, the tag corresponds to the first bit of the ASM.  This may be used to support “time packet” creation and subsequent spacecraft to Ground time correlation.\nAddress offset:\t\t\t\t8014h \t\t\t\t\nPOR/cPCI and Downlink Module reset value: \t0000 0000h\n\n\nRW#  Cannot be written when Downlink is Enabled (Non-Blank Frame).",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "dfst_lsw",
          "access": "rw",
          "reset": 0,
          "doc": "* Downlink Frame Start Time(19:0): Downlink Telemetry Bit 1 transmission start time. Least Significant Bit has an approximate 0.954s resolution, see § \nNote that DFSTL(19:0) is latched coincident with the 1st clock of the first data bit of the current frame when the TS bit is set in the frame header, see §13.1.2\nSoftware does not need to write to this register, this register will be updated by Hardware."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "clear_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Writing 1 to this bit and bit[0] will clear bit [0]"
        },
        {
          "nbits": 10,
          "lsb": 1,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "dl_timestamp",
          "access": "rw",
          "reset": 0,
          "doc": "* Downlink Time Correlation Packet sent. (e.g., read Downlink Frame Start Time) Writing 1 to bit[11] and bit[0] will clear this bit."
        }
      ]
    },
    "eio.dl.brd": {
      "id": "eio.dl.brd",
      "name": "brd",
      "type": "reg",
      "addr": 3235938328,
      "offset": 24,
      "doc": "Clock Rate Downlink Register\nThis register is applicable if tz_rs422_en AND/OR lv_rs422_en are set (on/enabled), even if there is no TZ or LV power present, i.e. in flight.\nThis register controls the clock rate (frequency) used to serially shift data on the TZ and LV downlink telemetry interfaces. Software sets BDIV (Baud Rate Divisor) in order to select the desired rate (DR) using the following equation. Programmed rates take effect at the beginning of the next frame. In order to change the frame rate immediately software would have to use the Soft Reset and Enable Register to restart the downlink module.  DMA engine should be configured before or after the reset.  Downlink will start over from Ping buffer with the new rate.  This register only controls the actual downlink clock signals toggling rate.  Though this rate has only for the TZ interface it will have a \nDesired Downlink Rate(DR) = SYSFREQ ÷ [ 2 x (BDIV  + 1)]\nBDIV = (SYSFREQ÷ 2DR )  - 1\nAs a corollary:\nSYSFREQ = Downlink Rate ÷ [ 2 x (BDIV  + 1)]\nFor BDIV=0, the desired rate has been hard coded to 0 MHz for SYSFREQ = 33 MHz.\nAddress offset:\t\t\t\t\t\t8018h \t\t\t\t\nPOR/cPCI/Downlink Module soft reset value: \t\t000C_96A7h (20 bps)",
      "fields": [
        {
          "nbits": 6,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "rate_pend",
          "access": "ro",
          "reset": 0,
          "doc": "Clock Rate Updated is Pending: true (1) if Clock Rate Register has been written – in other words a clock rate update has been requested. Cleared when update occurs. "
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "bdiv",
          "access": "rw",
          "reset": 824999,
          "doc": "Baud Rate Downlink Divisor: C96A7h at reset (20 bps for SYS 33MHz). These bits are used to set the clock frequency used to downlink telemetry data."
        }
      ]
    },
    "eio.dl.bfr": {
      "id": "eio.dl.bfr",
      "name": "bfr",
      "type": "reg",
      "addr": 3235938332,
      "offset": 28,
      "doc": "Blank Frame Register\nThis register contains the value of the blank frame.  This value will be sent to the TZ interface when Downlink DMA is not enabled following a reset.  Note: This value will be sent twice at start of a frame due to prefetching by DL engine.\nAddress offset:\t\t\t801Ch\nPOR/cPCI reset value:\t\tDEAD_C0DEh",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "bfr",
          "access": "rw",
          "reset": 3735929054,
          "doc": "Blank Frame Register, data sent when Downlink is not enabled, “blank frame mode.” BF_Reg_Sent bit in the DC register is set every time this value is read by DL engine."
        }
      ]
    },
    "eio.dl.tzasm": {
      "id": "eio.dl.tzasm",
      "name": "tzasm",
      "type": "reg",
      "addr": 3235938336,
      "offset": 32,
      "doc": "TZ ASM Bits Register\nThis register contains the Attached Sync Marker bits to be sent at the next frame preceding the data for TZ interface only.\nAddress offset:\t\t\t8020\nPOR/cPCI reset value:\t\t1ACF_FC1D",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "tzasm",
          "access": "rw",
          "reset": 449838109,
          "doc": "TZ ASM Bits Register"
        }
      ]
    },
    "eio.dl.ddiprev": {
      "id": "eio.dl.ddiprev",
      "name": "ddiprev",
      "type": "reg",
      "addr": 3235938352,
      "offset": 48,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.dl.dldadr": {
      "id": "eio.dl.dldadr",
      "name": "dldadr",
      "type": "reg",
      "addr": 3235938356,
      "offset": 52,
      "doc": "Downlink DMA Initial/Next Address Register\nThis register is initialized by software to indicate the initial address that the Downlink DMA should fetch data from.  This address will get incremented to indicate the next DMA address.\nAddress offset:\t\t\t8034h\t\t\t\t\t\ncPCI/DMA Soft Reset:\t\tuuuu uuuuh\t(u = unchanged)\nPOR Reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "source",
          "access": "rw",
          "reset": 0,
          "doc": "Source address for DMA (hardware increments this register per data transfer)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.dl.dldmal": {
      "id": "eio.dl.dldmal",
      "name": "dldmal",
      "type": "reg",
      "addr": 3235938360,
      "offset": 56,
      "doc": "Downlink DMA Length Register\nThis register indicates the number of double words the Downlink DMA should transfer prior to software involvement.  The DMA length is limited to the PCI space available for data storage.  The Downlink DMA reads the byte size information from the header of the pre-set up frame in the RAM and determines how many words to transfer to fill the Downlink Ping or Pong Buffer.  \nSoftware need to include the byte count for the Radio Header and be mindful of the linked list footer if used. In the event that the frame size does not contain a multiple of 4 bytes, the extra bytes will be counted as a single double word.   The Downlink DMA continues bursting to the selected Ping or Pong buffer until the frame is done; it then waits for the other buffer to be ready and proceed with the next frame.  If the DMA length reaches zero prior to completion of the last frame, a Downlink DMA Under Run Status is generated. If the length is zero prior to enabling the DMA dma_go bit will not set and Downlink DMA Under Run interrupt will be generated.\nAddress offset:\t\t\t8038h\t\t\t\t\t\ncPCI/DMA Soft Reset:\t\tuuuu uuuuh\t(u = unchanged)\nPOR Reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 2,
          "lsb": 30,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 30,
          "lsb": 0,
          "name": "length",
          "access": "rw",
          "reset": 0,
          "doc": "Number of double words to DMA (hardware decrements this register per data transfer). Downlink DMA Under Run Error if length does not cover last frame.\nNote that an extra word per frame is required for the Europa Radio Spacewire Header. Also yet another extra word per frame is required if the linked list option “569” header option is used."
        }
      ]
    },
    "eio.dl.dldcms": {
      "id": "eio.dl.dldcms",
      "name": "dldcms",
      "type": "reg",
      "addr": 3235938364,
      "offset": 60,
      "doc": "Downlink DMA Status Control Register\nThe 2 lower bytes are reserved for DMA control, while the 2 upper bytes are for status.  The DMA engine reads the byte count in the Downlink header data and transfers the specified number of bytes; however it does not validate the header.  Header validation is done by the Downlink module, so there is a potential for DMA engine to be out of sync with the Downlink engine.  It is up to the software to ensure the downlink header is correct or to clear DMA when a bad header error is generated from Downlink.\nAddress offset:\t\t\t803Ch\t\t\t\t\t\ncPCI/DMA Soft Reset:\t\tuuuu uuuu uuuu uuuu uuuu uuuu uuuu uuu0b\t(u = unchanged)\nPOR reset value: \t\t\t0000 0000h\t\nRW†\tWrite ‘1’ to set or clear, depending on function (writing ‘0’ has no effect)\nRW††\tWrite ‘1’ to set or clear.  When bit 30 is set dma error bit[17:19] will take whatever value is written to them, setting the dma error bits will generate a dma_err_int in HS2.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "clear_ena",
          "access": "ro",
          "reset": 0,
          "doc": "Setting this bit to ‘1’ and the bits 16 clear bit16\nSetting this bit to ‘1’ and the bits 20 clear bit20 "
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "test_mode",
          "access": "rw",
          "reset": 0,
          "doc": "When set prior to setting dma error bit[19:17], the error bits will take whatever value is written to them.\nNOTE: RESET FOR NORMAL OPERATION"
        },
        {
          "nbits": 9,
          "lsb": 21,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "dma_underrun",
          "access": "rw",
          "reset": 0,
          "doc": "Downlink DMA underrun.\nSets when dma length is not long enough to cover the current frame.\nTo clear Set this bit[20] and bit [31] to ‘1’"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "dma_perr",
          "access": "rw",
          "reset": 0,
          "doc": "†† DMA data parity error status. Sets when data parity is detected in DMA data. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "dma_t_abt",
          "access": "rw",
          "reset": 0,
          "doc": "†† DMA target abort status. Set when a PCI Target Abort occurs during DMA transfer. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "dma_m_abt",
          "access": "rw",
          "reset": 0,
          "doc": "†† DMA master abort status. Sets when a PCI Master Abort occurs during DMA transfer. Write ‘1’ to clear."
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "dma_done",
          "access": "rw",
          "reset": 0,
          "doc": "DMA done status.\nSets when DMA Length register reaches zero successfully. To clear set this bit [16] and the bit[31] to 1"
        },
        {
          "nbits": 13,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "dma_rst",
          "access": "rw",
          "reset": 0,
          "doc": "† Write ‘1’ to reset DMA engine. Bit will self-clear after assertion.\ndma_go bit needs to be ‘0’ for dma_rst to be set. \nIt’s a good practice to assert this bit prior to setting up new DMA instructions."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "dma_go",
          "access": "rw",
          "reset": 0,
          "doc": "Write ‘1’ to start DMA. Write ‘0’ to halt. Hardware will self-clear when dma is done, any of the above error conditions occur, a downlink DMA bad header occurs or the dma length is zero prior to enabling this bit. This bit needs to be cleared first for the dma_rst bit to take effect."
        }
      ]
    },
    "eio.dl.dl_page_rsvd_0": {
      "id": "eio.dl.dl_page_rsvd_0",
      "name": "dl_page_rsvd_0",
      "type": "mem",
      "addr": 3235938368,
      "offset": 64,
      "doc": ""
    },
    "eio.fdu": {
      "id": "eio.fdu",
      "name": "fdu",
      "type": "blk",
      "addr": 3235946496,
      "offset": 40960,
      "doc": "FDU Registers\nThis section describes the registers needed for fault detection unit (FDU) and dual string management.",
      "children": [
        "eio.fdu.fiprevid",
        "eio.fdu.fpsc",
        "eio.fdu.fpstr1",
        "eio.fdu.fpstr3",
        "eio.fdu.fpstr2",
        "eio.fdu.strcss",
        "eio.fdu.rstsr",
        "eio.fdu.fdu_page_rsvd_0"
      ]
    },
    "eio.fdu.fiprevid": {
      "id": "eio.fdu.fiprevid",
      "name": "fiprevid",
      "type": "reg",
      "addr": 3235946496,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.fdu.fpsc": {
      "id": "eio.fdu.fpsc",
      "name": "fpsc",
      "type": "reg",
      "addr": 3235946500,
      "offset": 4,
      "doc": "Fault Protection Status & Control Register\nAddress offset:\t\t\tA004h \t\t\t\t\t\ncPCI reset value: \t\t\t0000 0000 0000 0000 0000 0??? ??00 uuuub (u = unchanged; ? = External)\nPOR reset value: \t\t\t0000 0000 0000 0000 0000 0??? ??00 0000b (? = External)\n\t\t\t\t\n\nRW†, Writeable only with Fill_Bit.  The state of Fill_Bit is reflected to the bit.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "fill_bit",
          "access": "wo",
          "reset": 0,
          "doc": "The state of this bit is reflected to the bits 30:0 when written. "
        },
        {
          "nbits": 14,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "stena",
          "access": "rw",
          "reset": 0,
          "doc": "† Self test enable bit. This bit is enabled by software only and cleared by hardware when selftest fails. Use Fill_Bit."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "stack",
          "access": "rw",
          "reset": 0,
          "doc": "† Self test acknowledged bit. This bit clears self test failed state, read back ‘0’. Use Fill_Bit."
        },
        {
          "nbits": 4,
          "lsb": 11,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "csr_ena2",
          "access": "ro",
          "reset": 0,
          "doc": "Driver Enable 2 for FDU’s Prime and Online outputs. Driver controlled on the board via external inputs. (most likely via computer PIDs)"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "csr_ena1",
          "access": "ro",
          "reset": 0,
          "doc": "Driver Enable 1 for FDU’s Prime, Online and Healthbeat outputs. Driver controlled on the board via external inputs. (most likely via computer PIDs)"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "csr_ena0",
          "access": "ro",
          "reset": 0,
          "doc": "Driver Enable 0 for FDU’s Prime, Online and Healthbeat outputs. Driver controlled on the board via external inputs. (most likely via computer PIDs)"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "defselftest",
          "access": "ro",
          "reset": 0,
          "doc": "External signal for Defeat health check. Also known as Defeat Health or Defeat Self Test. ard level inputs DEFSTEST and CSRDEFSTEST. Defeat allows HEALTHBEAT to toggle even if selftest fails. "
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "healthstate",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates Healtbeat has been toggling and this string is considered healthy. Set if health defeated. "
        },
        {
          "nbits": 2,
          "lsb": 4,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "ststat",
          "access": "ro",
          "reset": 0,
          "doc": "Self test current state.  8 States see Figure 33 - Self Test States\n\nThere are three different failed stated and will stay at the failed state below till “stack” bit above is invoked.\n1001 Indicates Selftest Failed due to wrong data pattern\n1010 Indicates Selftest Failed due to wrong sequence\n1100 Indicates Selftest Failed due to timing "
        }
      ]
    },
    "eio.fdu.fpstr1": {
      "id": "eio.fdu.fpstr1",
      "name": "fpstr1",
      "type": "reg",
      "addr": 3235946504,
      "offset": 8,
      "doc": "Fault Protection Self Test Register\nThese registers need to be written with a special pattern in the specified sequence order within a single FDURTI period once self test is enabled in FDU Status and Control Register §5.7.1.\nWhen self test is enabled, failure to write to these registers in the order (Register 1, Register 2, Register 3) will cause a fault which in turn will cause a system reset. NOTE THE OUT OF SEQUNCE ADDRESSING!\nAddress offset:\t\t\tA008 (Register 1); A00C (Register 3); A010 (Register 2)\nPOR/cPCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "fdustr",
          "access": "wo",
          "reset": 0,
          "doc": "The following pattern needs to be written to the three registers in the right order:\n\n1. aaaa5555h to Test Register 1,\n2. 5555aaa8h to Test Register 2,\n3. 00ffff02h to Test Register 3.\n\nThese Registers are intentionally located out of sequence. Writes to these registers will only have an effect if Self Test is Enabled.\nAlways read back as 0h "
        }
      ]
    },
    "eio.fdu.fpstr3": {
      "id": "eio.fdu.fpstr3",
      "name": "fpstr3",
      "type": "reg",
      "addr": 3235946508,
      "offset": 12,
      "doc": "Fault Protection Self Test Register\nThese registers need to be written with a special pattern in the specified sequence order within a single FDURTI period once self test is enabled in FDU Status and Control Register §5.7.1.\nWhen self test is enabled, failure to write to these registers in the order (Register 1, Register 2, Register 3) will cause a fault which in turn will cause a system reset. NOTE THE OUT OF SEQUNCE ADDRESSING!\nAddress offset:\t\t\tA008 (Register 1); A00C (Register 3); A010 (Register 2)\nPOR/cPCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "fdustr",
          "access": "wo",
          "reset": 0,
          "doc": "The following pattern needs to be written to the three registers in the right order:\n\n1. aaaa5555h to Test Register 1,\n2. 5555aaa8h to Test Register 2,\n3. 00ffff02h to Test Register 3.\n\nThese Registers are intentionally located out of sequence. Writes to these registers will only have an effect if Self Test is Enabled.\nAlways read back as 0h "
        }
      ]
    },
    "eio.fdu.fpstr2": {
      "id": "eio.fdu.fpstr2",
      "name": "fpstr2",
      "type": "reg",
      "addr": 3235946512,
      "offset": 16,
      "doc": "Fault Protection Self Test Register\nThese registers need to be written with a special pattern in the specified sequence order within a single FDURTI period once self test is enabled in FDU Status and Control Register §5.7.1.\nWhen self test is enabled, failure to write to these registers in the order (Register 1, Register 2, Register 3) will cause a fault which in turn will cause a system reset. NOTE THE OUT OF SEQUNCE ADDRESSING!\nAddress offset:\t\t\tA008 (Register 1); A00C (Register 3); A010 (Register 2)\nPOR/cPCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "fdustr",
          "access": "wo",
          "reset": 0,
          "doc": "The following pattern needs to be written to the three registers in the right order:\n\n1. aaaa5555h to Test Register 1,\n2. 5555aaa8h to Test Register 2,\n3. 00ffff02h to Test Register 3.\n\nThese Registers are intentionally located out of sequence. Writes to these registers will only have an effect if Self Test is Enabled.\nAlways read back as 0h "
        }
      ]
    },
    "eio.fdu.strcss": {
      "id": "eio.fdu.strcss",
      "name": "strcss",
      "type": "reg",
      "addr": 3235946516,
      "offset": 20,
      "doc": "String and Cross String Status and Control Register\nThis register monitors the status of the redundancy management status bits.  Bit definitions starting with “LB” are status bits for the Loop Back signals that were outputted from the EIO.  Bits starting with “CSR” are the status bits for the Cross String EIO.  The software is required to update the bits whose definition start with “SW” and will be reflected on the EIO output at next FDURTI if the appropriate condition is met.  Any changes to this register will not take effect till the next FDURTI.  A string will not go online till its “healthy” and a string will not go Prime unless it is Online.  Bits [23:16] only changed at FDURTI boundary, bits [15:0] most likely will too however they are controlled externally.  LB signals (also known as LP) and CSR and HealthBeat signals will read back “0” when EM EIO’s external drivers that are on the board are disabled possibly via CPU signals (PID). (i.e. CSRIN_ENA & LP_ENA, that may be controlled by PID or other interfaces.)\nAddress offset:\t\t\tA014h \t\t\t\t\t\t\t\nPOR/cPCI reset value: \t\t0000 00??h (? = set externally)\n\nRW†, Writes are ignored when not healthy.",
      "fields": [
        {
          "nbits": 3,
          "lsb": 29,
          "name": "swprime",
          "access": "rw",
          "reset": 0,
          "doc": "These bits will be bit by bit reflected on the EIO Prime outputs and the Prime bits below.  These bits will be read back and reflected into Prime bits if EIO is online and Healthy i.e. at least two of the Online bits below are set and Healtbeat bit below is toggling. †"
        },
        {
          "nbits": 3,
          "lsb": 26,
          "name": "swonline",
          "access": "rw",
          "reset": 0,
          "doc": "These bits will be bit by bit reflected on the EIO Online outputs and the Online bits below, which indicate this string is capable of becoming Prime.  Online bits below will only set if EIO is Healthy i.e. Healtbeat bit below is toggling. †"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "healthbeat2_mirror",
          "access": "ro",
          "reset": 0,
          "doc": "Output toggles every FDURTI to indicate that this string is healthy. If unhealthy, this bit is reset to “0.” "
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "swhealthbeat1_mirror",
          "access": "ro",
          "reset": 0,
          "doc": "Inverted HealthBeat when the string is healthy.  Always “0” when not healthy. "
        },
        {
          "nbits": 3,
          "lsb": 21,
          "name": "prime",
          "access": "ro",
          "reset": 0,
          "doc": "Output indicates whether this string is a prime string.  3 signals are used for triple redundancy. Correspond if SW bits are reflected here on the next FDURTI. Majority vote of SW Prime bits after FDURTI.  Local String Status. "
        },
        {
          "nbits": 3,
          "lsb": 18,
          "name": "online",
          "access": "ro",
          "reset": 0,
          "doc": "Output indicates whether this string is online.  3 signals are used for triple redundancy. Corresponding SW bits are reflected here on the next FDURTI.  Majority vote of SW Prime bits after FDURTI.  Local String Status.   "
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "healthbeat2",
          "access": "ro",
          "reset": 0,
          "doc": "Output toggles every FDURTI to indicate that this string is healthy. If unhealthy, this bit is reset to “0.” "
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "healthbeat1",
          "access": "ro",
          "reset": 0,
          "doc": "Inverted HealthBeat when the string is healthy.  Always “0” when not healthy. "
        },
        {
          "nbits": 3,
          "lsb": 13,
          "name": "lbprime",
          "access": "ro",
          "reset": 0,
          "doc": "Input, loop back of the PRIME signal at the output of the driver.  Local String Status. "
        },
        {
          "nbits": 3,
          "lsb": 10,
          "name": "lbonline",
          "access": "ro",
          "reset": 0,
          "doc": "Input, loop back of the ONLINE signal at the output of the driver.  Local String Status. "
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "lbhealthbeat2",
          "access": "ro",
          "reset": 0,
          "doc": "Input, loop back of the HealthBeat 2 (Schematics: HEALTHBEAT) signal at the output of the driver. "
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "lbhealthbeat1",
          "access": "ro",
          "reset": 0,
          "doc": "Input loop back of the HealthBeat 1 (Schematics: HEALTHBEAT_n) signal at the output of the driver. "
        },
        {
          "nbits": 3,
          "lsb": 5,
          "name": "csrprime",
          "access": "ro",
          "reset": 0,
          "doc": "Input indicates the status of the cross string.  3 signals are used for triple redundancy.  Cross string status. "
        },
        {
          "nbits": 3,
          "lsb": 2,
          "name": "csronline",
          "access": "ro",
          "reset": 0,
          "doc": "Input indicates that the cross string is capable of being prime.  3 signals are used for triple redundancy.  Cross string status. "
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "csrhealthbeat2",
          "access": "ro",
          "reset": 0,
          "doc": "Input should toggle every FDURTI to indicate that this cross string is healthy.  Cross string status. "
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "csrhealthbeat1",
          "access": "ro",
          "reset": 0,
          "doc": "Input should toggle every FDURTI to opposite value of CSRHealthBeat when the string is healthy. "
        }
      ]
    },
    "eio.fdu.rstsr": {
      "id": "eio.fdu.rstsr",
      "name": "rstsr",
      "type": "reg",
      "addr": 3235946520,
      "offset": 24,
      "doc": "Reset Source Register\nThis register indicates the source of the last reset.  Flight software can clear the reset bits by writing to the Reset Acknowledge bit.\nAddress offset:\t\tA018h \t\t\t\t\t\ncPCI reset value: \t\t00?? ?u??h\t(? = depends on the last reset’s source, and count, unchanged)\nPOR reset value:\t\t0001 ?003h\t(Actual POR value is  0000 0001h, but will not be visible to software.)\n\nRW†\tTo clear bits 0 through 7 and bits 15 and 23 write ‘1’ to bit 31 and the bit that needs to be cleared.\nRW††\tBit 28 needs to be set to write to this bit.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "rst_ack",
          "access": "rw",
          "reset": 0,
          "doc": "Reset Acknowledge. The reset bits will be cleared by writing a ‘1’ to this bit and the corresponding bit 0 to 7, 15 and 23. Read back as 0. †"
        },
        {
          "nbits": 2,
          "lsb": 29,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "bbwd_tsel_vld",
          "access": "rw",
          "reset": 0,
          "doc": "Set this bit while writing to bit 8, boot bank watchdog expiration time."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "bbwd_disable",
          "access": "ro",
          "reset": 0,
          "doc": "External Input BP_ECE_BOOT_WD_DS, disables boot watchdog, so no boot bank changes or resets following boot bank change."
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "pcu_pwrgood",
          "access": "ro",
          "reset": 0,
          "doc": "PCU 28V power good indicator.  Same as in TZSTR."
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "pgood_1_8v",
          "access": "ro",
          "reset": 0,
          "doc": "1.8 Volt power good indicator.  Same as in TZSTR."
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "pgood_1_5v",
          "access": "ro",
          "reset": 0,
          "doc": "1.5 Volt power good indicator.  Same as in TZSTR."
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "pci_reset_ovf",
          "access": "rw",
          "reset": 0,
          "doc": "PCI Reset Over Flow indicator and Reset Counter clear register. This bit will set if bits 22:16 are all set. Cleared by writing a “1” combined with bit 31. Clearing this register also clears the reset counter. †"
        },
        {
          "nbits": 7,
          "lsb": 16,
          "name": "pci_rset_count",
          "access": "ro",
          "reset": 0,
          "doc": "PCI Reset counter. This counter increments every time a PCI reset is detected, including the initial PCI rest after POR. This counter will roll over; however, Over Flow bit above will be set. This register can be cleared by writing a “1” to bit 23 above at any time."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "sfc_v5_scrub_err",
          "access": "rw",
          "reset": 0,
          "doc": "Stored SFC Vertex 5 FPGA discrete status for Scrub Error. If set, software needs to clear using the rst_ack bit above.  See SFC documentation for details. Not cleared with cPCI reset."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "sfc_v5_load_fail",
          "access": "ro",
          "reset": 0,
          "doc": "SFC Vertex 5 FPGA status discrete for Load Fail. See SFC documentation for details."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "sfc_v5_load_used",
          "access": "ro",
          "reset": 0,
          "doc": "SFC Vertex 5 FPGA status discrete for Load Used. See SFC documentation."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "sfc_v5_load_done",
          "access": "ro",
          "reset": 0,
          "doc": "SFC Vertex 5 FPGA status discrete for Load Done. See SFC documentation."
        },
        {
          "nbits": 3,
          "lsb": 9,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "bbwd_tsel",
          "access": "rw",
          "reset": 0,
          "doc": "Selects the Watchdog timeout value for the boot bank select.  By default, after POR this value is 0 which corresponds to approximately 120 seconds.  This bit can be changed to 1 for a timeout value of approximately 60 seconds.  These seconds are based on the spacecraft seconds. Change has no effect during actual countdown.\nBit 28 needs to be set to write to this bit. ††"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "sw_rst",
          "access": "rw",
          "reset": 0,
          "doc": "Software Reset. Software has written to the Software Reset Bit in Software Reset Register §5.2.1.7†"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "st_rst",
          "access": "rw",
          "reset": 0,
          "doc": "ST Reset. Self Test Failed, reset initiated by the FDU when software fails to write to the self test registers 1-3 within an FDURTI. † Note: Need to clear STAck in FPSC Register before clearing this."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "rt_disc_rst",
          "access": "rw",
          "reset": 0,
          "doc": "External input from local string’s 1553 RT which received a user defined reset. MSL used a discrete bit on subaddress 3 to send a system reset request. (referred to as 1553 reset in some documents) †"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "bbwd_rst",
          "access": "rw",
          "reset": 0,
          "doc": "Boot Bank Selection Watchdog Timeout Reset †"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "hcd_rst",
          "access": "rw",
          "reset": 0,
          "doc": "HCD reset is internally connected to CRC0. This is commanded through Uplink. †"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "pci_rst",
          "access": "rw",
          "reset": 0,
          "doc": "PCI reset. This includes all the reset sources in this register. †"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "por_rst",
          "access": "rw",
          "reset": 0,
          "doc": "POR Reset. Power on reset which in turn will generate a PCI reset. †"
        }
      ]
    },
    "eio.fdu.fdu_page_rsvd_0": {
      "id": "eio.fdu.fdu_page_rsvd_0",
      "name": "fdu_page_rsvd_0",
      "type": "mem",
      "addr": 3235946524,
      "offset": 28,
      "doc": ""
    },
    "eio.tu": {
      "id": "eio.tu",
      "name": "tu",
      "type": "blk",
      "addr": 3235954688,
      "offset": 49152,
      "doc": "Timing Unit Registers",
      "children": [
        "eio.tu.tuiprev",
        "eio.tu.sctmsdw",
        "eio.tu.sctlsdw",
        "eio.tu.sctmprv",
        "eio.tu.sctlprv",
        "eio.tu.sctctr",
        "eio.tu.sict",
        "eio.tu.sctar",
        "eio.tu.sctdc",
        "eio.tu.swarti",
        "eio.tu.swartiprev",
        "eio.tu.swafctr",
        "eio.tu.tu_page_rsvd_0"
      ]
    },
    "eio.tu.tuiprev": {
      "id": "eio.tu.tuiprev",
      "name": "tuiprev",
      "type": "reg",
      "addr": 3235954688,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.tu.sctmsdw": {
      "id": "eio.tu.sctmsdw",
      "name": "sctmsdw",
      "type": "reg",
      "addr": 3235954692,
      "offset": 4,
      "doc": "Spacecraft Timer MSW\nThis is a read only register that holds the binary value of the Spacecraft Time in second’s resolution.  The rollover time is over 136 years.  This register is neither writable nor reset-able; however, software can load this register by writing to the preload registers.  The preload register value will be reflected here at the next RTI when appropriate steps are taken.  Please see Spacecraft timer synchronization §15.2 for load conditions.\nAddress offset:\t\t\tC004h\t\t\t\t\t\ncPCI reset value: \t\t\tuuuu uuuuh\t(u = unchanged)\nPOR reset value:\t\t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "sctime1_reg",
          "access": "ro",
          "reset": 0,
          "doc": "Spacecraft Time in seconds "
        }
      ]
    },
    "eio.tu.sctlsdw": {
      "id": "eio.tu.sctlsdw",
      "name": "sctlsdw",
      "type": "reg",
      "addr": 3235954696,
      "offset": 8,
      "doc": "Spacecraft Timer LSW\nThis is the subsecond’s resolution of the Spacecraft time described earlier.  The subsecond resolution is on the order of 1us.  Since it is a binary division of a second, it is by default 954ns per bit instead of 1us per bit. See §15.4 for details on how to change the resolution.  This register is neither writable nor reset-able; however, software can load this register by writing to the preload registers.  The preload register value will be reflected here at the next RTI when appropriate steps are taken.  Please see Spacecraft timer synchronization §15.2 for load conditions.\nAddress offset:\t\t\tC008h \t\t\t\t\t\ncPCI reset value: \t\t\tuuuu uuuuh\t(u = unchanged)\nPOR reset value:\t\t\t0000 0000h",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "sctime2_reg",
          "access": "ro",
          "reset": 0,
          "doc": "Spacecraft time in 20bit sub-seconds; resolution of ~1us (actually 1/1048576 or 954ns; adjustable);\nApproximate bit flip frequency for each corresponding bit provided for reference only. "
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.tu.sctmprv": {
      "id": "eio.tu.sctmprv",
      "name": "sctmprv",
      "type": "reg",
      "addr": 3235954700,
      "offset": 12,
      "doc": "Spacecraft Timer MSDW Preload Value\nThis register holds the Spacecraft second’s time that will be loaded to the Spacecraft time MSDW register when the load condition is satisfied as shown in §15.2.\nAddress offset:\t\t\tC00Ch \t\t\t\t\t\nPOR/cPCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "preload_sctime1_reg",
          "access": "rw",
          "reset": 0,
          "doc": "Value of the time to be loaded to spacecraft time, in seconds"
        }
      ]
    },
    "eio.tu.sctlprv": {
      "id": "eio.tu.sctlprv",
      "name": "sctlprv",
      "type": "reg",
      "addr": 3235954704,
      "offset": 16,
      "doc": "Spacecraft Timer LSW Preload Value\nThis register holds the Spacecraft subsecond’s time that will be loaded to the Spacecraft time LSDW register when the load condition is satisfied as shown in §15.2. \nAddress offset:\t\t\tC010h \t\t\t\t\t\nPOR/cPCI reset value: \t\t0000 0000h",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "preload_sctime2_reg",
          "access": "rw",
          "reset": 0,
          "doc": "Value of the time to be loaded to spacecraft time, in pseudo micro seconds."
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.tu.sctctr": {
      "id": "eio.tu.sctctr",
      "name": "sctctr",
      "type": "reg",
      "addr": 3235954708,
      "offset": 20,
      "doc": "Spacecraft Timer Control Register\nThis register allows control of the Global RTI and the SubRTI rate and the control of Spacecraft time load.  \nThe Current RTI and the Current RTI rates are changed only at the one second boundary of the Spacecraft clock to prevent partial long and short RTIs & SubRTIs within one second.\nAddress offset:\t\t\tC014h \t\t\t\t\t\nPOR/cPCI reset value: \t\t0016 1600h",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "rate_mod_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Software must set this bit during writes to the RTI and Sub RTI rate selection bits 12:8. Always reads back 0."
        },
        {
          "nbits": 10,
          "lsb": 21,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 18,
          "name": "current_subrti",
          "access": "ro",
          "reset": 5,
          "doc": "Indicates current Sub RTI rate:\n\n111 => indicates 4 KHz\n110 => indicates 2 KHz\n101 => indicates 1 KHz (default)\n100 => indicates 512 Hz\n011 => indicates 256 Hz\n010 => indicates 128 Hz\n001 => indicates 64 Hz\n000 => indicates 32 Hz"
        },
        {
          "nbits": 2,
          "lsb": 16,
          "name": "current_rti",
          "access": "ro",
          "reset": 2,
          "doc": "Indicates current Global RTI rate:\n\n11 => indicates 64 Hz\n10 => indicates 32 Hz (default)\n01 => indicates 16 Hz\n00 => indicates 8 Hz"
        },
        {
          "nbits": 3,
          "lsb": 13,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 10,
          "name": "sw_selsubrti",
          "access": "rw",
          "reset": 5,
          "doc": "Software selects SubRTI rate, must also set Rate_MOD_ENA (bit 31 above):\n\n111 => selects 4 KHz \n110 => selects 2 KHz \n101 => selects 1 KHz (default)\n100 => selects 512 Hz \n011 => selects 256 Hz \n010 => selects 128 Hz \n001 => selects 64 Hz \n000 => selects 32 Hz \n\nThe change is taking into effect and reflected in bits [20:18] at the one second boundary"
        },
        {
          "nbits": 2,
          "lsb": 8,
          "name": "sw_selrti",
          "access": "rw",
          "reset": 2,
          "doc": "Select Global RTI rate, must also set Rate_MOD_ENA (bit 31 above):\n\n11 => Selects 64 Hz \n10 => Selects 32 Hz (default)\n01 => Selects 16 Hz \n00 => selects 8 Hz \n\nThe change is taking into effect and reflected in bits [19:18] at the one second boundary"
        },
        {
          "nbits": 7,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "swldten",
          "access": "rw",
          "reset": 0,
          "doc": "Software Load Time Enable, to enable the load from the Spacecraft Time PreLoad Value registers to the Spacecraft Time MSDW and LSDW. It is cleared by the hardware after the PreLoad Value has been loaded. The load occurs at RTI boundary. Writing a “0” prior to RTI will disable the action."
        }
      ]
    },
    "eio.tu.sict": {
      "id": "eio.tu.sict",
      "name": "sict",
      "type": "reg",
      "addr": 3235954712,
      "offset": 24,
      "doc": "Spacecraft Timer for 1553 Timed Command\nThis register mirrors 12 bits of the Spacecraft Timer MSBs register and the upper 20 bits of the Spacecraft Timer LSBs register.  This register is used for the Timed Commands and Downlink frame stamp since a 32bit clock is needed.  This register rolls over every 1.1375 hours. \nAddress offset:\t\t\tC018h \t\t\t\t\t\ncPCI reset value: \t\t\tuuuu uuuuh\t(u = unchanged)\nPOR reset value:\t\t\t0000 0000h",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "sctime_reg32",
          "access": "ro",
          "reset": 0,
          "doc": "Spacecraft time in 32 sub-seconds; resolution of ~1us (actually 1/1048576 or 954ns); "
        }
      ]
    },
    "eio.tu.sctar": {
      "id": "eio.tu.sctar",
      "name": "sctar",
      "type": "reg",
      "addr": 3235954716,
      "offset": 28,
      "doc": "Spacecraft Timer Adjustment Register\nThe Spacecraft Timer Adjustment Register may be used to compensate for the clock differences between two strings. This Clock Adjustment Register is a 19-bit register that acts as a fine-tune for the Spacecraft Time counter. A higher value in this register will shorten the EIO’s perception of “one second,” equivalent to speeding up the clock source of the EIO.  A lower value will prolong the EIO’s perception of “one second,” equivalent to slowing down the clock source. The default value of this register is 370176 (0x5A600).  See §15.4 for details.\nThe time resolution of this Clock Adjustment Register is 1 clock period. The maximum/minimum values of the register correspond to approximately ±3000ppm (30ms per sec.) clock speed change.\nAddress offset:\t\t\tC01Ch \t\t\t\t\t\ncPCI reset value: \t\t\tuuuu uuuuh\t(u = unchanged)\nPOR reset value:\t\t\t0005_A600h",
      "fields": [
        {
          "nbits": 13,
          "lsb": 19,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 19,
          "lsb": 0,
          "name": "clkadj",
          "access": "rw",
          "reset": 370176,
          "doc": "Clock Adjustment Register. Setting to a higher value will speed up the time. Resolution is in 1 clock period (40MHz)."
        }
      ]
    },
    "eio.tu.sctdc": {
      "id": "eio.tu.sctdc",
      "name": "sctdc",
      "type": "reg",
      "addr": 3235954720,
      "offset": 32,
      "doc": "Spacecraft Timer Drift Counter\nThis Counter is an accumulator which collects the difference between the actual and expected arrival times of the Spacecraft Time Message each time the SWLDTEN (bit 0 of SCTCTR resister) is set and XRTI occurs (XRTI input is controlled most likely by Modecode17 via MRAM).  This difference represents the accumulated clock drift between the two ECEs since the last STM synchronization. The resolution of the clock drift counter is in approximately 0.954μs.  Since the STM is broadcasted once per second, the accumulator is updated once per second.\nAddress offset:\t\t\tC020h \t\t\t\t\t\ncPCI reset value: \t\t\tuuuu uuuuh\t(u = unchanged)\nPOR reset value:\t\t\t0000_0000h",
      "fields": [
        {
          "nbits": 13,
          "lsb": 19,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 19,
          "lsb": 0,
          "name": "clkdrft",
          "access": "rw",
          "reset": 0,
          "doc": "Clock Drift Counter. Resolution is in 0.954μs."
        }
      ]
    },
    "eio.tu.swarti": {
      "id": "eio.tu.swarti",
      "name": "swarti",
      "type": "reg",
      "addr": 3235954724,
      "offset": 36,
      "doc": "Current SWARTI Starting Time\nThis register indicates the Current SWARTI Starting Time with respect to RTI.  Once the Spacecraft subsecond time reaches this starting time, hardware will generate a SWARTI interrupt, which will set bit 17 of the HS1 register. \nAddress offset:\t\t\tC024h \t\t\t\t\t\nPOR/cPCI reset value:\t\tFFFF_F000h",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "cur_swarti_start_time",
          "access": "ro",
          "reset": 1048575,
          "doc": "Current SWARTI Starting Time. This value will be compared with the SC subsecond time to generate the SWARTI interrupt. The resolution is in 0.954μs. Default value of FFFF_F000h will put SWARTI aligned with RTI. The upper bits of this start time will be ignored based on the current RTI rate. Only the following bits of this filed are valid for each RTI rate:\n3 upper bits when Current_RTI = 00 (8Hz)\n4 upper bits when Current_RTI = 01 (16Hz)\n5 upper bits when Current_RTI = 10 (32Hz)\n6 upper bits when Current_RTI = 11 (64Hz)"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.tu.swartiprev": {
      "id": "eio.tu.swartiprev",
      "name": "swartiprev",
      "type": "reg",
      "addr": 3235954728,
      "offset": 40,
      "doc": "SWARTI Preload Value\nThis register indicates the preload value of the SWARTI Starting Time with respect to RTI.  This value will be loaded to the SWARTI register at the second boundary.  Upper bits are ignored depending on the RTI rate.\n\nAddress offset:\t\t\tC028h \t\t\t\t\t\nPOR/cPCI reset value:\t\tFFFF_F000h",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "swarti_start_time",
          "access": "rw",
          "reset": 1048575,
          "doc": "Preload SWARTI Starting Time. The resolution is in 0.954μs. Default value of FFFF_F000h will put SWARTI aligned with RTI.\nThe upper bits are ignored depending on the current RTI rate.\n\nRTI Rate Number of bits used Bits used Bits ignored\n64Hz 14 [25:12] [31:26]\n32Hz 15 [26:12] [31:27]\n16Hz 16 [27:12] [31:28]\n8Hz 17 [28:12] [31:29]"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.tu.swafctr": {
      "id": "eio.tu.swafctr",
      "name": "swafctr",
      "type": "reg",
      "addr": 3235954732,
      "offset": 44,
      "doc": "SWARTI & FDURTI Control Register\nThis register allows the software to select a different RTI rate for the FDU Self Test module.  It also allows the software to set the Load Enable bit for the SWARTI & FDURTI to take effect.  Spec refers to the different RTI rate as FDURTI.\n\nAddress offset:\t\t\tC02Ch \t\t\t\t\t\nPOR/cPCI reset value:\t\t0000_0000h \n\n\nRW†, Writeable only with Fill_Bit.  The state of Fill_Bit is reflected to the bit.\nRW*Takes effect at 1 second boundary.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "rate_mode_ena",
          "access": "rw",
          "reset": 0,
          "doc": "FDURTI Rate Mode Enable. Software must set this bit during write to FDURTI_SEL. Read back always 0."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "fdurti_sel_ena",
          "access": "rw",
          "reset": 0,
          "doc": "† Software enables this bit before being able to make FDURTI Selection; if disabled, FDURTI is aligned with the RTI. Must use bit 29 to select the desired state of this bit."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "fdurti_sel_ena_fill_bit",
          "access": "rw",
          "reset": 0,
          "doc": "FDURTI_SEL_ENA Fill bit. The state of this bit is reflected to bit 30 when bit 30 is also selected. Read back always 0."
        },
        {
          "nbits": 11,
          "lsb": 18,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 2,
          "lsb": 16,
          "name": "cfdurti_sel",
          "access": "ro",
          "reset": 0,
          "doc": "Current FDURTI Select. This indicates what RTI rate the FDU Self Test is currently used: 00b for 8Hz RTI, 01b for 16Hz, 10b for 32Hz and 11b for 64Hz. "
        },
        {
          "nbits": 6,
          "lsb": 10,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 2,
          "lsb": 8,
          "name": "fdurti_sel",
          "access": "rw",
          "reset": 0,
          "doc": "* Software selects this FDURTI Rate Preload value. The change is taking into effect and reflecting in bits [9:8] at the one secondary boundary.\n00b selects 8Hz, 01b selects 16Hz, 10b selects 32Hz & 11b selects 64Hz"
        },
        {
          "nbits": 7,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "swarti_load",
          "access": "rw",
          "reset": 0,
          "doc": "SWARTI Load Enable. Hardware will clear this bit after SWARTIPREV value is loaded in SWARTI. It can not be cleared by software."
        }
      ]
    },
    "eio.tu.tu_page_rsvd_0": {
      "id": "eio.tu.tu_page_rsvd_0",
      "name": "tu_page_rsvd_0",
      "type": "mem",
      "addr": 3235954736,
      "offset": 48,
      "doc": ""
    },
    "eio.bc": {
      "id": "eio.bc",
      "name": "bc",
      "type": "blk",
      "addr": 3235962880,
      "offset": 57344,
      "doc": "1553 BC and BC DMA Registers",
      "children": [
        "eio.bc.bciprev",
        "eio.bc.bcm0",
        "eio.bc.bcm1",
        "eio.bc.bcm2",
        "eio.bc.bcm3",
        "eio.bc.bcm4",
        "eio.bc.bcm5",
        "eio.bc.bcm6",
        "eio.bc.bcm7",
        "eio.bc.bcm8",
        "eio.bc.bcm9",
        "eio.bc.bcc",
        "eio.bc.bcdiprev",
        "eio.bc.bcdadr",
        "eio.bc.bcdcms",
        "eio.bc.t0",
        "eio.bc.t2c",
        "eio.bc.t2cil",
        "eio.bc.bc1553_page_rsvd_0"
      ]
    },
    "eio.bc.bciprev": {
      "id": "eio.bc.bciprev",
      "name": "bciprev",
      "type": "reg",
      "addr": 3235962880,
      "offset": 0,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.bc.bcm0": {
      "id": "eio.bc.bcm0",
      "name": "bcm0",
      "type": "reg",
      "addr": 3235962884,
      "offset": 4,
      "doc": "Internal Control Register\nInternal Address:\t\t0d \nF0/B1 Offset Address: \tE004h\nSystem reset value:\t0400h\t(See Note below) Reset by PCI or 1553 BCM soft reset see BCM_Ena_Rst §5.9.1.18); Bit 0 also cleared with Programmed Reset BCM12 §5.9.1.13.\nThis register includes all of the control bits for the 1553 BCM module\nNote: This register gets overwritten by T0 every RTI, so software will never see the system reset value of 0400h.  At the first RTI which occurs automatically BCM0 is overwritten by T0’s reset value of 0000h unless RTI mode is disabled and BC is reset via BCM soft reset.  \nAlso note that in order to change the operating modes, the host should first reset the BC, then set the mode, and finally assert the Start Enable bit.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "cmd_ab",
          "access": "rw",
          "reset": 0,
          "doc": "This bit will enable per Command Block control of the 1553 Channel selection in the BC mode. If set Bit 7 of the Control Word will define which Channel to send the command to. If “0” then the Global bcm_ab_sel below defines the channel selection. Retry on Alternate bus still applies even if this bit is set."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "rt_ad31",
          "access": "rw",
          "reset": 0,
          "doc": "When this bit is set to 0, the 1553BC recognizes RT address 31 as a broadcast command. When this bit is set to 1, the 1553BC treats RT address 31 as a normal terminal address."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "rt_sad31",
          "access": "rw",
          "reset": 0,
          "doc": "When this bit is set to 0, the 1553BC will recognize a command word either of sub-address 0 or 31 as being a valid mode code.\nWhen this bit is set to 1, the 1553BC only recognizes a command word with a sub-address of 0 as a valid mode code."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "bc_to",
          "access": "rw",
          "reset": 0,
          "doc": "Best Case Bus Controller Time-Out, i.e. no-prefetching. Also note the turnaround time.\nIf this bit is set to 1, the timer will time-out at 32 μs.  However the actual turn around time from one command to the other is 35 μs.\nIf this bit is set to 0, the timer will time-out at 21 μs with 24 μs turnaround time. \nNOTE: Depending on the settings of PCI DMA prefetch or BC Retry these timeout values may be larger."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "bc_m_sel",
          "access": "ro",
          "reset": 1,
          "doc": "BC/Mn Select. This bit would have selected between the Bus Controller and Monitor operation modes. Only Bus Controller function is allowed for EIO."
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "retry_alt",
          "access": "rw",
          "reset": 0,
          "doc": "(BC) Retry on Alternate Bus. This bit enables an automatic retry to operate on alternate buses. For example, if an automatic retry occurs while the 1553BC is operating on bus B, operation will then begin on bus A."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "bcm_ab_sel",
          "access": "rw",
          "reset": 0,
          "doc": "CMD_AB has to be “0” to write. If CMD_AB is “1” it reads back negative value of Current Control Word bit 7 and behaves accordingly.\nChannel Select A/Bn.  Select “0” for B and “1’ for A is selected for global channel select.  See cmd_ab."
        },
        {
          "nbits": 2,
          "lsb": 5,
          "name": "retry_cntr",
          "access": "rw",
          "reset": 0,
          "doc": "(Retry Count. These bits program the number of retries if an automatic retry occurs.\n\t00 = 1 retry (default)\n\t01 = 2 retries\n\t10 = 3 retires\n\t11 = 4 retries"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "retry_msg",
          "access": "rw",
          "reset": 0,
          "doc": "Retry on Bus Controller Message Error. This bit enables automatic retries on message errors detected by the Bus Controller."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "retry_to",
          "access": "rw",
          "reset": 0,
          "doc": "Retry on Time-out. This bit enables an automatic retry on a response time-out condition. Does not include timeout during data phase."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "retry_me",
          "access": "rw",
          "reset": 0,
          "doc": "Retry on Message Error. This bit enables an automatic retry when the message error bit is set in the RT’s status word response."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "retry_bsy",
          "access": "rw",
          "reset": 0,
          "doc": "Retry on RT Busy. This bit enables an automatic retry when the busy bit is set in the RT status word response."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "start_en",
          "access": "rw",
          "reset": 0,
          "doc": "Start Enable. This bit starts/restarts Command block execution. When using this function Restart the 1553BC after each system reset or soft resetThis bit reads back what was written. Readback from BC1 bit 0.This bit controls the operation of the 1553BC as follows:This bit is also reset via Programmed Reset Register BCM12.\n\tWrite 1\tStart\n\tWrite 0\tFinish Bus List, then Stop"
        }
      ]
    },
    "eio.bc.bcm1": {
      "id": "eio.bc.bcm1",
      "name": "bcm1",
      "type": "reg",
      "addr": 3235962888,
      "offset": 8,
      "doc": "Status register\nInternal Address: \t\t1d \nF0/B1 Offset Address:\tE008h\nSystem reset value:\t0080h\t(See note in §5.9.1.1 for bit 7) (Reset by PCI or 1553 BC soft reset see §5.9.1.18) \nThe Status Register is a read only register writes are Ignored. It indicates the present status of the 1553BC module.",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "bcm_mode",
          "access": "ro",
          "reset": 1,
          "doc": "Indicates the current mode of operation. 1 means BC and 0 means Monitor. This bit is a reflection of R0 bit 10. (See note in §5.13.1 for bit 7 in RTI mode) \nOnly Bus Controller function is allowed for EIO."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "a_not_b_sel",
          "access": "ro",
          "reset": 0,
          "doc": "(A/Bn) Indicates the channel presently in use or the last channel used. "
        },
        {
          "nbits": 5,
          "lsb": 1,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "bc_cmd_exe",
          "access": "ro",
          "reset": 0,
          "doc": "Bus Controller Command Block Execution in Process. This bit is a reflection of bit 0 R0 "
        }
      ]
    },
    "eio.bc.bcm2": {
      "id": "eio.bc.bcm2",
      "name": "bcm2",
      "type": "reg",
      "addr": 3235962892,
      "offset": 12,
      "doc": "Current Command Block Register\nInternal Address: \t\t2d\nF0/B1 Offset Address:\tE00Ch\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18)\nThis register contains the address of the head pointer of the Command Block being executed. Accessing a new Command Block updates it.\nNote: This register gets overwritten by T2C every RTI.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "ccb_data",
          "access": "rw",
          "reset": 0,
          "doc": "15 bit data to indicate starting address of Command Block pointer"
        }
      ]
    },
    "eio.bc.bcm3": {
      "id": "eio.bc.bcm3",
      "name": "bcm3",
      "type": "reg",
      "addr": 3235962896,
      "offset": 16,
      "doc": "Polling Compare Register\nInternal Address: \t\t3d \nF0/B1 Offset Address:\tE010h\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18\nDuring polling mode, the CPU sets the Polling Compare Register to indicate the RT response word on which the 1553BC should interrupt. This register is 11 bits wide corresponding to bit times 9 through 19 of the status word response from the RT.",
      "fields": [
        {
          "nbits": 21,
          "lsb": 11,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 11,
          "lsb": 0,
          "name": "pc_data",
          "access": "ro",
          "reset": 0,
          "doc": "(BC) Polling compare data. "
        }
      ]
    },
    "eio.bc.bcm4": {
      "id": "eio.bc.bcm4",
      "name": "bcm4",
      "type": "reg",
      "addr": 3235962900,
      "offset": 20,
      "doc": "Scratch Register\nThis register is used by the CPU to write and read back its own content for servicing the diagnostic test of the Internal Register interface between modules.\nInternal Address: \t\t4d\nF0/B1 Offset Address: \tE014h\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18)\nThis register is used by the CPU to write and read back its own content for servicing the diagnostic test of the Internal Register interface between modules.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "s_data",
          "access": "ro",
          "reset": 0,
          "doc": "(BC) 16 bit data register for write and read. "
        }
      ]
    },
    "eio.bc.bcm5": {
      "id": "eio.bc.bcm5",
      "name": "bcm5",
      "type": "reg",
      "addr": 3235962904,
      "offset": 24,
      "doc": "Current Command Register\nThis register contains the most current command sent out on the 1553 bus.  This register is updated only when BCM0 bit 0 is set.\nInternal Address: \t\t5d \nF0/B1 Offset Address: \tE018h\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "cc_data",
          "access": "ro",
          "reset": 0,
          "doc": "16 bit data for current command register "
        }
      ]
    },
    "eio.bc.bcm6": {
      "id": "eio.bc.bcm6",
      "name": "bcm6",
      "type": "reg",
      "addr": 3235962908,
      "offset": 28,
      "doc": "Interrupt Log List Pointer\nThis register is initialized by the CPU. The Interrupt Log List Pointer indicates the Start of the Interrupt Log List. After each log list entry, the BC module updates this register with the address of the next entry in the list. The software must make sure the Interrupt Log List Pointer does not point out of the BCM RAM address range.\nInternal Address: \t\t6d \nF0/B1 Offset Address: \tE01Ch\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18) \nNote: This register gets overwritten by T2CIL every RTI.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "illp_data",
          "access": "ro",
          "reset": 0,
          "doc": "Interrupt Log List Pointer "
        }
      ]
    },
    "eio.bc.bcm7": {
      "id": "eio.bc.bcm7",
      "name": "bcm7",
      "type": "reg",
      "addr": 3235962912,
      "offset": 32,
      "doc": "High Priority Interrupt Enable Register\nThis register is a read/write register. Setting the bits in this register causes a High-Priority Interrupt when the enabled event occurs. To service the High-priority Interrupt, the user reads the High-Priority-Interrupt Status Register (Register 8) to determine the cause of an interrupt and then writes to Register 8 to clear the appropriate bits.  BC also provide a Standard Priority Interrupt Scheme that does not require host intervention.  If High-Priority Interrupt service is not possible in a given application, it is advisable to use the Standard Priority features.\nInternal Address: \t\t7d \nF0/B1 Offset Address: \tE020h\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 7,
          "lsb": 9,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "doe",
          "access": "ro",
          "reset": 0,
          "doc": "Data Overrun Enable. When set, this bit enables an interrupt when the Decoder Buffer still contains a word when a new word arrives from the 1553 Bus. This usually happens when the PCI DMA Controller cannot get grant to use the memory bus in time. "
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "icee",
          "access": "ro",
          "reset": 0,
          "doc": "(BC) Illogical Command Error Enable. This bit enables a High-Priority Interrupt upon the occurrence of an Illogical Command. Illogical Command is the incorrectly formatted RT-RT Command Blocks. "
        },
        {
          "nbits": 4,
          "lsb": 3,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "eocbl",
          "access": "ro",
          "reset": 0,
          "doc": "(BC) End Of Command Block List Enable. This bit enables a High-Priority Interrupt when the BC finishes the last command on the Command Block list. This Interrupt can be superseded by the other High-Priority Interrupts "
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "hp_mee",
          "access": "ro",
          "reset": 0,
          "doc": "Message Error Enable. This bit enables a High-Priority Interrupt upon the occurrence of a message error. If a High-Priority Interrupt condition occurs, as the result of a message error, the device will halt operation until the user clears the interrupt by writing a “1” to Bit 1 of Register 8. If this interrupt is not cleared, the 1553BC remains in the HALTED state (appearing to be in a “hung up condition “), even if it receives a valid message. This High-Priority Interrupt scheme is necessary in order to maintain the BC/M’s state of operation so that the host CPU has this information available at the time of interrupt service. The 1553_HPINT_ena bit also needs to be enabled for a EIO board interrupt. "
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "ste",
          "access": "ro",
          "reset": 0,
          "doc": "Standard Interrupt Enable. If enabled, a standard interrupt is asserted. Does not cause a high priority interrupt. The 1553_STDINT_ena bit also needs to be enabled for a EIO board interrupt. "
        }
      ]
    },
    "eio.bc.bcm8": {
      "id": "eio.bc.bcm8",
      "name": "bcm8",
      "type": "reg",
      "addr": 3235962916,
      "offset": 36,
      "doc": "High-Priority Interrupt Status/Reset Register\nThe High-Priority Interrupt Status Register indicates the event that caused a High-Priority Interrupt to be asserted. To clear the interrupt signal and reset the bits, write a “1” to the appropriate bit. \nDuring normal operation, the High-Priority Interrupt Status register only supports the read operation or write “1” to clear the status. Standard Interrupts are:  BC_PCM, BC_RF, BC_MEE or BC_CBIAC\t\n\nInternal Address: \t\t8d\nF0/B1 Offset Address:\tE024h\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 7,
          "lsb": 9,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "dor",
          "access": "ro",
          "reset": 0,
          "doc": "Data Overrun Interrupt. This bit indicates a data overrun issue. "
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "ice",
          "access": "ro",
          "reset": 0,
          "doc": "Illogical Command Error. (Bad RT2RT command setup only) "
        },
        {
          "nbits": 4,
          "lsb": 3,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "eocbli",
          "access": "ro",
          "reset": 0,
          "doc": "End Of Command Block List Interrupt. This bit is set when the BC finishes the last command on the Command Block list. This Interrupt can be superseded by the other high-priority Interrupts "
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "mei",
          "access": "ro",
          "reset": 0,
          "doc": "Message Error Interrupt. This bit is set when a message error occurs. "
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "sti",
          "access": "ro",
          "reset": 0,
          "doc": "Standard Interrupt. This bit indicates that a standard interrupt has occurred, provided that bit0 of BC7 is set. "
        }
      ]
    },
    "eio.bc.bcm9": {
      "id": "eio.bc.bcm9",
      "name": "bcm9",
      "type": "reg",
      "addr": 3235962920,
      "offset": 40,
      "doc": "Standard Interrupt Enable Register\nThe Standard Interrupt Enable register contains all the enable bits for Standard Interrupt Logging.  Note: RT response \"busy\" is not considered a Message Error Event.\nInternal Address: \t\t9d \nF0/B1 Offset Address:\tE028h\nSystem reset value: \t0000h\t(Reset by PCI or 1553 soft reset see §5.9.1.18)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 12,
          "lsb": 4,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "pcm",
          "access": "ro",
          "reset": 0,
          "doc": "(BC) Polling Comparison Match. When set, this bit enables a Standard Interrupt to indicate that a Polling Comparison Match has been detected. "
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rf",
          "access": "ro",
          "reset": 0,
          "doc": "(BC) Retry Fail. This bit enables a Standard Interrupt indicating that all of the programmed number of retries have failed for the corresponding event. "
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "mee",
          "access": "ro",
          "reset": 0,
          "doc": "Message Error Event. The bit enables a Standard Interrupt for message error. "
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "cbiac",
          "access": "ro",
          "reset": 0,
          "doc": "Command Block Interrupt and Continue. This bit enables a standard Interrupt indicating that a Command Block, with the Interrupt and Continue Function enabled, has been executed. "
        }
      ]
    },
    "eio.bc.bcc": {
      "id": "eio.bc.bcc",
      "name": "bcc",
      "type": "reg",
      "addr": 3235966976,
      "offset": 4096,
      "doc": "1553 BC Status Control Register\nRTI initiated commanding is disabled via this register.\nAny BC commanding is allowed only when EIO is PRIME.  When RTI_Disable below is not set commanding will be initiated at RTI boundary and if not completed by DEADP or DTSTART a BAVA interrupt will be generated and the transceiver will be disabled.\nBC RTI independent commanding is controlled with the START_EN bit in the Internal Status Register §5.9.1.1. However EIO BC’s defaults to RTI controlled commanding.  The BC_Ena_Rst only enables/disables the RTI commanding interface.  Furthermore RTI_Disable & Timer Enable bits need to be set correctly.  1553 DMA must also be enabled to allow data to flow.\nIf the board design allows bit 0 of this register will allow software to actually turn board level component power off.  This will cause the FPGA to tristate all chip level outputs for the interface. \nAddress offset:\t\tF000h \t\t\t\t\nBC soft reset Value:\tSee individual bit descriptions for this detail\nPOR/cPCI reset value: \t0000 0110h\n\n\n* Requires Code_Enable.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "code_ena",
          "access": "wo",
          "reset": 0,
          "doc": "Code Enable(3:0): Must be set to the value indicated below to control the corresponding bit.\n\n0101b\tAllows write to RTI_Mntr_Mode, DTStart_Internal, \n1553_ChanA/B_Ena, and/or RTIDisable\n0010b\tAllows BC RTI Controller enabled, BAVA and BC_Dbe\n1001b\tAllows BC RTI Controller reset\n\nAll other combinations have no effect although there is no hardware error for such writes.\nWhen Read, these bits return the value of 0 "
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "bava",
          "access": "rw",
          "reset": 0,
          "doc": "This is not the same bit as the interrupt bit BAVA.\nBus Access Violation Attempt. Both bus inhibits are asserted when the software attempts to communicate on the 1553 bus during the dead time indicated by DTSTART or DEADP. Note that DTSTART or DEADP do not by themselves inhibit the transmitters but the BAVA error flag does. \nSW can clear this bit by writing ‘1’ and write Code Enable(3:0)=0010"
        },
        {
          "nbits": 14,
          "lsb": 12,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "rtidisable",
          "access": "rw",
          "reset": 0,
          "doc": "* RTI Disable = Software sets this bit to 1 to disable 1553 command execution based on the RTI boundaries.  Both PCI and soft reset clear this bit. Code_Ena(2:0) must be 5h during write."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "dtstart_internal",
          "access": "rw",
          "reset": 0,
          "doc": "* BC DTSTART Selection: This bit determines which DTSTART signal should be used by the BCM logic, the internal decoded signal or the external system signal. When this bit is set to ‘1’, the internal decoded signal will be used by the BCM. When this bit is set to ‘0’, the external DTSTARTn signal will be used. Code_Ena(2:0) must be 5h and TimerEnable above needs to be “0” during write."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "chanb_ena",
          "access": "rw",
          "reset": 1,
          "doc": "* 1553 Channel Enable: Enables channel B 1553 bus board driver. . This bit is ignored if BAVA is set. This output signal is forwarded to board level signal BC_B_ ENA which is logically OR-ed with the board input signal BP_BC_AB_INH to control the 1553 Channel B line driver. This bit is independent of the BCM internal register bits for the channel controls. Code_Ena(3:0) must be 5h during write and BC module must be enabled via Soft Reset and Enable. When in RTI mode 1553 commanding is only allowed during RTI non-dead time. Commanding during dead-time i.e. after DEADP or DTSTART will cause BAVA interrupt."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "bc_dbe",
          "access": "rw",
          "reset": 0,
          "doc": "Bus Controller Double Bit Error \nHard set this bit and SW can clear this bit by writing ‘1’ and write Code Enable(3:0)=0010"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "bp_bc_ab_inh",
          "access": "ro",
          "reset": 0,
          "doc": "This input signal is a board level signal BP_ECE_BC1553_INH which is logically OR-ed with BC_A_ENA and BC_B_EN on the board to control the 1553 Channel A & B line driver.  Most likely controlled via a SFC PID. Not an FPGA function."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "chana_ena",
          "access": "rw",
          "reset": 1,
          "doc": "* 1553 Channel A Enable: Enables channel A 1553 bus board driver. This bit is ignored if BAVA is set. This output signal is forwarded to board level signal BC_A_ENA which is logically OR-ed with the board input signal BP_BC_AB_INH to control the 1553 Channel A line driver. This bit is independent of the BCM internal register bits for the channel controls. Code_Ena(3:0) must be 5h during write and BC module must be enabled via Soft Reset and Enable. When in RTI mode 1553 commanding is only allowed during RTI non-dead time. Commanding during dead-time i.e. after DEADP or DTSTART will cause BAVA interrupt."
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_4",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "bcm_cntrl_rst",
          "access": "rw",
          "reset": 0,
          "doc": "* 1553 BC RTI Command Controller logic Reset.  NOTE: Reset also resets the actual BCM Protocol Engine.  BCM Protocol Engine is enabled and disabled separately by BCM Register 0 bit 0 see §5.9.1.1.  Reads Back 0."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "rsvd_5",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.bc.bcdiprev": {
      "id": "eio.bc.bcdiprev",
      "name": "bcdiprev",
      "type": "reg",
      "addr": 3235966992,
      "offset": 4112,
      "doc": "Revision ID Register",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "major",
          "access": "ro",
          "reset": 0,
          "doc": "Major component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "minor",
          "access": "ro",
          "reset": 0,
          "doc": "Minor component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "patch",
          "access": "ro",
          "reset": 0,
          "doc": "Patch component of the revision.\n\nNote that decimal numbering is used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "eio.bc.bcdadr": {
      "id": "eio.bc.bcdadr",
      "name": "bcdadr",
      "type": "reg",
      "addr": 3235966996,
      "offset": 4116,
      "doc": "1553 BCM DMA Start Address Register\nThis register is initialized by software to the starting address of the 64Kbyte reserved memory for 1553 BCM Data.  Since only the upper address bits are controlled, software can only reserve an address range starting at 64Kbyte boundary.\nAddress offset:\t\t\tF014h\t\t\t\t\t\ncPCI/1553 BC Soft Reset:\t\tuuuu 0000h\t(u = unchanged)\nPOR reset value: \t\t\t0000 0000h",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "src_dst",
          "access": "rw",
          "reset": 0,
          "doc": "Source/destination address for DMA (hardware increments this register per data transfer)"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "eio.bc.bcdcms": {
      "id": "eio.bc.bcdcms",
      "name": "bcdcms",
      "type": "reg",
      "addr": 3235967000,
      "offset": 4120,
      "doc": "1553 BCM DMA Status Control Register\nThere are no control bits for the 1553 interface, only some status bits.\nAddress offset:\t\t\tF018h\t\t\t\t\t\ncPCI/1553 BC Soft Reset:\t\tuu00 000uh\t(u = unchanged)\nPOR reset value: \t\t\t0000 0000h\n\nRW††\tWrite ‘1’ to clear.  When bit 30 is set dma error bit[1:17] will take whatever value is written to them, setting the dma error bits will generate a dma_err_int in HS2.  Note: BCM will be held in reset till all three error cases are cleared, BCM internal registers will remain unchanged.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "test_mode",
          "access": "rw",
          "reset": 0,
          "doc": "When set, dma error bit[19:17] will take whatever value is written to them.\nNOTE: RESET FOR NORMAL OPERATION"
        },
        {
          "nbits": 10,
          "lsb": 20,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "dma_perr",
          "access": "rw",
          "reset": 0,
          "doc": "DMA data parity error status. Sets when data parity is detected in DMA data. Write ‘1’ to clear ††"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "dma_t_abt",
          "access": "rw",
          "reset": 0,
          "doc": "DMA target abort status. Set when a PCI Target Abort occurs during DMA transfers. ††"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "dma_m_abt",
          "access": "rw",
          "reset": 0,
          "doc": "DMA master abort status. Set when a PCI Master Abort occurs during DMA transfers. ††"
        },
        {
          "nbits": 16,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "rd_prftch_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553 DMA Read Prefetch Enable . When set 1553 commands will be delayed till all data is pulled."
        }
      ]
    },
    "eio.bc.t0": {
      "id": "eio.bc.t0",
      "name": "t0",
      "type": "reg",
      "addr": 3235967032,
      "offset": 4152,
      "doc": "RTI dependent BCM0 Control Register\nAddress offset:\t\tF038h \t\t\t\t\t\t\t\nBCM Soft Reset: \t\tuuuu uuuuh\t(u = unchanged)\t\nPOR/cPCI reset value: \t0000 0000h\t(Reset by PCI Reset, not affected by BCM soft reset)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rtibcm0control",
          "access": "rw",
          "reset": 0,
          "doc": "Timed RTI BCM0 Control [15:0]: Same bit definitions as 1553 BCM0 Control Register. Please refer to 1553BC programming information (Appendix of this document)\n\nWhen RTI occurs hardware loads (overwrites) this register directly into the 1553 BCM0 Control register. Bit 0 (which corresponds to BCM0’s “Go” bit) needs to be set in order for the command list to be executed at the desired time.\nBit 0 of this register is automatically reset after the command list has been initiated."
        }
      ]
    },
    "eio.bc.t2c": {
      "id": "eio.bc.t2c",
      "name": "t2c",
      "type": "reg",
      "addr": 3235967036,
      "offset": 4156,
      "doc": "RTI dependent BCM2 Current Command Block Register\nAddress offset:\t\tF03Ch \t\t\t\t\t\t\t\nBCM Soft Reset: \t\tuuuu uuuuh\t(u = unchanged)\t\nPOR/cPCI reset value: \t0000 0000h\t(Reset by PCI Reset, not affected by BCM soft reset)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rtibcm2control",
          "access": "rw",
          "reset": 0,
          "doc": "RTI BCM2 Control [15:0] Same bit definitions as 1553 BCM2 Current Command Block Register. Please refer to 1553BC programming information (Appendix of this document)\n\nThis register is loaded (overwritten) into the 1553 BCM2 Current Command Block register when the RTI occurs depending on which mode of operation is selected. Unlike the actual BCM2 Current Command Block inside the 1553 BCM device, this register is not automatically updated by the 1553 BCM."
        }
      ]
    },
    "eio.bc.t2cil": {
      "id": "eio.bc.t2cil",
      "name": "t2cil",
      "type": "reg",
      "addr": 3235967044,
      "offset": 4164,
      "doc": "RTI dependent BCM6 Interrupt Log List Pointer Register\nAddress offset:\t\tF044h \t\t\t\t\t\t\t\nBCM Soft Reset: \t\tuuuu uuuuh\t(u = unchanged)\t\nPOR/cPCI reset value: \t0000 1000h\t(Reset by PCI Reset, not affected by BCM soft reset)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "rtibcm6control",
          "access": "rw",
          "reset": 0,
          "doc": "RTI BCM6 Control [15:0] Same bit definitions as 1553 BCM6 Interrupt Log List Pointer. Please refer to 1553BC programming information (Appendix of this document)\n\nThis register is loaded (overwritten) into the 1553 BCM6 Interrupt Log List Pointer when RTI occurs. Unlike the actual BCM6 Interrupt Log List Pointer inside the 1553 BCM device, this register is not automatically updated by the 1553 BCM."
        }
      ]
    },
    "eio.bc.bc1553_page_rsvd_0": {
      "id": "eio.bc.bc1553_page_rsvd_0",
      "name": "bc1553_page_rsvd_0",
      "type": "mem",
      "addr": 3235967048,
      "offset": 4168,
      "doc": ""
    },
    "emem": {
      "display_name": "EMEM",
      "version": "emem_16.0p_16.0n_20220115-176-ge619741d5",
      "links": {
        "GitHub": "https://github.jpl.nasa.gov/ecm-avs/emem",
        "Specification": "https://github.jpl.nasa.gov/ecm-avs/emem/tree/master/emem/csr_gen"
      },
      "children": [
        "emem.EMEM_APB"
      ],
      "id": "emem",
      "name": "emem",
      "addr": 3236167680,
      "offset": 3236167680
    },
    "emem.EMEM_APB": {
      "id": "emem.EMEM_APB",
      "name": "EMEM_APB",
      "type": "blk",
      "addr": 3236167680,
      "offset": 0,
      "doc": "APB registers blocks address space map\nThe 64KB APB address space contains blocks of registers implemented on the APB bus. These registers configure and report status of all EMEMP and EMEMN functions. The APB address space is defined in the following table.\n\n\tTable 5 EMEM APB Memory Space",
      "children": [
        "emem.EMEM_APB.APB_SYST",
        "emem.EMEM_APB.APB_EMEMP_FFB",
        "emem.EMEM_APB.APB_NAND_DMA",
        "emem.EMEM_APB.APB_SRAM_DMA",
        "emem.EMEM_APB.APB_SRAM",
        "emem.EMEM_APB.APB_MRAM_NVCRC",
        "emem.EMEM_APB.blk_apb_rsvd_0",
        "emem.EMEM_APB.blk_apb_rsvd_1",
        "emem.EMEM_APB.APB_ETH",
        "emem.EMEM_APB.blk_apb_rsvd_2",
        "emem.EMEM_APB.blk_apb_rsvd_3",
        "emem.EMEM_APB.blk_apb_rsvd_4",
        "emem.EMEM_APB.APB_EMEMN_SYST",
        "emem.EMEM_APB.APB_RT_1553",
        "emem.EMEM_APB.APB_EMEMN_FFB",
        "emem.EMEM_APB.blk_apb_rsvd_5",
        "emem.EMEM_APB.blk_apb_rsvd_6"
      ]
    },
    "emem.EMEM_APB.APB_SYST": {
      "id": "emem.EMEM_APB.APB_SYST",
      "name": "APB_SYST",
      "type": "blk",
      "addr": 3236167680,
      "offset": 0,
      "doc": "EMEMP System Page registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_SYST.EMEMP_REV",
        "emem.EMEM_APB.APB_SYST.EMEMP_BDID",
        "emem.EMEM_APB.APB_SYST.EMEMP_ID",
        "emem.EMEM_APB.APB_SYST.POWER_STATUS",
        "emem.EMEM_APB.APB_SYST.REPO_DATE",
        "emem.EMEM_APB.APB_SYST.NAND_DMA_PCI_WR_UPPER_ADDR",
        "emem.EMEM_APB.APB_SYST.NAND_DMA_PCI_WR_LOWER_ADDR",
        "emem.EMEM_APB.APB_SYST.NAND_DMA_SRAM_WR_UPPER_ADDR",
        "emem.EMEM_APB.APB_SYST.NAND_DMA_SRAM_WR_LOWER_ADDR",
        "emem.EMEM_APB.APB_SYST.DMA_BOUNDARY_ERROR_STATUS",
        "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_0",
        "emem.EMEM_APB.APB_SYST.BACKPLANE_DISCRETES",
        "emem.EMEM_APB.APB_SYST.ECC_CONTROL",
        "emem.EMEM_APB.APB_SYST.SRAM_DMA_PCI_WR_UPPER_ADDR",
        "emem.EMEM_APB.APB_SYST.SRAM_DMA_PCI_WR_LOWER_ADDR",
        "emem.EMEM_APB.APB_SYST.SRAM_DMA_SRAM_WR_UPPER_ADDR",
        "emem.EMEM_APB.APB_SYST.SRAM_DMA_SRAM_WR_LOWER_ADDR",
        "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_1",
        "emem.EMEM_APB.APB_SYST.TIMING_CONTROL",
        "emem.EMEM_APB.APB_SYST.TIMING_DRIFT",
        "emem.EMEM_APB.APB_SYST.FDU_LSCSS",
        "emem.EMEM_APB.APB_SYST.HKADC_CHAN_OFFSET",
        "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_2",
        "emem.EMEM_APB.APB_SYST.HKADC_VALUE",
        "emem.EMEM_APB.APB_SYST.HKADC_RTI0_SEEN",
        "emem.EMEM_APB.APB_SYST.HKADC_LAST_CHAN_OFFSET_RD",
        "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_3",
        "emem.EMEM_APB.APB_SYST.PCI_ERR_CTRL",
        "emem.EMEM_APB.APB_SYST.PCI_INIT_FIRST_ERR_ADDR",
        "emem.EMEM_APB.APB_SYST.PCI_ERR",
        "emem.EMEM_APB.APB_SYST.PCI_TARG_FIRST_ERR_ADDR",
        "emem.EMEM_APB.APB_SYST.EMEMP_RT1553_DISC_MON",
        "emem.EMEM_APB.APB_SYST.TEST_BACKPLANE_DISCRETES_OVW",
        "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_4"
      ]
    },
    "emem.EMEM_APB.APB_SYST.EMEMP_REV": {
      "id": "emem.EMEM_APB.APB_SYST.EMEMP_REV",
      "name": "EMEMP_REV",
      "type": "reg",
      "addr": 3236167680,
      "offset": 0,
      "doc": "EMEMP Revision Number",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "maj_rev",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the major revision number of this FPGA build"
        },
        {
          "nbits": 12,
          "lsb": 12,
          "name": "min_rev",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the minor revision number of this FPGA build"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "pat_rev",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the patch revision number of this FPGA build"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.EMEMP_BDID": {
      "id": "emem.EMEM_APB.APB_SYST.EMEMP_BDID",
      "name": "EMEMP_BDID",
      "type": "reg",
      "addr": 3236167684,
      "offset": 4,
      "doc": "EMEMP Board ID",
      "fields": [
        {
          "nbits": 22,
          "lsb": 10,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 2,
          "lsb": 8,
          "name": "board_type",
          "access": "ro",
          "reset": 0,
          "doc": "2 bit board type set by board jumpers.\n\n\nValue Description\n0 Breadboard\n1 Proto\n2 EM\n3 FM"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "bd_sn",
          "access": "ro",
          "reset": 0,
          "doc": "8 bit serial number set by board jumpers.  \n\nNote only the 4 LSBs are implemented in this design.  The 4 MSBs are always 0."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.EMEMP_ID": {
      "id": "emem.EMEM_APB.APB_SYST.EMEMP_ID",
      "name": "EMEMP_ID",
      "type": "reg",
      "addr": 3236167688,
      "offset": 8,
      "doc": "EMEMP FPGA ID",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "emem_common_id",
          "access": "ro",
          "reset": 0,
          "doc": "0xE3E3. Identifier common to both EMEM FPGAs"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "ememp_id",
          "access": "ro",
          "reset": 0,
          "doc": "0x09c1.Unique identifier for EMEMP-FPGA"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.POWER_STATUS": {
      "id": "emem.EMEM_APB.APB_SYST.POWER_STATUS",
      "name": "POWER_STATUS",
      "type": "reg",
      "addr": 3236167692,
      "offset": 12,
      "doc": "Power Status\nThis register provides status /monitoring for various voltages across the EMEM board.",
      "fields": [
        {
          "nbits": 29,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "pgood_se_3p3v",
          "access": "ro",
          "reset": 0,
          "doc": "High when 3.3V power for SE (Ethernet) is good"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "pgood_1p8v",
          "access": "ro",
          "reset": 0,
          "doc": "High when 1.8V power is good  (permanently tied HIGH in PROTO boards)"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "pgood_1p5v",
          "access": "ro",
          "reset": 0,
          "doc": "High when 1.5V power is good"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.REPO_DATE": {
      "id": "emem.EMEM_APB.APB_SYST.REPO_DATE",
      "name": "REPO_DATE",
      "type": "reg",
      "addr": 3236167696,
      "offset": 16,
      "doc": "Repository Date\nThis register is the last commit date of the design repository.  This is automatically generated by the checkout and build scripts.  Packed BCD format.  \nExample: Dec 31 2018  = 0x2018_1231",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "year",
          "access": "ro",
          "reset": 0,
          "doc": "character hex year"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "month",
          "access": "ro",
          "reset": 0,
          "doc": "2 character hex month"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "Day",
          "access": "ro",
          "reset": 0,
          "doc": "2 character hex day"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.NAND_DMA_PCI_WR_UPPER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.NAND_DMA_PCI_WR_UPPER_ADDR",
      "name": "NAND_DMA_PCI_WR_UPPER_ADDR",
      "type": "reg",
      "addr": 3236167700,
      "offset": 20,
      "doc": "NAND_DMA PCI Write Upper Address\nFSW sets this register to set the upper PCI address boundary limit for the NAND DMA.",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "pci_hi_bndry_addr",
          "access": "rw",
          "reset": 1073741823,
          "doc": "Upper PCI write address boundary when using NAND_DMA (= upper PCI address allowed when performing NAND read, with PCI as target, therefore writing to PCI address space).\nDefault full 32 bit address is 0xFFFF_FFFC"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.NAND_DMA_PCI_WR_LOWER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.NAND_DMA_PCI_WR_LOWER_ADDR",
      "name": "NAND_DMA_PCI_WR_LOWER_ADDR",
      "type": "reg",
      "addr": 3236167704,
      "offset": 24,
      "doc": "NAND_DMA PCI Write Lower Address\nFSW sets this register to set the lower PCI address boundary limit for the NAND DMA.",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "pci_lo_bndry_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Lower PCI write address boundary when using NAND_DMA (= lower PCI address allowed when performing NAND read, with PCI as target, therefore writing to PCI address space) ."
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.NAND_DMA_SRAM_WR_UPPER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.NAND_DMA_SRAM_WR_UPPER_ADDR",
      "name": "NAND_DMA_SRAM_WR_UPPER_ADDR",
      "type": "reg",
      "addr": 3236167708,
      "offset": 28,
      "doc": "NAND_DMA SRAM Write Upper Address\nFSW sets this register to set the upper SRAM address boundary limit for the NAND DMA.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 22,
          "lsb": 2,
          "name": "sram_hi_bndry_addr",
          "access": "rw",
          "reset": 4194303,
          "doc": "Upper SRAM write address boundary when using NAND_DMA (= upper SRAM offset address allowed when performing NAND read, with SRAM as target, therefore writing to SRAM address space).  This is the SRAM offset ONLY (not including BAR1 address). This should be in the range: \nSRAM0: 0x0 - 0x7FFFFC  / 4\nSRAM1 : 0x800000 /4  to 0xFFFFFC/4"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.NAND_DMA_SRAM_WR_LOWER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.NAND_DMA_SRAM_WR_LOWER_ADDR",
      "name": "NAND_DMA_SRAM_WR_LOWER_ADDR",
      "type": "reg",
      "addr": 3236167712,
      "offset": 32,
      "doc": "NAND_DMA SRAM Write Lower Address\nFSW sets this register to set the lower SRAM address boundary limit for the NAND DMA.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 22,
          "lsb": 2,
          "name": "sram_lo_bndry_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Lower SRAM write address boundary when using NAND_DMA (= lower SRAM address allowed when performing NAND read, with SRAM as target, therefore writing to SRAM address space). This is the SRAM offset ONLY (not including BAR1 address). This should be in the range :\nSRAM0 : 0x0 - 0x7FFFFC /4 \nSRAM1 : 0x800000 /4 to  0xFFFFFC /4"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.DMA_BOUNDARY_ERROR_STATUS": {
      "id": "emem.EMEM_APB.APB_SYST.DMA_BOUNDARY_ERROR_STATUS",
      "name": "DMA_BOUNDARY_ERROR_STATUS",
      "type": "reg",
      "addr": 3236167716,
      "offset": 36,
      "doc": "DMA Boundary Error Status\nThis register provides status regarding any boundary crossing violations defined by the DMA Upper/Lower Address Boundary Registers above.  Status bits are cleared by writing 1 in the field(s) to be cleared.",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "sram_dma_sram_wr_lower_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= SRAM_DMA detected an SRAM lower address boundary error. SRAM_DMA settings violated SRAM write lower address boundary. SRAM_DMA did not proceed (see SRAM_DMA status block).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "sram_dma_sram_wr_upper_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= SRAM_DMA detected a SRAM upper address boundary error. SRAM_DMA settings violated SRAM write upper address boundary. SRAM_DMA did not proceed (see SRAM_DMA status block).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "sram_dma_pci_wr_lower_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= SRAM_DMA detected a PCI lower address boundary error. SRAM_DMA settings violated PCI write lower address boundary. SRAM_DMA did not proceed  (see SRAM_DMA status block).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "sram_dma_pci_wr_upper_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= SRAM_DMA detected a PCI upper address boundary error. SRAM_DMA settings violated PCI write upper address boundary. SRAM_DMA did not proceed  (see SRAM_DMA status block).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "nand_dma_sram_wr_lower_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= NAND_DMA detected an SRAM lower address boundary error. NAND_DMA settings violated SRAM write lower address boundary. NAND_DMA did not proceed (see nand_dma_fail flag).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "nand_dma_sram_wr_upper_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= NAND_DMA detected a SRAM upper address boundary error. NAND_DMA settings violated SRAM write upper address boundary. NAND_DMA did not proceed (see nand_dma_fail flag).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nand_dma_pci_wr_lower_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= NAND_DMA detected a PCI lower address boundary error. NAND_DMA settings violated PCI write lower address boundary. NAND_DMA did not proceed (see nand_dma_fail flag).\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nand_dma_pci_wr_upper_addr_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= NAND_DMA detected a PCI upper address boundary error. NAND_DMA settings violated PCI write upper address boundary. NAND_DMA did not proceed (see nand_dma_fail flag).\nWrite 1 to clear this field."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_0": {
      "id": "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_0",
      "name": "rblk_apb_syst_rsvd_0",
      "type": "mem",
      "addr": 3236167720,
      "offset": 40,
      "doc": "RSVD"
    },
    "emem.EMEM_APB.APB_SYST.BACKPLANE_DISCRETES": {
      "id": "emem.EMEM_APB.APB_SYST.BACKPLANE_DISCRETES",
      "name": "BACKPLANE_DISCRETES",
      "type": "reg",
      "addr": 3236167724,
      "offset": 44,
      "doc": "Backplane Discretes Monitor\nThis register shows the status of the various discrete input signals that control state of the EMEM. EMEM_L6_613931. EMEM_L6_613932",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "bp_ece_emem_crcc_spr",
          "access": "ro",
          "reset": 0,
          "doc": "Monitors spare backplane discretes bp_ece_emem_crcc_spr."
        },
        {
          "nbits": 2,
          "lsb": 24,
          "name": "bp_ece_emem_bdsc_spr",
          "access": "ro",
          "reset": 0,
          "doc": "Monitors spare backplane discretes bp_ece_emem_bdsc_spr."
        },
        {
          "nbits": 3,
          "lsb": 21,
          "name": "bp_ece_emem_spr",
          "access": "ro",
          "reset": 0,
          "doc": "Monitors spare backplane discretes bp_ece_emem_spr."
        },
        {
          "nbits": 5,
          "lsb": 16,
          "name": "bp_ece_eio_emem_spr",
          "access": "ro",
          "reset": 0,
          "doc": "Monitors spare backplane discretes bp_ece_eio_emem_spr."
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "ecc_enable",
          "access": "ro",
          "reset": 0,
          "doc": "Monitors state of global ECC/EDAC enable (for all modules in EMEM design: NAND, SRAM, RT…).\n0 = all ECC/EDAC disabled (regardless of fine module-level ECC enable control from ECC_CONTROL)\n1=  ECC/EDAC modules enabled depending on their fine module-level ECC enable control from ECC_CONTROL). \nThis is the inverted state of backplane signal bp_nvcrc58."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "fsw2_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Write protect for FSW image 2 stored in MRAMs 6 and 7.\n1= write protected.\nDriven by discrete bp_ece_eio_emem_spr[3]\nwp_emem_mram_bank2_crc31"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fsw1_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Write protect for FSW image 1 stored in MRAMs 3 and 4.\n1= write protected.\nDriven by discrete bp_ece_eio_emem_spr[4]\nwp_emem_mram_bank1_crc30"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "fsw0_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Write protect for FSW image 0 stored in MRAMs 0 and 1.\n1= write protected. \nDriven by discrete bp_ece_mram_wprot\nwp_emem_mram_bank0_crc24"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "nand_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Write protect for NAND.  1= write protected. Note this is only for the first 1/8 of the address range (= protects die0 in each lane only) wp_emem_nand_crc21."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "unprime",
          "access": "ro",
          "reset": 0,
          "doc": "1= unprime, 0 = prime"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "flight_testmode",
          "access": "ro",
          "reset": 0,
          "doc": "1= in flight testmode"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "ground_testmode",
          "access": "ro",
          "reset": 0,
          "doc": "1= in ground testmode"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.ECC_CONTROL": {
      "id": "emem.EMEM_APB.APB_SYST.ECC_CONTROL",
      "name": "ECC_CONTROL",
      "type": "reg",
      "addr": 3236167728,
      "offset": 48,
      "doc": "Per module ECC EDAC enable control\nThis register is used to control fine ECC EDAC enable per module as well as ECC error clearing.  To enable EDAC/ECC for a module you need both :\necc_enable for that module needs to be set high and ALSO \nglobal BACKPLANE_DISCRETE.ecc_enable needs to be set high\nEMEM_L6_613993",
      "fields": [
        {
          "nbits": 19,
          "lsb": 13,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "sram_1_access_raw_ecc_bits",
          "access": "rw",
          "reset": 0,
          "doc": "Allows access to SRAM1 raw ECC bits.\nWhen this field is HIGH along with FLT_TEST_MODE enabled and  SRAM ECC disabled (either with the global NVCRC58 or the fine SRAM ECC disable) then all PCI accesses to SRAM will only be accessing the SRAM raw ECC bits.\nOnly bits 7-0 of the full 32bit Dword are meaningful in that mode. Dwords bits 7-0 will correspond to SRAM ECC bits 7-0 (true for SRAM read and  SRAM write)."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "sram_0_access_raw_ecc_bits",
          "access": "rw",
          "reset": 0,
          "doc": "Allows access to SRAM0 raw ECC bits.\nWhen this field is HIGH along with FLT_TEST_MODE enabled and  SRAM ECC disabled (either with the global NVCRC58 or the fine SRAM ECC disable) then all PCI accesses to SRAM will only be accessing the SRAM raw ECC bits.\nOnly bits 7-0 of the full 32bit Dword are meaningful in that mode. Dwords bits 7-0 will correspond to SRAM ECC bits 7-0 (true for SRAM read and  SRAM write)."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "nand_ecc_err_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to clear all error reporting for NAND (both groups A&B and DMR). Will clear error flags, counters, and error addresses)"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "mram_ecc_err_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to clear all error reporting for MRAM (all 3 MRAM devices on bus 0). Will clear error flags, counters, and error addresses)"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "sram_1_ecc_cerr_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to clear all reporting of SRAM_1 ECC correctable errors (will clear cerr detect, counter, first and last error addresses)"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "sram_1_ecc_uerr_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to clear all reporting of SRAM_1 ECC uncorrectable errors (will clear uerr detect, counter, first and last error addresses)"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "sram_0_ecc_cerr_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to clear all reporting of SRAM_0 ECC correctable errors (will clear cerr detect, counter, first and last error addresses)"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "sram_0_ecc_uerr_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to clear all reporting of SRAM_0 ECC uncorrectable errors (will clear uerr detect, counter, first and last error addresses)"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rt1553_ecc_enable",
          "access": "rw",
          "reset": 1,
          "doc": "Enables ECC/EDAC for RT1553 module.\n1= RT1553 ECC enabled IF global ECC is also enabled as monitored by BACKPLANE.DISCRETES.ecc_enable=1 \nNote: in gnd_test_mode, RT1553 RTECS register bit 26 must also be 0 for EDAC enabled, so in gnd_test_mode all 3 enables must show enabled for RT1553 EDAC to be enabled.\n0= RT1553 ECC/EDAC disabled"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nand_ecc_enable",
          "access": "rw",
          "reset": 1,
          "doc": "Enables ECC/EDAC for NAND/NAND_DMA module.\n1= NAND ECC enabled IF global ECC also enabled as monitored by BACKPLANE.DISCRETES.ecc_enable=1\n0= NAND ECC/EDAC disabled"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "sram_ecc_enable",
          "access": "rw",
          "reset": 1,
          "doc": "Enables ECC/EDAC for SRAM module.\n1= SRAM ECC enabled IF global ECC also enabled as monitored by BACKPLANE.DISCRETES.ecc_enable=1\n0= SRAM ECC/EDAC disabled"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.SRAM_DMA_PCI_WR_UPPER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.SRAM_DMA_PCI_WR_UPPER_ADDR",
      "name": "SRAM_DMA_PCI_WR_UPPER_ADDR",
      "type": "reg",
      "addr": 3236167732,
      "offset": 52,
      "doc": "SRAM_DMA PCI write Upper Address\nFSW sets this register to set the upper address boundary limit for the SRAM DMA.",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "pci_hi_bndry_addr",
          "access": "rw",
          "reset": 1073741823,
          "doc": "Upper PCI write address boundary when using SRAM_DMA (= upper PCI address allowed when performing SRAM read DMA therefore writing to PCI address space). Default full 32 bit address is 0xFFFF_FFFC"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.SRAM_DMA_PCI_WR_LOWER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.SRAM_DMA_PCI_WR_LOWER_ADDR",
      "name": "SRAM_DMA_PCI_WR_LOWER_ADDR",
      "type": "reg",
      "addr": 3236167736,
      "offset": 56,
      "doc": "SRAM_DMA PCI Write Lower Address\nFSW sets this register to set the lower PCI address boundary limit for the SRAM DMA.",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "pci_lo_bndry_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Lower PCI write address boundary when using SRAM_DMA (= lower PCI address allowed when performing SRAM DMA read therefore writing to PCI address space) ."
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.SRAM_DMA_SRAM_WR_UPPER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.SRAM_DMA_SRAM_WR_UPPER_ADDR",
      "name": "SRAM_DMA_SRAM_WR_UPPER_ADDR",
      "type": "reg",
      "addr": 3236167740,
      "offset": 60,
      "doc": "SRAM_DMA SRAM Write Upper Address\nFSW sets this register to set the upper SRAM/MRAM address boundary limit for the SRAM DMA.",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 25,
          "lsb": 2,
          "name": "sram_hi_bndry_addr",
          "access": "rw",
          "reset": 33554431,
          "doc": "Upper SRAM/MRAM write address boundary when using SRAM_DMA (= upper SRAM/MRAM offset address allowed when performing SRAM DMA write, therefore writing to SRAM/MRAM address space).  This is the SRAM/MRAM offset ONLY (not including BAR address). This should be in the range: \nSRAM0 : 0x0 - 0x7F_FFFC /4\nSRAM1 : 0x80_0000 /4 to 0xFF_FFFC /4 \nMRAM : 0x0  to 0x47F_FFFC /4"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.SRAM_DMA_SRAM_WR_LOWER_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.SRAM_DMA_SRAM_WR_LOWER_ADDR",
      "name": "SRAM_DMA_SRAM_WR_LOWER_ADDR",
      "type": "reg",
      "addr": 3236167744,
      "offset": 64,
      "doc": "SRAM_DMA SRAM Write Lower Address\nFSW sets this register to set the lower SRAM/MRAM address boundary limit for the SRAM DMA.",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 25,
          "lsb": 2,
          "name": "sram_lo_bndry_addr",
          "access": "rw",
          "reset": 0,
          "doc": "Lower SRAM/MRAM write address boundary when using SRAM_DMA (= lower SRAM/MRAM address allowed when performing SRAM/MRAM DMA write, therefore writing to SRAM/MRAM address space). This is the SRAM/MRAM offset ONLY (not including BAR address). This should be in the range :\nSRAM0 : 0x0 - 0x7FFFFC \nSRAM1 : 0x800000 -0xFFFFFC"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_1": {
      "id": "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_1",
      "name": "rblk_apb_syst_rsvd_1",
      "type": "mem",
      "addr": 3236167748,
      "offset": 68,
      "doc": "RSVD"
    },
    "emem.EMEM_APB.APB_SYST.TIMING_CONTROL": {
      "id": "emem.EMEM_APB.APB_SYST.TIMING_CONTROL",
      "name": "TIMING_CONTROL",
      "type": "reg",
      "addr": 3236167752,
      "offset": 72,
      "doc": "Timing Unit Control Register\nThe timing unit provides a drift measurement between 2 timing events.  There are 2 measurements possible, selectable by a config register.  There is a single measurement available in the drift counter register.  \nRTI to RTI\nRTI to DEADP\nThis register controls the selection of the drift measurement.",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 2,
          "lsb": 10,
          "name": "lclrti_sel",
          "access": "rw",
          "reset": 2,
          "doc": "Selects local RTI frequency. This value gets loaded into the cur_lclrti approximately every second.  \n2’b00 indicates 8Hz (XRTI decoded with MC17 with data word 0x25C3) \n2’b01 indicates 16Hz (XRTI decoded with MC17 with data word 0x25C2, 0x25C3) \n2’b10 indicates 32Hz (XRTI decoded with MC17 with data words: 0x25C1, 0x25C2, 0x25C3) \n2’b11 indicates 64Hz (XRTI decoded with MC17 with data word 0x25C0 thru 0x25C3)"
        },
        {
          "nbits": 2,
          "lsb": 8,
          "name": "cur_lclrti",
          "access": "ro",
          "reset": 2,
          "doc": "Shows current local RTI frequency. See field lclrti_sel above for details\n2’b00 indicates 8Hz \n2’b01 indicates 16Hz \n2’b10 indicates 32Hz  \n2’b11 indicates 64Hz"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "xrti_multi",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "An xrti_n was correctly detected during the first 81us of an rti period, but at least 1 more xrti_n incorrectly occurred during that rti period.\nFSW writes 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "xrti_timeout",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "An xrti_n was not detected during the first 81us of the rti period but was detected outside of that 81us expected/legal window (later during the rti period). \nPer legacy behavior, if no xRTI is received within the RTI period, this bit will NOT get set.\nFSW writes 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "xrti_nominal",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "An xrti_n was detected during the first 81us of the rti period.\nFSW writes 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "xrti_detect",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "An xrti_n was detected.\nFSW writes 1 to clear this field (does NOT clear automatically at each RTI)"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "drift_overflow",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "This error bit is set when:\n1. The drift counter is enabled\n2. At least 1 RTI negedge has been received.  \n3. An RTI has not been received in 254.2ms\nFSW writes 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "drift_enable",
          "access": "rw",
          "reset": 0,
          "doc": "Controls the enabling of the drift counter.  \nFSW writes 1 or 0 to this field to enable/disable. HW will clear this field if reaching error state.\nNote: for legacy reasons when drift_enable = 0, TIMING_DRIFT.drift_counter will not reset to 0, it will show the last drift counter value recorded when drift_enable was last set to 1.\n0 = Disabled\n1 = Enabled"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "drift_select",
          "access": "rw",
          "reset": 0,
          "doc": "Controls the drift mode measurement  configuration.\n0 = RTI to RTI\n1 = RTI to DEADP"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.TIMING_DRIFT": {
      "id": "emem.EMEM_APB.APB_SYST.TIMING_DRIFT",
      "name": "TIMING_DRIFT",
      "type": "reg",
      "addr": 3236167756,
      "offset": 76,
      "doc": "Timing Unit Drift Measurement Register\nThis register reports the drift count for the last period.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "drift_select_info",
          "access": "ro",
          "reset": 0,
          "doc": "This is just a mirror of the drift mode selected by TIMING_CONTROL.drift_select fields. The mirror here is for information only allows telemetry channel to gather setting along with drift value.\n0 = RTI_n rise to RTI_n fall (= from end of RTI pulse to beginning of next RTI pulse)\n1 = RTI_n rise to DEADP_n fall (= from end of RTI pulse to beginning of following DEADP pulse)"
        },
        {
          "nbits": 7,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "drift_counter",
          "access": "ro",
          "reset": 0,
          "doc": "Provides the drift count for the last drift measurement as configured by the drift_mode setting (reports number of 40MHz=25ns clock cycles)  \n\nExpected/nominal counts for drift_select settings at 32Hz RTI:\n\n0 (RTI-RTI) = 1,249,960 = 0x13_12A8\n1 (RTI-DEADP)= 1,199,960 = 0x12_4F58\n\nDue to retiming and other design constraints, the drift value reported could have up to +/- 5clk cycles (=+/-125ns) of uncertainty."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.FDU_LSCSS": {
      "id": "emem.EMEM_APB.APB_SYST.FDU_LSCSS",
      "name": "FDU_LSCSS",
      "type": "reg",
      "addr": 3236167760,
      "offset": 80,
      "doc": "FDU LocalString Cross String Status Register\nThis register reports FDU vectors values received from the backplane (from local string and cross-strings)",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 3,
          "lsb": 13,
          "name": "fdu_ls_prime",
          "access": "ro",
          "reset": 0,
          "doc": "3 Redundant Local String (=loopback)  PRIME signals. \nbit 7 = online 2\nbit 6 = online 1\nbit 5 = online 0"
        },
        {
          "nbits": 3,
          "lsb": 10,
          "name": "fdu_ls_online",
          "access": "ro",
          "reset": 0,
          "doc": "3 Redundant Local String (=loopback)  ONLINE signals. \nbit 4 = online 2\nbit 3 = online 1\nbit 2 = online 0"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "fdu_ls_healthbeat",
          "access": "ro",
          "reset": 0,
          "doc": "Local String (=loopback) HEALTHBEAT signal."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "fdu_ls_healthbeat_n",
          "access": "ro",
          "reset": 0,
          "doc": "Local String (=loopback) inverted HEALTHBEAT signal."
        },
        {
          "nbits": 3,
          "lsb": 5,
          "name": "fdu_csr_prime",
          "access": "ro",
          "reset": 0,
          "doc": "3 Redundant Cross String PRIME signals.  \nbit 7 = online 2\nbit 6 = online 1\nbit 5 = online 0"
        },
        {
          "nbits": 3,
          "lsb": 2,
          "name": "fdu_csr_online",
          "access": "ro",
          "reset": 0,
          "doc": "3 Redundant Cross String ONLINE signals. \nbit 4 = online 2\nbit 3 = online 1\nbit 2 = online 0"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "fdu_csr_healthbeat",
          "access": "ro",
          "reset": 0,
          "doc": "Cross String HEALTHBEAT signal."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "fdu_csr_healthbeat_n",
          "access": "ro",
          "reset": 0,
          "doc": "Cross String inverted HEALTHBEAT signal."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.HKADC_CHAN_OFFSET": {
      "id": "emem.EMEM_APB.APB_SYST.HKADC_CHAN_OFFSET",
      "name": "HKADC_CHAN_OFFSET",
      "type": "reg",
      "addr": 3236167764,
      "offset": 84,
      "doc": "8-bit unsigned integer",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "value",
          "access": "rw",
          "reset": 0,
          "doc": "A value between 0 and 39.  See Europa Clipper EMEM FPGA Specification section 7.16.9 HK_ADC operation for channel vs. offset mapping (in particular the table will show how to select instantaneous ADC channel reading versus sum/average channel reading)"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_2": {
      "id": "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_2",
      "name": "rblk_apb_syst_rsvd_2",
      "type": "mem",
      "addr": 3236167768,
      "offset": 88,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SYST.HKADC_VALUE": {
      "id": "emem.EMEM_APB.APB_SYST.HKADC_VALUE",
      "name": "HKADC_VALUE",
      "type": "reg",
      "addr": 3236167776,
      "offset": 96,
      "doc": "HKADC Measurement Register\nThis register updates with the latest HKADC reading every RTI0. Consecutive reads of this register automatically advances to next channel pair.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "channel_odd",
          "access": "ro",
          "reset": 0,
          "doc": "Odd channel reading for selected offset."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "channel_even",
          "access": "ro",
          "reset": 0,
          "doc": "Even channel reading for selected offset."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.HKADC_RTI0_SEEN": {
      "id": "emem.EMEM_APB.APB_SYST.HKADC_RTI0_SEEN",
      "name": "HKADC_RTI0_SEEN",
      "type": "reg",
      "addr": 3236167780,
      "offset": 100,
      "doc": "HKADC Measurement Register\nThis register updates with the latest HKADC reading every RTI0.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "RTI0_SEEN",
          "access": "ro",
          "reset": 0,
          "doc": "Count of RTI0 pulses seen since reset (rolls over at 16 bits)"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.HKADC_LAST_CHAN_OFFSET_RD": {
      "id": "emem.EMEM_APB.APB_SYST.HKADC_LAST_CHAN_OFFSET_RD",
      "name": "HKADC_LAST_CHAN_OFFSET_RD",
      "type": "reg",
      "addr": 3236167784,
      "offset": 104,
      "doc": "HKADC Last Channel Offset Read",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "last_offset_rd",
          "access": "ro",
          "reset": 0,
          "doc": "This reports the last HKADC Channel offset read. This is mostly for debug to report the last channel offset read. Can be useful when relying on auto-incrementing HKADC channel offsets.\n\nBit 7 of this field shows parity violation. When 1, a parity violation occurred inside the internal BRAM memory holding HKADC value for the corresponding channel."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_3": {
      "id": "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_3",
      "name": "rblk_apb_syst_rsvd_3",
      "type": "mem",
      "addr": 3236167788,
      "offset": 108,
      "doc": "RSVD"
    },
    "emem.EMEM_APB.APB_SYST.PCI_ERR_CTRL": {
      "id": "emem.EMEM_APB.APB_SYST.PCI_ERR_CTRL",
      "name": "PCI_ERR_CTRL",
      "type": "reg",
      "addr": 3236167848,
      "offset": 168,
      "doc": "PCI Error Control Register",
      "fields": [
        {
          "nbits": 29,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "t_to_dis",
          "access": "rw",
          "reset": 0,
          "doc": "Disables Target Timeout.  When asserted (“1”),  PCI Initiator Interface will wait indefinitely for a Target a response after Target assertion of DEVSEL and will not issue a Master Abort.\nWhen this bit is not asserted (“0”), the PCI Initiator Interface will behave per PCI Specification (issues a Master Abort if no Target response occurs after 32 PCI clocks following Target assertion of DEVEL).  \nNote:  If this bit and the Target TO 64 bit are both asserted, this bit takes precedence."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "t_to_64",
          "access": "rw",
          "reset": 0,
          "doc": "Disables Target Timeout.  Target Timeout 64 Clocks.  When asserted (“1”),  PCI Initiator Interface will wait 64 PCI clocks for a Target a response after Target assertion of DEVSEL (as opposed to 32 clocks per the PCI Spec) before issuing a Master Abort.\nWhen this bit is not asserted (“0”),  PCI Initiator Interface will behave per PCI Specification (issues a Master Abort if no Target response occurs after 32 PCI clocks following Target assertion of DEVEL).  \nNote:  If this bit and the Target TO Disable bit are both asserted, the Target TO Disable bit takes precedence."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.PCI_INIT_FIRST_ERR_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.PCI_INIT_FIRST_ERR_ADDR",
      "name": "PCI_INIT_FIRST_ERR_ADDR",
      "type": "reg",
      "addr": 3236167852,
      "offset": 172,
      "doc": "PCI Initiator First Error Address Register",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "pci_init_err_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Records the PCI Initiator address corresponding to the first PCI initiator error detected (=first address that generated any PCI error when EMEM DMA(s) are used as PCI initiator(s)) Only PCI_ERR fields init_perr_cmdfifo, init_perr_wrfifo, init_pci_par, init_tabort, init_mabort result in error address pci_init_err_addr. Cleared by writing anything to  PCI_ERR register."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.PCI_ERR": {
      "id": "emem.EMEM_APB.APB_SYST.PCI_ERR",
      "name": "PCI_ERR",
      "type": "reg",
      "addr": 3236167856,
      "offset": 176,
      "doc": "PCI Access Error Register",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "ffb_bridge_ok_pn",
          "access": "ro",
          "reset": 0,
          "doc": "1= Both EMEMP and EMEMN sides of the FPGA to FPGA bridge (FFB) link is up\n0 = at least one side of the FFB bridge (EMEMP or EMEMN) has declared link down\nThis field is for information only. But if PCI_ERR flags corrupted_pci_read, ui_pci_read or failed_pci_write are set then FSW should check this ffb_bridge_ok_pn field as FFB bridge must be back up before any access to EMEMN registers or RT1553 intRAM or HiMem from PCI can go through successfully."
        },
        {
          "nbits": 9,
          "lsb": 22,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "init_pci_par",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = PCI parity error detected during EMEM DMA-initiated PCI access. Detected by EMEMP PCI Initiator.  \nIf this error occurs when the DMA Engine is pulling (reading) data, the DMA Engine aborts the current operation at the end of the current 16 Dword burst and asserts cPCI PERR backplane signal.  This means up to 15 Dwords of data could be transferred before the operation aborts.\nIf this error occurs when the DMA Engine is pushing (writing) data, it means that the Target asserted PERR which will cause the DMA Engine to abort the current operation at the end of the current 16 Dword burst.  This means up to 15 Dwords of data could be transferred before the operation aborts.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "init_tabort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = PCI target abort reported during EMEM DMA-initiated PCI access. Detected by EMEMP PCI Initiator.  Note:  For an ARINC Space Partition compliant system like the Europa Compute Element, a Target Abort should rarely or never occur, so this status bit is provided to accommodate targets that may be allowed to issue a Target Abort under special circumstances. DMA engine that initated this transfer will abort operation.\nIf Write 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "init_mabort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = PCI master abort reported during EMEM DMA-initiated PCI access. Issued and reported by EMEMP PCI Initiator.  DMA engine that initiated this transfer will abort operation.\nIf Write 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "init_perr_rdfifo",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = PCI initiator parity error in read FIFO during EMEM DMA-initiated PCI access. Detected by EMEMP PCI Initiator. No matching error address provided.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "init_perr_wrfifo",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = PCI initiator parity error in write FIFO during EMEM DMA-initiated PCI access. Detected by EMEMP PCI Initiator.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "init_perr_cmdfifo",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = PCI initiator parity error in cmd FIFO during EMEM DMA-initiated PCI access. Detected by EMEMP PCI Initiator.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "t_perr_wrfifo",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= Target PCI detected Write FIFO parity error (in internal BRAM-based write FIFO)\nDetected by EMEMP PCI Target. No matching error address provided.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "t_perr_rdfifo",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= Target PCI detected Read FIFO parity error (in internal BRAM-based read FIFO)\nDetected by EMEMP PCI Target. No matching error address provided.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "t_tabort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= Target PCI asserted Target Abort. Unsupported/unused for Europa Clipper.\nDetected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "t_mabort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= Target PCI asserted Master Abort. This will happen in case of unsupported PCI Command.  The PCI Target detected a valid address, but an unsupported PCI Command.  In this case the PCI core will force a Master Abort (no DEVSEL). No data is exchanged. Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "pci_par_wrerr",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= Target PCI Write Parity Error.  The PCI Target detected a parity error when receiving data (from an external PCI initiator).  In this case, the PCI core will accept the data and assert the PERR backplane signal. Bad data will written to its destination due to legacy PCI core behavior. Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "BO_read_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = Burst Order Read Error.  The PCI Target received a read command where the least significant address bits were not 2’b00 (not supported by Europa).  Note:  The PCI Interface will zero out the LSB 2 address bits, return one Dword based on that address and disconnect in accordance with the PCI specification. Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "BO_write_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = Burst Order Write Error.  The PCI Target received a write command where the least significant address bits were not 2’b00 (not supported by EuropaNote:  The PCI Interface will zero out the LSB 2 address bits and transfer 1 Dword of data based on that address and disconnect in accordance with the PCI specification. Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "byte_read_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = The PCI CBEs (Command Byte Enables) were not all asserted (indicating a sub Dword read).  This is allowed by PCI, but not allowed by Europa.  Note:  The PCI Interface will return all 4 bytes of data and take no further action (i.e. no target abort, retry, etc.). Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "byte_write_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1= The PCI CBEs (Command Byte Enables) were not all asserted (indicating a sub Dword write).  This is allowed by PCI, but not allowed by Europa.  Note:  The PCI Interface will bit bucket the write data disconnect, which gracefully terminates the transaction.  The PCI Target Abort status bit will assert in the PCI Configuration Status Register, but the EMEM Target does not force a Target Abort. Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 4,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "corrupted_pci_read",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = Data read during PCI read was corrupted (e.g. due to SRAM EDAC/DBE, due to data corruption when reading remote EMEMN FPGA resource or any other data corruption on the path). Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "ui_pci_read",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = Unimplemented / illegal PCI read access detected (access to reserved/illegal/unmapped address). In that case the reserved data code 0xbad_c0de will have been read on PCI data bus. Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "failed_pci_write",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1 = Unimplemented / illegal or otherwise failed PCI write access detected (access to reserved/illegal/unmapped/read-only address or write to remote EMEMN FPGA resource that did not complete properly). Detected by EMEMP PCI Target.\nWrite 1 to clear this field."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.PCI_TARG_FIRST_ERR_ADDR": {
      "id": "emem.EMEM_APB.APB_SYST.PCI_TARG_FIRST_ERR_ADDR",
      "name": "PCI_TARG_FIRST_ERR_ADDR",
      "type": "reg",
      "addr": 3236167860,
      "offset": 180,
      "doc": "PCI Target First Error Address Register",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "pci_targ_err_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Records the PCI Target address corresponding to the first PCI target error detected in PCI_ERR bits 0-12 (=first invalid address when EMEM used as PCI target). Note: t_perr_rdfifo and t_perr_wrfifo do NOT result in error address pci_targ_err_addr. Cleared by writing anything to  PCI_ERR register."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.EMEMP_RT1553_DISC_MON": {
      "id": "emem.EMEM_APB.APB_SYST.EMEMP_RT1553_DISC_MON",
      "name": "EMEMP_RT1553_DISC_MON",
      "type": "reg",
      "addr": 3236167864,
      "offset": 184,
      "doc": "EMEMP RT1553 Discretes Monitor Register",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 7,
          "lsb": 9,
          "name": "ememp_rt_1553_disco_mon",
          "access": "ro",
          "reset": 0,
          "doc": "RT1553 DISC0 monitoring on EMEMP side (for debug purposes only)\nDisco[7:1] = bits 15:9"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "ememp_rt_1553_disci_mon",
          "access": "ro",
          "reset": 0,
          "doc": "RT1553 DISCI monitoring on EMEMP side (for debug purposes only)"
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.TEST_BACKPLANE_DISCRETES_OVW": {
      "id": "emem.EMEM_APB.APB_SYST.TEST_BACKPLANE_DISCRETES_OVW",
      "name": "TEST_BACKPLANE_DISCRETES_OVW",
      "type": "reg",
      "addr": 3236167868,
      "offset": 188,
      "doc": "Test only Backplane Discretes Overwrite\nDO NOT USE IN FLIGHT. This is to facilitate EMEM standalone testing. This register allows overwriting Backplane Discretes signals so that EMEM can be tested standalone, without needing EIO board for example.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "cfg_key",
          "access": "rw",
          "reset": 0,
          "doc": "Reset Control Key = 0xC\nWrites will only take effect if this field is set to the specified value."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "enable_ovw",
          "access": "rw",
          "reset": 0,
          "doc": "Write 1 to enable backplane discretes overwrite.\nWrite 0 to disable overwrite (design will use the actual backplane discretes inputs again)."
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "bp_ece_emem_crcc_spr",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 2,
          "lsb": 24,
          "name": "bp_ece_emem_bdsc_spr",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 3,
          "lsb": 21,
          "name": "bp_ece_emem_spr",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 5,
          "lsb": 16,
          "name": "bp_ece_eio_emem_spr",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "ecc_enable",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "fsw2_write_protect",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fsw1_write_protect",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "fsw0_write_protect",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "nand_write_protect",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "unprime",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "flight_testmode",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "ground_testmode",
          "access": "rw",
          "reset": 0,
          "doc": "Writing a value will overwrite corresponding backplane signal with this value."
        }
      ]
    },
    "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_4": {
      "id": "emem.EMEM_APB.APB_SYST.rblk_apb_syst_rsvd_4",
      "name": "rblk_apb_syst_rsvd_4",
      "type": "mem",
      "addr": 3236167872,
      "offset": 192,
      "doc": ""
    },
    "emem.EMEM_APB.APB_EMEMP_FFB": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB",
      "name": "APB_EMEMP_FFB",
      "type": "blk",
      "addr": 3236167936,
      "offset": 256,
      "doc": "EMEMP Bridge registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ID_REV",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR1",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR2",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR3",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_SCRPD",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER1",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER2",
        "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER3",
        "emem.EMEM_APB.APB_EMEMP_FFB.rblk_apb_ememp_ffb_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ID_REV": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ID_REV",
      "name": "EMEMP_FFB_ID_REV",
      "type": "reg",
      "addr": 3236167936,
      "offset": 0,
      "doc": "FFB ID/Revision Register\nThis register reports EMEMP or EMEMN FFB bridge status. There is a single register type, described below, and 2 instances of it, one in EMEMP and one in EMEMN.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "Id",
          "access": "ro",
          "reset": 49147,
          "doc": "Indicates the ID and revision of this FFB module"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "major",
          "access": "ro",
          "reset": 1,
          "doc": "Major revision"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "minor",
          "access": "ro",
          "reset": 1,
          "doc": "Minor reivision"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR1": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR1",
      "name": "EMEMP_FFB_ESCR1",
      "type": "reg",
      "addr": 3236167940,
      "offset": 4,
      "doc": "FFB Error Status Control Register 1",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "cmd",
          "access": "rw",
          "reset": 0,
          "doc": "On write:\n0xC0 – clear cmd_perr\n0xC1 – clear data_perr\n0xC2 – clear rd_rsp_tmout\n0xC3 – clear unexp_rd_rsp\n0xC4 – clear rx_ovfl\n0xC5 – clear fc_ovfl\n0xC6 – clear tx_blkd\n0xC7 – clear mlfd_pkt\n0xC8 – clear sync_in_active\n0xC9 – clear response cmd fifo parity error\n0xCA – clear response data fifo parity error\n0xCB – clear tx cmd fifo parity error\n0xCC – clear tx data fifo parity error\n0xCD – clear rx cmd fifo parity error\n0xCE – clear rx data fifo parity error\n0xCF – reset resync counter \nOn read: last written value"
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "resync_cnt_ovfl",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a resync counter overflow is detected"
        },
        {
          "nbits": 4,
          "lsb": 15,
          "name": "resync_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Counter of resync events that have occurred since last reset"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "rsp_cmd_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in response command fifo"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "rsp_data_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in response data fifo"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "tx_cmd_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in transmit command fifo"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "tx_data_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in transmit data fifo"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "rx_cmd_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in receive command fifo"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "rx_data_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in receive data fifo"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "sync_in_active",
          "access": "ro",
          "reset": 0,
          "doc": "A sync was received while in active state."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "mlfd_pkt",
          "access": "ro",
          "reset": 0,
          "doc": "A malformed packet was received."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "tx_blkd",
          "access": "ro",
          "reset": 0,
          "doc": "Transmit timeout has occurred due to lack of credit (10ms timeout)."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fc_ovfl",
          "access": "ro",
          "reset": 0,
          "doc": "A flow-control credit overflow has occurred, i.e. received more credit than initially negotiated."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "rx_ovfl",
          "access": "ro",
          "reset": 0,
          "doc": "The other FFB used more credits than was made available (read command or write command/data)."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "unexp_rd_rsp",
          "access": "ro",
          "reset": 0,
          "doc": "An unexpected read response was received (no read request in flight)"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rd_rsp_tmout",
          "access": "ro",
          "reset": 0,
          "doc": "A read completion timeout has occurred"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "data_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected on a data word"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "cmd_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected on a cmd word"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR2": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR2",
      "name": "EMEMP_FFB_ESCR2",
      "type": "reg",
      "addr": 3236167944,
      "offset": 8,
      "doc": "FFB Error Status Control Register 2",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "cmd",
          "access": "rw",
          "reset": 0,
          "doc": "On write:\n0xE0/0xC0 – set/clear perr_dis\n0xE2/0xC2 – set/clear rd_rsp_tmout_dis\n0xE3/0xC3 – set/clear unexp_rd_rsp_dis\n0xE4/0xC4– set/clear rx_ovfl_dis\n0xE5/0xC5 – set/clear fc_ovfl_dis\n0xE6/0xC6 – set/clear tx_blkd_dis\n0xE7/0xC7 – set/clear mlfd_pkt_dis\nOn read: last written value"
        },
        {
          "nbits": 16,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "mlfd_pkt_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to mlfd_pkt (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "tx_blkd_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to tx_blkd (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fc_ovfl_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to fc_ovfl (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "rx_ovfl_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to rx_ovfl (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "unexp_rd_rsp_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to unexp_rd_rsp_dis (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rd_rsp_tmout_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to rd_rsp_tmout (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "perr_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable parity checking."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR3": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_ESCR3",
      "name": "EMEMP_FFB_ESCR3",
      "type": "reg",
      "addr": 3236167948,
      "offset": 12,
      "doc": "FFB Error Status Control Register 3",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "cmd",
          "access": "rw",
          "reset": 0,
          "doc": "On write:\n0x77 – unlock test mode (locked by default)\n0x33 – lock test mode\n0x73 – when test mode is unlocked, force resync\n0x7C – when test mode is unlocked, inject a sync packet to RX module\n0x7D – Inject Parity Error\n0x7B – Inject Transmit blocked\n0x7E – Inject read response timeout\nOn read: last written value"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "0 – test mode disabled; 1 – test mode enabled"
        },
        {
          "nbits": 7,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "tx_sync_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of sync packets transmitted since reset, saturates to 0xF"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "rx_sync_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of sync packets received since reset, saturates to 0xF"
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "tx_perr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of parity errors transmitted since reset, saturates to 0xF"
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "rx_perr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of parity errors observed since reset, saturates to 0xF"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_SCRPD": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_SCRPD",
      "name": "EMEMP_FFB_SCRPD",
      "type": "reg",
      "addr": 3236167952,
      "offset": 16,
      "doc": "32-bit unsigned integer",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "value",
          "access": "rw",
          "reset": 0,
          "doc": "A value between 0 and 232-1"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER1": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER1",
      "name": "EMEMP_FFB_FPER1",
      "type": "reg",
      "addr": 3236167956,
      "offset": 20,
      "doc": "FFB Fifo Parity Error Register 1",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "fifo_perr_src",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the FIFO that had the parity error associated with the data in FFB_FPER1-FFB_FPER3 \n0x1 – rx cmd fifo saw a parity error\n0x2 – rx data fifo saw a parity error\n0x3 – tx cmd fifo saw a parity error\n0x4 – tx data fifo saw a parity error\n0x5 – rsp cmd fifo saw a parity error\n0x6 – rsp data fifo saw a parity error"
        },
        {
          "nbits": 11,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "cmd_fifo_err",
          "access": "ro",
          "reset": 0,
          "doc": "Error bit from last good cmd fifo"
        },
        {
          "nbits": 2,
          "lsb": 14,
          "name": "cmd_fifo_src",
          "access": "ro",
          "reset": 0,
          "doc": "Source from last good cmd fifo"
        },
        {
          "nbits": 2,
          "lsb": 12,
          "name": "cmd_fifo_dest",
          "access": "ro",
          "reset": 0,
          "doc": "Destination from last good cmd fifo"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "cmd_fifo_tag",
          "access": "ro",
          "reset": 0,
          "doc": "Tag from last good cmd fifo"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "cmd_fifo_wd_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Word count from last good cmd fifo"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER2": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER2",
      "name": "EMEMP_FFB_FPER2",
      "type": "reg",
      "addr": 3236167960,
      "offset": 24,
      "doc": "FFB Fifo Parity Error Register 2",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "cmd_fifo_data",
          "access": "ro",
          "reset": 0,
          "doc": "Data from last good cmd fifo"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER3": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.EMEMP_FFB_FPER3",
      "name": "EMEMP_FFB_FPER3",
      "type": "reg",
      "addr": 3236167964,
      "offset": 28,
      "doc": "FFB Fifo Parity Error Register 3",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "data_fifo_data",
          "access": "ro",
          "reset": 0,
          "doc": "Data from last good data fifo"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMP_FFB.rblk_apb_ememp_ffb_rsvd_0": {
      "id": "emem.EMEM_APB.APB_EMEMP_FFB.rblk_apb_ememp_ffb_rsvd_0",
      "name": "rblk_apb_ememp_ffb_rsvd_0",
      "type": "mem",
      "addr": 3236167968,
      "offset": 32,
      "doc": "Reserved register space"
    },
    "emem.EMEM_APB.APB_NAND_DMA": {
      "id": "emem.EMEM_APB.APB_NAND_DMA",
      "name": "APB_NAND_DMA",
      "type": "blk",
      "addr": 3236175872,
      "offset": 8192,
      "doc": "EMEMP NAND_DMA registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_NAND_DMA.NAND_POWER",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_POWER_MON_OVERRIDE",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_ENA",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CFG",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CB_CNT",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CB_CURR_ADDR",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_SB_CURR_ADDR",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_EB_CURR_ADDR",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_SID",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_TMO_INFO",
        "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_LAST_CBL_W0",
        "emem.EMEM_APB.APB_NAND_DMA.rblk_apb_nand_dma_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_POWER": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_POWER",
      "name": "NAND_POWER",
      "type": "reg",
      "addr": 3236175872,
      "offset": 0,
      "doc": "NAND devices Power\nThis register is the power enable for external NAND devices and power monitor the same devices.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "pwr_on_overridden",
          "access": "ro",
          "reset": 0,
          "doc": "HIGH when NAND_POWER_MON_OVERRIDE has successfully requested a NAND power override.\nNote: if the NAND_DMA was busy when register NAND_POWER_MON_OVERRIDE was written then a delay will be observed before field pwr_on_overridden is set to 1 (the FPGA will wait until NAND_DMA is not busy anymore to update the override state so as to not risk turning off power during NAND activity)."
        },
        {
          "nbits": 24,
          "lsb": 7,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "nand_b_ext_power_good",
          "access": "ro",
          "reset": 0,
          "doc": "This bit asserts when the external circuit detects that NAND-B array power domain is on. This is for information only. FSW only has to read nand_*_power_good fields to get NAND power status."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "nand_b_power_good",
          "access": "ro",
          "reset": 0,
          "doc": "This bit asserts when both external circuit detects that NAND-B array power domain is on AND the FPGA internal logic has completed the power-up sequence for the NAND device."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "nand_b_power_enable",
          "access": "rw",
          "reset": 0,
          "doc": "Write to this bit to turn on the NAND  B array power domain.  This will only take effect when NAND controller is idle to prevent accidental power down while erasing/programming."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "nand_a_ext_power_good",
          "access": "ro",
          "reset": 0,
          "doc": "This bit asserts when the external circuit detects that NAND-A array power domain is on. This is for information only. FSW only has to read nand_*_power_good fields to get NAND power status."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nand_a_power_good",
          "access": "ro",
          "reset": 0,
          "doc": "This bit asserts when both external circuit detects that NAND-A array power domain is on AND the FPGA internal logic has completed the power-up sequence for the NAND device."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nand_a_power_enable",
          "access": "rw",
          "reset": 0,
          "doc": "Write to this bit to turn on the NAND  A array power domain. This will only take effect when NAND controller is idle to prevent accidental power down while erasing/programming."
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_POWER_MON_OVERRIDE": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_POWER_MON_OVERRIDE",
      "name": "NAND_POWER_MON_OVERRIDE",
      "type": "reg",
      "addr": 3236175876,
      "offset": 4,
      "doc": "NAND devices Power Monitor Overrride\nThis register is to be used only if the NAND power monitor circuitry is suspected to malfunction. In that case we can force the design to bypass the NAND power monitor circuit and still allow NAND activity regardless of the NAND power monitor reading.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "cfg_key",
          "access": "rw",
          "reset": 0,
          "doc": "Reset Control Key = 0xC\nWrites will only take effect if this field is set to the specified value."
        },
        {
          "nbits": 4,
          "lsb": 24,
          "name": "pwr_on_override",
          "access": "rw",
          "reset": 0,
          "doc": "If set to 0xA, will override power good (i.e. when set to 0xA, NAND activity and NAND-DMA execution will be allowed even if NAND power down is detected). Value of 0x0 is recommended for normal operation. Value of 0xA should only be used in the very rare case the power good circuitry is not functioning.\nNote: internally to the FPGA, override will only change state once NAND_DMA has returned to idle (to prevent power changes during NAND activity).\nTo confirm the internal override state has changed, FSW should read NAND_POWER. pwr_on_overridden field each time NAND_POWER_ON_OVERRIDE is being written."
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_ENA": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_ENA",
      "name": "NAND_DMA_ENA",
      "type": "reg",
      "addr": 3236175880,
      "offset": 8,
      "doc": "NAND DMA Enable\nThis register is used to start, monitor, and stop the execution of the NAND DMA.  Other registers set the various configuration options for the DMA such as address, length etc.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "go",
          "access": "rw",
          "reset": 0,
          "doc": "FSW sets this bit to begin execution.  Action of writing 1 on this field will cause execution to begin (= it does not matter if this bit is still 1 after execution complete. A new execution will only be triggered by FSW actively writing again to this field).\nFSW must first verify that busy bit is not set (setting go high while busy is still high will be ignored by HW)"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "busy",
          "access": "ro",
          "reset": 0,
          "doc": "HW sets this bit when executing CBs.  \nHW clears this bit at all other times."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "ffb_bridge_ok",
          "access": "ro",
          "reset": 0,
          "doc": "When high, notifies that FFB bridge is sync’d and able to support NAND_DMA activity. No NAND_DMA should be attempted if this bit is low (it would fail with fail_id=0x8)."
        },
        {
          "nbits": 12,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "nand_status_err",
          "access": "ro",
          "reset": 0,
          "doc": "1 = some NAND device returned FAIL status – reported after program or erase operations only. The program or erase operation associated with this status fail was fully executed by the NAND_DMA, NAND_DMA_ENA.complete will still get set,  but the NAND operation did not complete for one or more NAND devices). This is the main mechanism for new NAND device bad block detection. NAND_DMA Status Block information must be analyzed to know which NAND device/block number returned this status and if confirmed the new bad block must be added to the manufacturer bad bock list."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "sbeb_bram_par_err",
          "access": "ro",
          "reset": 0,
          "doc": "1 = parity error was detected in internal BRAMs temporarily holding NAND_DMA Status/Error Blocks due to radiation (or parity error on BRAM  holding SB/EB from SRAM_DMA embedded in NAND_DMA, or parity error on nand_rfifo or nand_wfifo temporary FIFOs where SB/EB also go through). Some words in Status Blocks / Error Blocks might not be trustworthy (no other NAND_DMA action is taken in this case, only this flag will be set). This field is cleared automatically by HW upon starting a new CB list."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "nand_dma_n_failed_first",
          "access": "ro",
          "reset": 0,
          "doc": "When high indicates that the EMEMN part of the NAND_DMA (=NAND_DMA_N) failed first. This is only useful in the rare cases when EMEMN NAND_DMA failed first but was not able to send the Status Block back to EMEMP. In that case nand_dma*_fail_id will both show 0x0 but this bit will confirm that EMEMN failed. For information only."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "sgl_gr_dmr_tmo",
          "access": "ro",
          "reset": 0,
          "doc": "When high, notifies user that at least one CB executed a NAND READ with DMR in the single-sided mode (DMR single read post watchdog timeout mode) because one NAND group suffered watchdog timeout error. NAND read data was recovered using the other group. But matching SB/EB should be read for more details about which NAND device got watchdog timeout (as this is potentially serious NAND device damage)"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "data_uerr",
          "access": "ro",
          "reset": 0,
          "doc": "When high, notifies user that an uncorrectable data error has happened during the course of the NAND_DMA execution. This is a very important flag. WHEN NON-ZERO, data read or programmed contains errors. This could be due to:\nEMEMN reported uncorrectable error(s) : DMR miscompare with no DBE,  DMR simultaneous DBE, DMR DBE in single  group mode because one group suffered NAND timeout, DBE when DMR is disabled, EMEMN NAND FIFO EDAC DBE, FFB data corruption\nEMEMP reported uncorrectable error(s) : SRAM DBE, AHB error, FFB data corruption small NAND FIFO parity violation (nand_rfifo or nand_wfifo)"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "nand_dma_n_fail_id",
          "access": "ro",
          "reset": 0,
          "doc": "If NAND_DMA execution failed (reported by NAND_DMA_ENA.fail) and this was detected by NAND_DMA_N (EMEMN side of the NAND_DMA) then the reason for failure can be found here:\n0x0 = No failure\n0x1 = Reserved\n0x2 = CBL parity error \n0x3 = NAND power error (NAND power good not detected when NAND_DMA_N activity was triggered)\n0x4 = CBL header was not 0xCB\n0x5 = CBL contained illegal NAND action\n0x6 = NAND device watchdog error (one or more of the NAND lanes ready/busy line did not assert/deassert in time, this is a potentially drastic device failure)\n0x7 = one or more NAND ready/busy line was stuck busy before start of NAND_DMA_N activity\n0x8 = FFB bridge down during NAND_DMA\n0x9 = NAND controller (logic controller inside EMEMN) was already busy when DMA activity was requested."
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "fail_id",
          "access": "ro",
          "reset": 0,
          "doc": "If NAND_DMA execution failed (reported by NAND_DMA_ENA.fail) and this was detected by NAND_DMA_P (EMEMP side of the NAND_DMA) then the reason for failure can be found here (for exact cause for the failure, see Status Block List):\n0x0 = no failure\n0x1 = Number of CBs was zero\n0x2 = CBL parity error \n0x3 = NAND power error (NAND power good not detected when NAND_DMA activity was triggered)\n0x4 = CBL header was not 0xCB\n0x5 = CBL contained illegal NAND action  \n0x6 = CBL echo error (CBL echoed back from EMEMN to EMEMP contained error due to FPGA to FPGA communication issue)\n0x7 = NAND write protect violation (programming or erase was attempted while NAND was write protected)\n0x8 = FFB bridge down during NAND_DMA\n0x9 = RSVD\n0xA = NAND_DMA address boundary error (upon writing to PCI or SRAM). ARINC feature.\n0xC = Error when fetching CBL (SRAM DBE or AHB interface error)\n0xD = PCI fatal error (PCI parity error, mabort or tabort) during DMA data phase\n0xF = EMEMP NAND_DMA timeout expiration"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "cbl_cnt_zero",
          "access": "ro",
          "reset": 0,
          "doc": "The CBL count was set to 0.  No CBs were executed."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "fail",
          "access": "ro",
          "reset": 0,
          "doc": "The requested transfer did not complete (see fail_id and nand_dma_n_fail_id for details)."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "complete_with_error",
          "access": "ro",
          "reset": 0,
          "doc": "The requested transfer completed with data error(s). \nThis flag will be set if correctable OR uncorrectable data errors occurred (so this flag does not necessarily mean that data integrity is compromised for the user, depending on the nature of the data error(s) they could have been corrected by the design in which case the user will receive error-free data, but of course they could also be uncorrectable errors, in which case the user will receive erroneous data). To know if the resulting data error was correctable or not refer to field data_uerr. \nList of errors that will raise complete_with_error flag:  DMR miscompare, DBEs, SBEs, running in DMR single-sided read post TMO (sgl_gr_dmr_tmo), detecting full FFs (fully erased word) on either group, internal NAND FIFO buffer EDAC SBE or DBE error, small NAND FIFO parity error (nand_rfifo, nand_wfifo)."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "complete",
          "access": "ro",
          "reset": 0,
          "doc": "The requested transfer completed with complete data integrity (= no data error detected)."
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CFG": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CFG",
      "name": "NAND_DMA_CFG",
      "type": "reg",
      "addr": 3236175884,
      "offset": 12,
      "doc": "NAND DMA Configuration\nThis register sets the high level configurations options of the NAND DMA.",
      "fields": [
        {
          "nbits": 3,
          "lsb": 29,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "cb_parity_dis",
          "access": "rw",
          "reset": 0,
          "doc": "1 = disable parity check on Control Block Word(s)."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "dbuffer_sram_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select which SRAM to use for Temporary Data Buffer. Note: this is a temporary buffer used only when PCI is the end target. Data there will be over-written with each new CB executed.\n\n0 = SRAM 0\n1 = SRAM 1"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "ebl_sram_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select which SRAM to use for the Error Block List.\n\n0 = SRAM 0\n1 = SRAM 1"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "sbl_sram_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select which SRAM to use for the Status Block List.\n\n0 = SRAM 0\n1 = SRAM 1"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "cbl_sram_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select which SRAM to use for the Control Block List.\n\n0 = SRAM 0\n1 = SRAM 1"
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CB_CNT": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CB_CNT",
      "name": "NAND_DMA_CB_CNT",
      "type": "reg",
      "addr": 3236175888,
      "offset": 16,
      "doc": "NAND DMA Ctrl Block Count\nThis register sets the count of Control Blocks in the Control Block List for the DMA to execute.  The 13 bit count has a max value of 8191.  This is sized to correspond to the 256KiByte allocated buffer size (actual size is 8192, last location is unused).",
      "fields": [
        {
          "nbits": 19,
          "lsb": 13,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 13,
          "lsb": 0,
          "name": "cnt",
          "access": "rw",
          "reset": 0,
          "doc": "Number of Control Blocks to execute."
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CB_CURR_ADDR": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_CB_CURR_ADDR",
      "name": "NAND_DMA_CB_CURR_ADDR",
      "type": "reg",
      "addr": 3236175892,
      "offset": 20,
      "doc": "NAND DMA Ctrl Block Current Address\nThis register shows the current address of the Control Block being executed (if still executing) or last executed (if done with CBL).",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 0,
          "doc": "Address of the Control Block currently executing. \nNote: this reports only the lowest 24 bits of offset into BAR1 (so full BAR1 address will not show here)"
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_SB_CURR_ADDR": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_SB_CURR_ADDR",
      "name": "NAND_DMA_SB_CURR_ADDR",
      "type": "reg",
      "addr": 3236175896,
      "offset": 24,
      "doc": "NAND DMA Status Block Current Address\nThis register shows the current address of the Status Block being executed (if still executing) or last executed (if done with CBL).",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 0,
          "doc": "Address of the next Status Block to be updated by HW. \nNote: this reports only the lowest 24 bits of offset into BAR1 (so full BAR1 address will not show here)"
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_EB_CURR_ADDR": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_EB_CURR_ADDR",
      "name": "NAND_DMA_EB_CURR_ADDR",
      "type": "reg",
      "addr": 3236175900,
      "offset": 28,
      "doc": "NAND DMA Error Block Current Address\nThis register shows the current address of the Error Block being executed (if still executing) or last executed (if done with CBL).",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 0,
          "doc": "Address of the Error Block List currently executing. \nNote: this reports only the lowest 24 bits of offset into BAR1 (so full BAR1 address will not show here)"
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_SID": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_SID",
      "name": "NAND_DMA_SID",
      "type": "reg",
      "addr": 3236175904,
      "offset": 32,
      "doc": "NAND DMA Session ID\nThis register sets the Session ID for the Control Block List to be executed. This value will be written in the Status/Error Block list for traceability.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "sid",
          "access": "rw",
          "reset": 0,
          "doc": "FSW writes a unique value here that will be used to stamp the Status/Error BL (can be used for traceability in particular when executing CBLs several times)."
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_TMO_INFO": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_TMO_INFO",
      "name": "NAND_DMA_TMO_INFO",
      "type": "reg",
      "addr": 3236175908,
      "offset": 36,
      "doc": "NAND DMA Timeout information\nThis register gives extra information regarding the state of the design (in particular all important FSM states) when the NAND DMA execution timeout occurred.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "tmo_disable",
          "access": "rw",
          "reset": 0,
          "doc": "When HIGH disables the NAND_DMA EMEMP-side timeout feature altogether (= NAND_DMA could be stuck waiting for an event indefinitely until FPGA-wide reset)."
        },
        {
          "nbits": 19,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "ffb_user_state",
          "access": "ro",
          "reset": 0,
          "doc": "FFB user module FSM state at timeout"
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "seq_state",
          "access": "ro",
          "reset": 0,
          "doc": "Sequencer main FSM state at timeout. ."
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "ahb_state",
          "access": "ro",
          "reset": 0,
          "doc": "AHB FSM state at timeout."
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_LAST_CBL_W0": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.NAND_DMA_LAST_CBL_W0",
      "name": "NAND_DMA_LAST_CBL_W0",
      "type": "reg",
      "addr": 3236175912,
      "offset": 40,
      "doc": "NAND_DMA Last CBL Word 0 (EMEMP)\nThis register shows the very first word (WORD_0) of the last CBL read from SRAM by EMEMP.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "last_cbl_w0",
          "access": "ro",
          "reset": 0,
          "doc": "Copy of word_0 (first word) of the last CBL read by EMEMP from SRAM."
        }
      ]
    },
    "emem.EMEM_APB.APB_NAND_DMA.rblk_apb_nand_dma_rsvd_0": {
      "id": "emem.EMEM_APB.APB_NAND_DMA.rblk_apb_nand_dma_rsvd_0",
      "name": "rblk_apb_nand_dma_rsvd_0",
      "type": "mem",
      "addr": 3236175916,
      "offset": 44,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SRAM_DMA": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA",
      "name": "APB_SRAM_DMA",
      "type": "blk",
      "addr": 3236176128,
      "offset": 8448,
      "doc": "SRAM_DMA registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_ENA",
        "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CFG",
        "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CBCNT",
        "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_0",
        "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CBL_CURR_ADDR",
        "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_1",
        "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_SBL_CURR_ADDR",
        "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_2",
        "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_3",
        "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_4"
      ]
    },
    "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_ENA": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_ENA",
      "name": "SRAM_DMA_ENA",
      "type": "reg",
      "addr": 3236176128,
      "offset": 0,
      "doc": "SRAM DMA Enable\nThis register is used to start, monitor, and stop the execution of the SRAM DMA. Other registers set the various configuration options for the DMA such as address, length, error handling options, etc.",
      "fields": [
        {
          "nbits": 27,
          "lsb": 5,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "cbl_zero_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "The CBL count was set to 0.  No CBs were executed."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "stopped",
          "access": "ro",
          "reset": 0,
          "doc": "HW sets this bit when the Go bit was cleared by FSW during execution of the CB list.  \n\nHW clears this bit when the Go bit is set and execution begins."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "done",
          "access": "ro",
          "reset": 0,
          "doc": "HW sets this bit when execution stops.  \n\nHW clears this bit when the Go bit is set and execution begins."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "busy",
          "access": "ro",
          "reset": 0,
          "doc": "HW sets this bit when executing CBs.  \nHW clears this bit at all other times."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "go",
          "access": "rw",
          "reset": 0,
          "doc": "FSW sets this bit to begin execution.  \n\nHW clears this bit when execution stops, either due to completion of the CB List or if execution stops due to an error.  \n\nFSW can clear this bit during execution to gracefully pause the CB List at the end of the current CB."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CFG": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CFG",
      "name": "SRAM_DMA_CFG",
      "type": "reg",
      "addr": 3236176132,
      "offset": 4,
      "doc": "SRAM DMA Configuration\nThis register sets the high level configurations options of the SRAM DMA.",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "sbl_sram_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select which SRAM to use for the Status Block List.\n\n0 = SRAM 0 (default)\n1 = SRAM 1"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "cbl_sram_sel",
          "access": "rw",
          "reset": 0,
          "doc": "Select which SRAM to use for the Control Block List.\n\n0 = SRAM 0 (default)\n1 = SRAM 1"
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CBCNT": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CBCNT",
      "name": "SRAM_DMA_CBCNT",
      "type": "reg",
      "addr": 3236176136,
      "offset": 8,
      "doc": "SRAM DMA Control Block List Count\nThis register sets the count of Control Blocks in the Control Block List for the DMA to execute. The 8 bit count has a max value of 255.",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "count",
          "access": "rw",
          "reset": 0,
          "doc": "Number of Control Blocks to execute. Valid range is from 1-255 Control Blocks."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_0": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_0",
      "name": "rblk_apb_sram_dma_rsvd_0",
      "type": "mem",
      "addr": 3236176140,
      "offset": 12,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CBL_CURR_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_CBL_CURR_ADDR",
      "name": "SRAM_DMA_CBL_CURR_ADDR",
      "type": "reg",
      "addr": 3236176144,
      "offset": 16,
      "doc": "SRAM DMA Control Block List Current Address\nThis register shows the current address of the Control Block being executed.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 4194304,
          "doc": "Address of the Control Block currently executing. While stopped, this gives the value of the control block that is next to be fetched. When DMA execution over, this register will reset to 0s again."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_1": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_1",
      "name": "rblk_apb_sram_dma_rsvd_1",
      "type": "mem",
      "addr": 3236176148,
      "offset": 20,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_SBL_CURR_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.SRAM_DMA_SBL_CURR_ADDR",
      "name": "SRAM_DMA_SBL_CURR_ADDR",
      "type": "reg",
      "addr": 3236176152,
      "offset": 24,
      "doc": "SRAM DMA Status Block List Current Address\nThis register shows the address of the next Status Block to be updated by HW.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 24,
          "lsb": 0,
          "name": "address",
          "access": "ro",
          "reset": 4456448,
          "doc": "Address of the next Status Block to be updated by HW. While stopped, this gives the address of the next status block to be written. When execution is over, this register will reset to 0s again."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_2": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_2",
      "name": "rblk_apb_sram_dma_rsvd_2",
      "type": "mem",
      "addr": 3236176156,
      "offset": 28,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_3": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_3",
      "name": "rblk_apb_sram_dma_rsvd_3",
      "type": "mem",
      "addr": 3236176160,
      "offset": 32,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_4": {
      "id": "emem.EMEM_APB.APB_SRAM_DMA.rblk_apb_sram_dma_rsvd_4",
      "name": "rblk_apb_sram_dma_rsvd_4",
      "type": "mem",
      "addr": 3236176164,
      "offset": 36,
      "doc": ""
    },
    "emem.EMEM_APB.APB_SRAM": {
      "id": "emem.EMEM_APB.APB_SRAM",
      "name": "APB_SRAM",
      "type": "blk",
      "addr": 3236176384,
      "offset": 8704,
      "doc": "SRAM registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR",
        "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR",
        "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR_FIRST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR_LAST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR_FIRST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR_LAST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR",
        "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR",
        "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR_FIRST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR_LAST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR_FIRST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR_LAST_ADDR",
        "emem.EMEM_APB.APB_SRAM.SRAM_SCRATCH",
        "emem.EMEM_APB.APB_SRAM.rblk_apb_sram_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR",
      "name": "SRAM_0_ECC_UERR",
      "type": "reg",
      "addr": 3236176384,
      "offset": 0,
      "doc": "SRAM_0 ECC Uncorrectable Error Status & Count\nThis register shows the uncorrectable error count.",
      "fields": [
        {
          "nbits": 15,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "uerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one uncorrectable error on SRAM_0 since last cleared (by ECC_CONTROL)."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "SRAM_0 uncorrectable/DBE error count.  This count increments by 1 every time an uncorrectable error is detected during SRAM_0 read (requires both ECC global enable and fine SRAM ECC enable from ECC_CONTROL.sram_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\n\nThis counter does not wrap around and will saturate to 0xFFFF after 65,535 errors are detected.\n\nNote: Because PCI BAR for SRAM is prefetchable PCI will always read a multiple of 16-Dwords regardless of number of words were requested by PCI initiator. This can result in extra SRAM errors being reported in those registers (especially if the tail end of the 16 Dword burst reads uninitialized SRAM words)."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR",
      "name": "SRAM_0_ECC_CERR",
      "type": "reg",
      "addr": 3236176388,
      "offset": 4,
      "doc": "SRAM_0 ECC Correctable Error Status & Count\nThis register shows the uncorrectable error count.",
      "fields": [
        {
          "nbits": 15,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "cerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one correctable error on SRAM_0 since last cleared (cleared by ECC_CONTROL or disabling ECC/SRAM ECC)."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "SRAM_0 correctable/SBE error count.  This count increments by 1 every time an correctable error is detected during SRAM_0 read (requires both ECC global enable and fine SRAM ECC enable from ECC_CONTROL.sram_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\n\nThis counter does not wrap around and will saturate to 0xFFFF after 65,535 errors are detected.\n\nNote: Because PCI BAR for SRAM is prefetchable PCI will always read a multiple of 16-Dwords regardless of number of words were requested by PCI initiator. This can result in extra SRAM errors being reported in those registers (especially if the tail end of the 16 Dword burst reads uninitialized SRAM words)."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR_FIRST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR_FIRST_ADDR",
      "name": "SRAM_0_ECC_UERR_FIRST_ADDR",
      "type": "reg",
      "addr": 3236176392,
      "offset": 8,
      "doc": "First Address for SRAM Uncorrectable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "first_uerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the first SRAM_0 uncorrectable error (cleared by ECC_CONTROL or disabling ECC/SRAM ECC).\n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR_LAST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_UERR_LAST_ADDR",
      "name": "SRAM_0_ECC_UERR_LAST_ADDR",
      "type": "reg",
      "addr": 3236176396,
      "offset": 12,
      "doc": "Last Address for SRAM Uncorrectable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "last_uerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the last SRAM_0 uncorrectable error(cleared by ECC_CONTROL or disabling ECC/SRAM ECC).  \n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR_FIRST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR_FIRST_ADDR",
      "name": "SRAM_0_ECC_CERR_FIRST_ADDR",
      "type": "reg",
      "addr": 3236176400,
      "offset": 16,
      "doc": "First Address for SRAM Correctable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "first_cerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the first SRAM_0 correctable error(cleared by ECC_CONTROL or disabling ECC/SRAM ECC). \n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR_LAST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_0_ECC_CERR_LAST_ADDR",
      "name": "SRAM_0_ECC_CERR_LAST_ADDR",
      "type": "reg",
      "addr": 3236176404,
      "offset": 20,
      "doc": "Last Address for SRAM Correctable Error\nThis register shows the address of the first uncorrectable error.\n\n\n\n\n\n\nThe following registers are for SRAM 1 ECC / EDAC information reporting.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "last_cerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the last SRAM_0 correctable error(cleared by ECC_CONTROL or disabling ECC/SRAM ECC).  \n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR",
      "name": "SRAM_1_ECC_UERR",
      "type": "reg",
      "addr": 3236176408,
      "offset": 24,
      "doc": "SRAM_1 ECC Uncorrectable Error Status &  Count\nThis register shows the uncorrectable error count.",
      "fields": [
        {
          "nbits": 15,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "uerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one uncorrectable error on SRAM_1 since last cleared (by ECC_CONTROL or disabling ECC/SRAM ECC)."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "SRAM_1 uncorrectable/DBE error count.  This count increments by 1 every time an uncorrectable error is detected during SRAM_1 read (requires both ECC global enable and fine SRAM ECC enable from ECC_CONTROL.sram_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\n\nThis counter does not wrap around and will saturate to 0xFFFF after 65,535 errors are detected.\n\nNote: Because PCI BAR for SRAM is prefetchable PCI will always read a multiple of 16-Dwords regardless of number of words were requested by PCI initiator. This can result in extra SRAM errors being reported in those registers (especially if the tail end of the 16 Dword burst reads uninitialized SRAM words)."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR",
      "name": "SRAM_1_ECC_CERR",
      "type": "reg",
      "addr": 3236176412,
      "offset": 28,
      "doc": "SRAM_1 ECC Correctable Error Status & Count\nThis register shows the uncorrectable error count.",
      "fields": [
        {
          "nbits": 15,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "cerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one uncorrectable error on SRAM_1 since last cleared (cleared by ECC_CONTROL or disabling ECC/SRAM ECC)."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "SRAM_1 correctable/SBE error count.  This count increments by 1 every time an correctable error is detected during SRAM_1 read (requires both ECC global enable and fine SRAM ECC enable from ECC_CONTROL.sram_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\n\nThis counter does not wrap around and will saturate to 0xFFFF after 65,535 errors are detected.\n\nNote: Because PCI BAR for SRAM is prefetchable PCI will always read a multiple of 16-Dwords regardless of number of words were requested by PCI initiator. This can result in extra SRAM errors being reported in those registers (especially if the tail end of the 16 Dword burst reads uninitialized SRAM words)."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR_FIRST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR_FIRST_ADDR",
      "name": "SRAM_1_ECC_UERR_FIRST_ADDR",
      "type": "reg",
      "addr": 3236176416,
      "offset": 32,
      "doc": "First Address for SRAM Uncorrectable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "first_uerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the first SRAM_1 uncorrectable error (cleared by ECC_CONTROL or disabling ECC/SRAM ECC). \n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR_LAST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_UERR_LAST_ADDR",
      "name": "SRAM_1_ECC_UERR_LAST_ADDR",
      "type": "reg",
      "addr": 3236176420,
      "offset": 36,
      "doc": "Last Address for SRAM Uncorrectable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "last_uerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the last SRAM_1 uncorrectable error (cleared by ECC_CONTROL or disabling ECC/SRAM ECC).  \n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR_FIRST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR_FIRST_ADDR",
      "name": "SRAM_1_ECC_CERR_FIRST_ADDR",
      "type": "reg",
      "addr": 3236176424,
      "offset": 40,
      "doc": "First Address for SRAM Correctable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "first_cerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the first SRAM_1 correctable error (cleared by ECC_CONTROL or disabling ECC/SRAM ECC).  \n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR_LAST_ADDR": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_1_ECC_CERR_LAST_ADDR",
      "name": "SRAM_1_ECC_CERR_LAST_ADDR",
      "type": "reg",
      "addr": 3236176428,
      "offset": 44,
      "doc": "Last Address for SRAM Correctable Error\nThis register shows the address of the first uncorrectable error.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 21,
          "lsb": 2,
          "name": "last_cerr_address",
          "access": "ro",
          "reset": 0,
          "doc": "This is the address of the last SRAM_1 correctable error (cleared by ECC_CONTROL or disabling ECC/SRAM ECC).\n\nThis is the raw SRAM offset address (= uses 32-bit word addressing and does not include SRAM PCI BAR  address)"
        },
        {
          "nbits": 2,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.SRAM_SCRATCH": {
      "id": "emem.EMEM_APB.APB_SRAM.SRAM_SCRATCH",
      "name": "SRAM_SCRATCH",
      "type": "reg",
      "addr": 3236176432,
      "offset": 48,
      "doc": "scratch register\nDebug scratch bit. No other functionality than register access debug.",
      "fields": [
        {
          "nbits": 31,
          "lsb": 1,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "scratch_bit",
          "access": "rw",
          "reset": 0,
          "doc": "No use. This RW bit is not attached to any functionality."
        }
      ]
    },
    "emem.EMEM_APB.APB_SRAM.rblk_apb_sram_rsvd_0": {
      "id": "emem.EMEM_APB.APB_SRAM.rblk_apb_sram_rsvd_0",
      "name": "rblk_apb_sram_rsvd_0",
      "type": "mem",
      "addr": 3236176436,
      "offset": 52,
      "doc": ""
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC",
      "name": "APB_MRAM_NVCRC",
      "type": "blk",
      "addr": 3236176640,
      "offset": 8960,
      "doc": "MRAM & NVCRC registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_0_ECC_ERR_DET",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_1_ECC_ERR_DET",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_2_ECC_ERR_DET",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_ECC_ERR_CNT",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_FIRST_ERR_ADDR",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_LAST_ERR_ADDR",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_CTRL_ERR",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_WP",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_CTRL_MISC_CFG",
        "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_FIRST_WP_ERR_ADDR",
        "emem.EMEM_APB.APB_MRAM_NVCRC.rblk_apb_mram_nvcrc_rsvd_0",
        "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_CTRL",
        "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_LOAD_STAT",
        "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_STAT",
        "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_STAT",
        "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_LAST_FRAME",
        "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_FRAME_COUNTER",
        "emem.EMEM_APB.APB_MRAM_NVCRC.rblk_apb_mram_nvcrc_rsvd_1"
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_0_ECC_ERR_DET": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_0_ECC_ERR_DET",
      "name": "MRAM_BUS_0_ECC_ERR_DET",
      "type": "reg",
      "addr": 3236176640,
      "offset": 0,
      "doc": "MRAM BUS_0 ECC Error Detect Flags\nThis register shows if any ECC error were detected and corrected by the MRAM bus 0 devices. EMEM_L6_613977",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "mram_bus0_2_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 0, device #2.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "mram_bus0_1_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 0, device #1.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "mram_bus0_0_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 0, device #0.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_1_ECC_ERR_DET": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_1_ECC_ERR_DET",
      "name": "MRAM_BUS_1_ECC_ERR_DET",
      "type": "reg",
      "addr": 3236176644,
      "offset": 4,
      "doc": "MRAM BUS_1 ECC Error Detect Flags\nThis register shows if any ECC error were detected and corrected by the MRAM bus 1 devices. EMEM_L6_613977",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "mram_bus1_2_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 1, device #2.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "mram_bus1_1_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 1, device #1.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "mram_bus1_0_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 1, device #0.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_2_ECC_ERR_DET": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_BUS_2_ECC_ERR_DET",
      "name": "MRAM_BUS_2_ECC_ERR_DET",
      "type": "reg",
      "addr": 3236176648,
      "offset": 8,
      "doc": "MRAM BUS_2 ECC Error Detect Flags\nThis register shows if any ECC error were detected and corrected by the MRAM bus 2 devices. EMEM_L6_613977",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "mram_bus2_2_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 2, device #2.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "mram_bus2_1_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 2, device #1.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "mram_bus2_0_err_det",
          "access": "ro",
          "reset": 0,
          "doc": "ECC error detected and corrected by MRAM bus 2, device #0.\nBit0 high = stack die 0 indicated & corrected error\nBit1 high = stack die 1 indicated & corrected error\nBit2 high = stack die 2 indicated & corrected error\nBit3 high = stack die 3 indicated & corrected error\nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_ECC_ERR_CNT": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_ECC_ERR_CNT",
      "name": "MRAM_ECC_ERR_CNT",
      "type": "reg",
      "addr": 3236176652,
      "offset": 12,
      "doc": "MRAM ECC Error Counters\nThis register shows the current count of ECC error detected and corrected by any of the MRAM devices. EMEM_L6_613977",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "mram_persist_err_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of persistent errors corrected by MRAM devices. \nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr.  \nNote: if MRAM_CTRL_MISC_CFG. mram_double_read_ena is low then mram_persist_err_cnt field will not be incremented and will show 0 (since we don’t know the error type in this mode, only mram_total_err_cnt will increment)"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "mram_total_err_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Total number of errors corrected by MRAM devices (this includes transient and persistent errors) \nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr.  \n\nNote: Because PCI BAR for MRAM is prefetchable PCI will always read a multiple of 16-Dwords regardless of number of words were requested by PCI initiator. This can result in extra MRAM errors being reported in those registers."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_FIRST_ERR_ADDR": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_FIRST_ERR_ADDR",
      "name": "MRAM_FIRST_ERR_ADDR",
      "type": "reg",
      "addr": 3236176656,
      "offset": 16,
      "doc": "MRAM First Error Address\nThis register shows the address of the first error that occurred on any MRAM device  since it was last serviced/cleared.  \nEMEM_L6_613977",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 27,
          "lsb": 0,
          "name": "mram_first_err_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Address (byte addressing) for the first error reported by any MRAM device.  This is the first error detected since last cleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_LAST_ERR_ADDR": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_LAST_ERR_ADDR",
      "name": "MRAM_LAST_ERR_ADDR",
      "type": "reg",
      "addr": 3236176660,
      "offset": 20,
      "doc": "MRAM Last Error Address\nThis register shows the address of the last/most recent error that occurred on any MRAM device.\nEMEM_L6_613977",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 27,
          "lsb": 0,
          "name": "mram_last_err_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Address (byte addressing) for the last/most recent error reported by any MRAM device.  \nCleared by writing to EMEM_CONTROL field mram_ecc_err_clr."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_CTRL_ERR": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_CTRL_ERR",
      "name": "MRAM_CTRL_ERR",
      "type": "reg",
      "addr": 3236176664,
      "offset": 24,
      "doc": "MRAM Controller Error\nThis register shows MRAM controller errors that happened since last time the register was cleared.  Those do not cover MRAM data error or TMR errors, only access errors detected by the controller resulting from illegal AHB transfers.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "mram_ctrl_err_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write to clear all bits in this register as well as register MRAM_FIRST_WP_ERR_ADDR"
        },
        {
          "nbits": 22,
          "lsb": 9,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "mram_dma_fsw_wp_violation",
          "access": "ro",
          "reset": 0,
          "doc": "DMA master (actually SRAM_DMA reused as RAM_DMA) attempted a write to a protected FSW MRAM area (to unprotect FSW0/FSW1/FSW2 the appropriate BP discrete must be lifted)."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "mram_dma_nvcrc_wp_violation",
          "access": "ro",
          "reset": 0,
          "doc": "DMA master (actually SRAM_DMA reused as MRAM_DMA) attempted a write to protected NVCRC MRAM area. To unprotect NVCRC area and allow PCI access, ground test mode must be set AS WELL as unlock_nvcrc_mram."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "mram_rt1553_fsw_wp_violation",
          "access": "ro",
          "reset": 0,
          "doc": "RT_1553 master attempted a write to a protected FSW MRAM area (to unprotect FSW0/FSW1/FSW2 the appropriate BP discrete must be lifted)."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "mram_rt1553_nvcrc_wp_violation",
          "access": "ro",
          "reset": 0,
          "doc": "RT_1553 master attempted a write to protected NVCRC MRAM area. To unprotect NVCRC area and allow RT access, ground test mode must be set AS WELL as unlock_nvcrc_mram."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "mram_pci_fsw_wp_violation",
          "access": "ro",
          "reset": 0,
          "doc": "PCI master attempted a write to a protected FSW MRAM area (to unprotect FSW0/FSW1/FSW2 the appropriate BP discrete must be lifted)."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "mram_pci_nvcrc_wp_violation",
          "access": "ro",
          "reset": 0,
          "doc": "PCI master attempted a write to protected NVCRC MRAM area. To unprotect NVCRC area and allow PCI access, ground test mode must be set AS WELL as unlock_nvcrc_mram."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "mram_illegal_master_err",
          "access": "ro",
          "reset": 0,
          "doc": "A non-authorized AHB master attempted to access the MRAM (authorized masters are PCI, NVCRC and NVCRC-SPI)."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "mram_ahb_err",
          "access": "ro",
          "reset": 0,
          "doc": "An AHB transfer to address inside BAR2 but outside of MRAM address range was attempted."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_WP": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_WP",
      "name": "MRAM_WP",
      "type": "reg",
      "addr": 3236176668,
      "offset": 28,
      "doc": "MRAM write protect\nThis register is used to report the state of various write protected regions as well as to lift the NVCRC region write protect for PCI (note: ground test mode is also needed to allow PCI access to NVCRC MRAM region)",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "cfg_key",
          "access": "rw",
          "reset": 0,
          "doc": "Reset Control Key = 0xC\nWrites will only take effect if this field is set to the specified value."
        },
        {
          "nbits": 20,
          "lsb": 8,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "nvcrc_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Status of write protect for NVCRC regions of MRAM (unlock_mram_nvcrc must be high and we must be in ground test mode). \n1= write protected"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "fsw2_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Status of write protect for FSW image 2 stored in MRAMs 0 and 1. 1= write protected\nwp_emem_mram_bank0_crc31"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fsw1_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Status of write protect for FSW image 1 stored in MRAMs 0 and 1. 1= write protected\nwp_emem_mram_bank1_crc30"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "fsw0_write_protect",
          "access": "ro",
          "reset": 0,
          "doc": "Status of write protect for FSW image 0 stored in MRAMs 0 and 1. 1= write protected\nwp_emem_mram_bank0_crc24"
        },
        {
          "nbits": 3,
          "lsb": 1,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "unlock_mram_nvcrc",
          "access": "rw",
          "reset": 0,
          "doc": "1 = allows PCI access to MRAM NVCRC regions IF ground test mode is also set (BOTH unlock_mram_nvcrc and ground test mode must be set to allow PCI access)."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_CTRL_MISC_CFG": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_CTRL_MISC_CFG",
      "name": "MRAM_CTRL_MISC_CFG",
      "type": "reg",
      "addr": 3236176672,
      "offset": 32,
      "doc": "MRAM Controller Miscellaneous Configuration\nThis register is used to select miscellaneous MRAM controller configuration.",
      "fields": [
        {
          "nbits": 31,
          "lsb": 1,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "RSVD"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "mram_double_read_ena",
          "access": "rw",
          "reset": 1,
          "doc": "When set high, enables the MRAM double read upon corrected error indication.\n0 = single MRAM read\n1 = double MRAM read if MRAM reports corrected error.\nImportant: when the MRAM reports the error, it has corrected the error so setting this bit high/low does not change data read. Setting to 1 potentially allows the user to gather statistics to know if the error was a short transient error or a more permanent one. But setting to 1 lowers MRAM bandwidth during reads in an environment with numerous errors."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_FIRST_WP_ERR_ADDR": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.MRAM_FIRST_WP_ERR_ADDR",
      "name": "MRAM_FIRST_WP_ERR_ADDR",
      "type": "reg",
      "addr": 3236176676,
      "offset": 36,
      "doc": "MRAM First write protect error/violation Address\nThis register shows the address of the first write protect error/violation that occurred on any MRAM device  since it was last serviced/cleared.",
      "fields": [
        {
          "nbits": 5,
          "lsb": 27,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 27,
          "lsb": 0,
          "name": "mram_first_wp_err_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Address (byte addressing) for the first MRAM write protect error.  This is the first WP violation detected since last cleared by writing to MRAM_CTRL_ERR field mram_ctrl_err_clr."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.rblk_apb_mram_nvcrc_rsvd_0": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.rblk_apb_mram_nvcrc_rsvd_0",
      "name": "rblk_apb_mram_nvcrc_rsvd_0",
      "type": "mem",
      "addr": 3236176680,
      "offset": 40,
      "doc": "RSVD"
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_CTRL": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_CTRL",
      "name": "NVCRC_CTRL",
      "type": "reg",
      "addr": 3236176704,
      "offset": 64,
      "doc": "NVCRC Control Register\nThis register shows the status of the NVCRC load and allows FSW to initiate a refresh of all NVCRCs.",
      "fields": [
        {
          "nbits": 29,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "done",
          "access": "ro",
          "reset": 0,
          "doc": "HW sets this bit after the NVCRC load or refresh has completed.  \nHW clears this bit when the refresh, initial or SPI load is executing."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "busy",
          "access": "ro",
          "reset": 0,
          "doc": "HW sets this bit while loading or refreshing the NVCRCs.\nThis flag will show busy whenever NVCRC updates are ongoing, regardless of whether those updates were triggered by coming out of reset, SPI-commanded or FSW-controlled using NVCRC_CTRL.refresh).\nIMPORTANT: NVCRC_CTRL.busy flag must be polled / verified to be low before FSW is allowed to issue NVCRC_CTRL.refresh."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "refresh",
          "access": "rw",
          "reset": 0,
          "doc": "FSW can write 1 to this bit to cause the NVCRC logic to refresh all NVCRC values. \nIMPORTANT: NVCRC_CTRL.busy flag must be polled / verified to be low before FSW is allowed to issue NVCRC_CTRL.refresh."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_LOAD_STAT": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_LOAD_STAT",
      "name": "NVCRC_LOAD_STAT",
      "type": "reg",
      "addr": 3236176708,
      "offset": 68,
      "doc": "NVCRC Load Status\nThis register shows the load status of the NVCRCs.  The TMR voting is tracked by TMR copy. This status is cleared at the start of each NVCRC load/refresh cycle.  The data is valid when the done signal in the control register has asserted.",
      "fields": [
        {
          "nbits": 29,
          "lsb": 3,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "tmr_error_2",
          "access": "ro",
          "reset": 0,
          "doc": "A TMR voting error occurred in the 2 copy of the TMR data."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "tmr_error_1",
          "access": "ro",
          "reset": 0,
          "doc": "A TMR voting error occurred in the 1 copy of the TMR data."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "tmr_error_0",
          "access": "ro",
          "reset": 0,
          "doc": "A TMR voting error occurred in the 0 copy of the TMR data."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_STAT": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_STAT",
      "name": "NVCRC_STAT",
      "type": "reg",
      "addr": 3236176716,
      "offset": 76,
      "doc": "NVCRC Status\nThis register shows the status of the NVCRCs.  These values are valid following a load/refresh cycle once the done signal has asserted.  All values are active high (1=asserted).\nEMEM_L6_613922  EMEM_L6_613937",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nvcrc_63",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_63"
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "nvcrc_62",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_62"
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "nvcrc_61",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_61"
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "nvcrc_60",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_60 \nEnable Zombie State pid56"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "nvcrc_59",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_59. \nBDS EDAC inhibit\n0 = BDS EDAC/ECC Enabled\n1 = BDS  EDAC/ECC Disabled"
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "nvcrc_58",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_58. ECC Inhibit.\nEMEM EDAC inhibit\n0 = EMEM EDAC/ECC Enabled\n1 = EMEM  EDAC/ECC Disabled"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "nvcrc_57",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_57 \nEIO EDAC inhibit\n0 = EIO EDAC/ECC Enabled\n1 = EIO EDAC/ECC Disabled"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "nvcrc_56",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_56 \nsfc_edac_inh_crc56_pid56 \nrad 750 EDAC inhibit."
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "nvcrc_55",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_55"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "nvcrc_54",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_54"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "nvcrc_53",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_53"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "nvcrc_52",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_52"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "nvcrc_51",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_51"
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "nvcrc_50",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_50 \nGo Zombie State"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "nvcrc_49",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_49 \nFSM image 1 select\n1= MRAM FSW image 1 selected"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "nvcrc_48",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_48 \nFSM image 0 select\n1= MRAM FSW image 0 selected"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "nvcrc_47",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_47"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "nvcrc_46",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_46"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "nvcrc_45",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_45"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "nvcrc_44",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_44"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "nvcrc_43",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_43"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "nvcrc_42",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_42"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "nvcrc_41",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_41 \nTurbo long/short (0=short/1=long)"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "nvcrc_40",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_40"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "nvcrc_39",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_39 \nbist_ignore_crc39_pid57"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "nvcrc_38",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_38 \nFDU defeated. 1 = FDU defeated."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "nvcrc_37",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_37"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "nvcrc_36",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_36"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "nvcrc_35",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_35"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "nvcrc_34",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_34\nARINC inhibit. 1 = ARINC inhibited."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nvcrc_33",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_33\nUNUSED. Does not go out of FPGA, does not go out to CRCC-backplane anymore."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nvcrc_32",
          "access": "ro",
          "reset": 0,
          "doc": "Shows value of NVCRC_32.\nUNUSED. Does not go out of FPGA, does not go out to CRCC-backplane anymore."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_STAT": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_STAT",
      "name": "NVCRC_SPI_STAT",
      "type": "reg",
      "addr": 3236176720,
      "offset": 80,
      "doc": "NVCRC_SPI Status",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "clear_status",
          "access": "rw",
          "reset": 0,
          "doc": "Write to this bit to clear all of the NVSPI registers."
        },
        {
          "nbits": 25,
          "lsb": 6,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "watchdog_error",
          "access": "ro",
          "reset": 0,
          "doc": "A frame was received that exceeded the expected 32 bit SPI period time.  \nSince last cleared with clear_status field."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "frame_underflow",
          "access": "ro",
          "reset": 0,
          "doc": "A frame was received with fewer than the expected 32 bits. Since last cleared with clear_status field."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "bank_error",
          "access": "ro",
          "reset": 0,
          "doc": "A frame was received with an invalid bank field. \nSince last cleared with clear_status field."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "enable_error",
          "access": "ro",
          "reset": 0,
          "doc": "A frame was received with an invalid enable field. \nSince last cleared with clear_status field."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "data_error",
          "access": "ro",
          "reset": 0,
          "doc": "A frame was received with an invalid data field. \nSince last cleared with clear_status field."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "crc_error",
          "access": "ro",
          "reset": 0,
          "doc": "A frame was received with an invalid crc field. \nSince last cleared with clear_status field."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_LAST_FRAME": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_LAST_FRAME",
      "name": "NVCRC_SPI_LAST_FRAME",
      "type": "reg",
      "addr": 3236176724,
      "offset": 84,
      "doc": "NVCRC_SPI Last Frame\nThis register shows the value of the last NVCRC_SPI frame received.",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "bank",
          "access": "ro",
          "reset": 0,
          "doc": "Valid values are \n\n0xA4 = Bank 4\n0xB5 = Bank 5\n0xC6 = Bank 6\n0xD7 = Bank 7"
        },
        {
          "nbits": 8,
          "lsb": 16,
          "name": "enable",
          "access": "ro",
          "reset": 0,
          "doc": "1-hot bit enable.  \n\n0x01 = bit[0]\n0x02 = bit[1]\n0x04 = bit[2]\n0x08 = bit[3]\n0x10 = bit[4]\n0x20 = bit[5]\n0x40 = bit[6]\n0x80 = bit[7]"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "data",
          "access": "ro",
          "reset": 0,
          "doc": "Supports setting or clearing the NVCRC.\n\nSet = 0xAA\nClear = 0x55"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "crc",
          "access": "ro",
          "reset": 0,
          "doc": "8 bit CRC code."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_FRAME_COUNTER": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.NVCRC_SPI_FRAME_COUNTER",
      "name": "NVCRC_SPI_FRAME_COUNTER",
      "type": "reg",
      "addr": 3236176732,
      "offset": 92,
      "doc": "NVCRC_SPI Frame Counter\nThis register shows the count of NVCRC_SPI frames received.  The counters rollover and are meant for debug and not for flight operations as an absolute value.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "error_packets",
          "access": "ro",
          "reset": 0,
          "doc": "This count increments every time an invalid packet is received.  The counter rolls over and continues counting."
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "valid_packets",
          "access": "ro",
          "reset": 0,
          "doc": "This count increments every time a valid packet is received.  The counter rolls over and continues counting."
        }
      ]
    },
    "emem.EMEM_APB.APB_MRAM_NVCRC.rblk_apb_mram_nvcrc_rsvd_1": {
      "id": "emem.EMEM_APB.APB_MRAM_NVCRC.rblk_apb_mram_nvcrc_rsvd_1",
      "name": "rblk_apb_mram_nvcrc_rsvd_1",
      "type": "mem",
      "addr": 3236176736,
      "offset": 96,
      "doc": ""
    },
    "emem.EMEM_APB.blk_apb_rsvd_0": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_0",
      "name": "blk_apb_rsvd_0",
      "type": "mem",
      "addr": 3236176896,
      "offset": 9216,
      "doc": ""
    },
    "emem.EMEM_APB.blk_apb_rsvd_1": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_1",
      "name": "blk_apb_rsvd_1",
      "type": "mem",
      "addr": 3236192256,
      "offset": 24576,
      "doc": ""
    },
    "emem.EMEM_APB.APB_ETH": {
      "id": "emem.EMEM_APB.APB_ETH",
      "name": "APB_ETH",
      "type": "blk",
      "addr": 3236200448,
      "offset": 32768,
      "doc": "Ethernet registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_ETH.ETH_POWER",
        "emem.EMEM_APB.APB_ETH.ETH_INTR",
        "emem.EMEM_APB.APB_ETH.ETH_DMA_ADDR",
        "emem.EMEM_APB.APB_ETH.ETH_DMA_LEN",
        "emem.EMEM_APB.APB_ETH.ETH_DMA_CTL",
        "emem.EMEM_APB.APB_ETH.rblk_apb_eth_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_ETH.ETH_POWER": {
      "id": "emem.EMEM_APB.APB_ETH.ETH_POWER",
      "name": "ETH_POWER",
      "type": "reg",
      "addr": 3236200448,
      "offset": 0,
      "doc": "Ethernet power control and status\nThis register controls the Ethernet switched power domain.  This drives a discrete output from the FPGA to enable the onboard power switch for the Ethernet domain.  \nEMEM_L6_613991\nEMEM_L6_682702",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "pgood_se_3p3v",
          "access": "ro",
          "reset": 0,
          "doc": "High when 3.3V power for SE (Ethernet) is good"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "eth_power_ena",
          "access": "rw",
          "reset": 0,
          "doc": "Controls Ethernet power domain.\nEthernet switched power domain is turned on (se_swen signal on the board) when this bit is set AND ground testmode is also asserted.  \n\n0 = Off\n1 = ON if ground testmode also = 1"
        }
      ]
    },
    "emem.EMEM_APB.APB_ETH.ETH_INTR": {
      "id": "emem.EMEM_APB.APB_ETH.ETH_INTR",
      "name": "ETH_INTR",
      "type": "reg",
      "addr": 3236200452,
      "offset": 4,
      "doc": "Ethernet Interrupts Status Register\nThis register reflects the Ethernet interrupt status bits. Note that conditions must be cleared from this register.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "intr_key",
          "access": "rw",
          "reset": 0,
          "doc": "Set/Clear control key. \nWhen key set to 0x0: the other fields are write one to clear. \nWhen key set to 0xc: the other fields are write one to set (this mode is used only for testing purposes to generate a fake interrupt to test interrupt propagation)\nWrites to other fields will only take effect if this field is set to a valid key."
        },
        {
          "nbits": 21,
          "lsb": 7,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "eth_prog_err_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1: to enable eth_prog_err interrupt \n0: to disable eth_prog_err interrupt"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "eth_dma_done_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1: to enable eth_dma_done interrupt\n0: to disable eth_dma_done interrupt"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "eth_intr_ena",
          "access": "rw",
          "reset": 0,
          "doc": "1: to enable eth_intr interrupt (intr comes from external PHY)\n0: to disable eth_intr interrupt (intr comes from external PHY)"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "eth_prog_err",
          "access": "rw",
          "reset": 0,
          "doc": "Indicates Ethernet dma was programmed but has not been enabled for use. \neth_prog_err=1 IF Ethernet DMA was programmed but either :\nETH_POWER. eth_power_ena=0 \nor system is not in ground test mode\nor ethernet 3.3V power is not good (POWER_STATUS.pgood_se_3p3v=0)\nField will never be set if corresponding interrupt is disabled with eth_prog_err_ena =0."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "eth_dma_done",
          "access": "rw",
          "reset": 0,
          "doc": "If set indicates and Ethernet dma operation has completed.\nNote that this bit will be ‘0’ if we are not in ground test mode and/or the Ethernet 3.3V power is not good.\nField will never be set if corresponding interrupt is disabled with eth_dma_done_ena =0."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "eth_intr",
          "access": "rw",
          "reset": 0,
          "doc": "Indicates an Ethernet interrupt from the MAC/PHY device. \nNote that this bit will be ‘0’ if we are not in ground test mode and/or the Ethernet 3.3V power is not good.\nField will never be set if corresponding interrupt is disabled with eth_intr_ena =0."
        }
      ]
    },
    "emem.EMEM_APB.APB_ETH.ETH_DMA_ADDR": {
      "id": "emem.EMEM_APB.APB_ETH.ETH_DMA_ADDR",
      "name": "ETH_DMA_ADDR",
      "type": "reg",
      "addr": 3236200456,
      "offset": 8,
      "doc": "Ethernet DMA Address Register",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "eth_dma_addr",
          "access": "rw",
          "reset": 0,
          "doc": "PCI address where the ethernet DMA function will transfer from/to. This address must be dword aligned."
        }
      ]
    },
    "emem.EMEM_APB.APB_ETH.ETH_DMA_LEN": {
      "id": "emem.EMEM_APB.APB_ETH.ETH_DMA_LEN",
      "name": "ETH_DMA_LEN",
      "type": "reg",
      "addr": 3236200460,
      "offset": 12,
      "doc": "Ethernet DMA Length Register",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "eth_dma_len",
          "access": "rw",
          "reset": 0,
          "doc": "DMA length in bytes. Ethernet Tx dmas(PCI reads) are limited to max 2048B. Rx dmas(PCI writes) are limited to max 2028B.\nThe max limitation is due to the Micrel part not being able to handle a single frame being delivered or fetched in multiple segments."
        }
      ]
    },
    "emem.EMEM_APB.APB_ETH.ETH_DMA_CTL": {
      "id": "emem.EMEM_APB.APB_ETH.ETH_DMA_CTL",
      "name": "ETH_DMA_CTL",
      "type": "reg",
      "addr": 3236200464,
      "offset": 16,
      "doc": "Ethernet Control Register",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "eth_dma_start",
          "access": "RW-Write-1-to-Set",
          "reset": 0,
          "doc": "When set an Ethernet DMA operation is initiated. This bit will be cleared when the operation has completed."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "eth_dma_rw",
          "access": "rw",
          "reset": 0,
          "doc": "If set DMA is a read operation of the MAC RXQ. If clear DMA is a write operation of the MAC TXQ."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "eth_dma_term",
          "access": "RW-Write-1-to-Set",
          "reset": 0,
          "doc": "DO NOT USE. LEAVE AT 0. NOT IMPLEMENTED. Terminates an already active DMA. This bit will be cleared when the operation has completed."
        },
        {
          "nbits": 15,
          "lsb": 14,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 14,
          "lsb": 0,
          "name": "eth_dma_num_bytes",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the number of bytes transferred in the last DMA operation."
        }
      ]
    },
    "emem.EMEM_APB.APB_ETH.rblk_apb_eth_rsvd_0": {
      "id": "emem.EMEM_APB.APB_ETH.rblk_apb_eth_rsvd_0",
      "name": "rblk_apb_eth_rsvd_0",
      "type": "mem",
      "addr": 3236200468,
      "offset": 20,
      "doc": ""
    },
    "emem.EMEM_APB.blk_apb_rsvd_2": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_2",
      "name": "blk_apb_rsvd_2",
      "type": "mem",
      "addr": 3236200704,
      "offset": 33024,
      "doc": "RBLK_APB_ETH_PHY\nEthernet MAC/PHY external chip registers block (because those are external to the EMEM design we have to use the RSVD keyword but to the user this is transparent and all registers from external Ethernet chip are mapped here)"
    },
    "emem.EMEM_APB.blk_apb_rsvd_3": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_3",
      "name": "blk_apb_rsvd_3",
      "type": "mem",
      "addr": 3236208640,
      "offset": 40960,
      "doc": "UNUSED. Placeholder for RBLK_APB_STSU  if needed."
    },
    "emem.EMEM_APB.blk_apb_rsvd_4": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_4",
      "name": "blk_apb_rsvd_4",
      "type": "mem",
      "addr": 3236208896,
      "offset": 41216,
      "doc": ""
    },
    "emem.EMEM_APB.APB_EMEMN_SYST": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST",
      "name": "APB_EMEMN_SYST",
      "type": "blk",
      "addr": 3236216832,
      "offset": 49152,
      "doc": "EMEMN remote FPGA registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.",
      "children": [
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_REV",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_ID",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_SCRATCH_DEBUG",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_REPO_DATE",
        "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_0",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_CFG",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_SEL",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_SEL",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_STAT",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_CBL_INFO",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_CBL_W0",
        "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_1",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_RB",
        "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_2",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_FFB_FIFO_INFO",
        "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_3",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_READ_WCNT",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_PROG_WCNT",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_DATA_READ",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_DATA_PROG",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_EXEC_STATUS",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_ECC_UERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_ECC_UERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_ECC_CERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_ECC_CERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_DMR_UERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_DMR_CMISCOMP",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_ADDR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_ADDR_PG",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_GR_A_DATA",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_GR_B_DATA",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_ADDR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_ADDR_PG",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_RAW_DATA",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_CORRECTED_DATA",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_0_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_1_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_2_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_3_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_4_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_5_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_0_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_1_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_2_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_3_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_4_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_5_ERR",
        "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_4"
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_REV": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_REV",
      "name": "EMEMN_REV",
      "type": "reg",
      "addr": 3236216832,
      "offset": 0,
      "doc": "EMEMN Revision Number",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "maj_rev",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the major revision number of this FPGA build"
        },
        {
          "nbits": 12,
          "lsb": 12,
          "name": "min_rev",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the minor revision number of this FPGA build"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "pat_rev",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the patch revision number of this FPGA build"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_ID": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_ID",
      "name": "EMEMN_ID",
      "type": "reg",
      "addr": 3236216836,
      "offset": 4,
      "doc": "EMEMN FPGA ID",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "emem_common_id",
          "access": "ro",
          "reset": 0,
          "doc": "0xE3E3. Identifier common to both EMEM FPGAs"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "ememn_id",
          "access": "ro",
          "reset": 0,
          "doc": "0x2a2d. Unique identifier for EMEMN-FPGA"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_SCRATCH_DEBUG": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_SCRATCH_DEBUG",
      "name": "EMEMN_SCRATCH_DEBUG",
      "type": "reg",
      "addr": 3236216840,
      "offset": 8,
      "doc": "EMEMN Scratchpad and Debug Register",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "scratchpad",
          "access": "rw",
          "reset": 0,
          "doc": "Scratchpad register used to test write and readback to  EMEMN registers"
        },
        {
          "nbits": 10,
          "lsb": 6,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "rt_1553_rtpty_mon",
          "access": "ro",
          "reset": 0,
          "doc": "RT1553 Address parity bit monitoring"
        },
        {
          "nbits": 5,
          "lsb": 0,
          "name": "rt_1553_rta_mon",
          "access": "ro",
          "reset": 0,
          "doc": "RT1553 Address bits [4:0] monitoring"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_REPO_DATE": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_REPO_DATE",
      "name": "EMEMN_REPO_DATE",
      "type": "reg",
      "addr": 3236216844,
      "offset": 12,
      "doc": "Repository Date\nThis register is the last commit date of the design repository.  This is automatically generated by the checkout and build scripts.  Packed BCD format.  \nExample: Dec 31 2018  = 0x2018_1231",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "year",
          "access": "ro",
          "reset": 0,
          "doc": "character hex year"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "month",
          "access": "ro",
          "reset": 0,
          "doc": "2 character hex month"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "Day",
          "access": "ro",
          "reset": 0,
          "doc": "2 character hex day"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_0": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_0",
      "name": "rblk_apb_ememn_rsvd_0",
      "type": "mem",
      "addr": 3236216848,
      "offset": 16,
      "doc": "RSVD"
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_CFG": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_CFG",
      "name": "EMEMN_NAND_CFG",
      "type": "reg",
      "addr": 3236217088,
      "offset": 256,
      "doc": "EMEMN NAND configuration\nThis register is used to configure the EMEMN part of the NAND DMA.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "cfg_key",
          "access": "rw",
          "reset": 0,
          "doc": "Control Key = 0xC\nWrites will only take effect if this field is set to the specified value."
        },
        {
          "nbits": 6,
          "lsb": 22,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 2,
          "lsb": 20,
          "name": "partial_arr_cfg",
          "access": "rw",
          "reset": 0,
          "doc": "Partial Array Configuration. This field sets access configuration of the arrays when DMR is disabled.  The NAND actions for each configuration value are summarized below.\n0x0 =  A Only     => NAND GrpA = All cmds \n                            => NAND GrpB = No cmd\n0x1 =  B Only     => NAND GrpA = No cmd\n                            => NAND GrpB = All cmds\n0x2 = A Rebuild => NAND GrpA = Prog/Erase, reset, pre-reset \n                           => NAND GrpB = Rd, reset, pre-reset\n0x3 = B Rebuild => NAND GrpA = Rd, reset, pre-reset\n                            => NAND GrpB = Prog/Erase, reset, pre-reset\n\nThis field is IGNORED when DMR is enabled."
        },
        {
          "nbits": 2,
          "lsb": 18,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "dmr_ena",
          "access": "rw",
          "reset": 1,
          "doc": "DMR enable. This bit is used to enable/disable the full DMR operation.  When disabled the partial DMR access settings are set by the Partial Array Configuration field above.\n0 = DMR Disabled \n1 = DMR Enabled"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "allow_disable_erase_prog",
          "access": "rw",
          "reset": 0,
          "doc": "This fields allows disabling erase & prog for selected NAND lanes with the use of fields disable_erase_prog_lane_sel_gr_*.\n0 = disabling for erase/prog not allowed (=disable_erase_prog_lane_sel_gr_* will be ignored)\n1 = selectively disabling/masking erase/program for specific lanes is allowed using fields disable_erase_prog_lane_sel_gr_*."
        },
        {
          "nbits": 2,
          "lsb": 14,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 6,
          "lsb": 8,
          "name": "disable_erase_prog_lane_sel_gr_b",
          "access": "rw",
          "reset": 0,
          "doc": "This field is used (in conjunction with disable_erase_prog_ena field) to disable (=mask) erase and program capability for specific NAND lanes for group B. Particularly used to separately program/erase spare lane only without having to erase/program the other lanes twice.\n0x0 = erase/prog enabled for all lanes (except the one selected for spare)\nbit#1 set = phys lane#0 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#2 set = phys lane#2 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#3 set = phys lane#3 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#4 set = phys lane#4 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#5 set = phys lane#5 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#6 set = phys lane#6 erase/prog disabled (if allow_disable_erase_prog=1)\nNote: lane selected for spare by EMEMN_NAND_GR_*_LANE_SEL_T. spare_lane_sel_gr_* never gets accessed in erase/prog/read, regardless of setting of this disable_erase_prog_lane_sel field."
        },
        {
          "nbits": 2,
          "lsb": 6,
          "name": "rsvd_4",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "disable_erase_prog_lane_sel_gr_a",
          "access": "rw",
          "reset": 0,
          "doc": "This field is used (in conjunction with disable_erase_prog_ena field) to disable (=mask) erase and program capability for specific NAND lanes for group A. Particularly used to separately program/erase spare lane only without having to erase/program the other lanes twice.\n0x0 = erase/prog enabled for all lanes (except the one selected for spare)\nbit#1 set = phys lane#0 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#2 set = phys lane#2 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#3 set = phys lane#3 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#4 set = phys lane#4 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#5 set = phys lane#5 erase/prog disabled (if allow_disable_erase_prog=1)\nbit#6 set = phys lane#6 erase/prog disabled (if allow_disable_erase_prog=1)\nNote: lane selected for spare by EMEMN_NAND_GR_*_LANE_SEL_T. spare_lane_sel_gr_* never gets accessed in erase/prog/read, regardless of setting of this disable_erase_prog_lane_sel field"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_SEL": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_SEL",
      "name": "EMEMN_NAND_GR_A_LANE_SEL",
      "type": "reg",
      "addr": 3236217092,
      "offset": 260,
      "doc": "EMEMN NAND Group A Lane select/mapping\nThis register is used to select/map group A physical NAND devices/lanes into bytes/ECC/spare. \n\n(*) Important Note: values selected for byte0, byte1, byte2, byte3, ECC, spare MUST be distinct and MUST be between 0-5. In case of programming error where 2 or more of those values are selected to be the same or any value outside of the 0-5 allowed range, HW will ignore this register and use the default configuration : byte0=0, byte1=1, byte2=2, byte3=3, ECC=4, spare=5 instead.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "cfg_key",
          "access": "rw",
          "reset": 0,
          "doc": "Control Key = 0xC\nWrites will only take effect if this field is set to the specified value."
        },
        {
          "nbits": 4,
          "lsb": 24,
          "name": "rsvd_5",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "invalid_sel",
          "access": "ro",
          "reset": 0,
          "doc": "1 = an invalid Group A Lane select mapping has been set by FSW (either values 6-7 was entered for some byte or duplicate lane number selected for different bytes). In this case, the default Lane setting will be used : Byte#0=lane#0, Byte#1=Lane#1, Byte#2=lane#2, Byte#3=lane#3, ECC Byte=Lane#4, Spare=Lane#5."
        },
        {
          "nbits": 3,
          "lsb": 20,
          "name": "spare_lane_sel_gr_a",
          "access": "rw",
          "reset": 5,
          "doc": "This selects which of the 6 NAND lanes/devices is used for spare  (for the NAND group A).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "rsvd_6",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 16,
          "name": "ecc_lane_sel_gr_a",
          "access": "rw",
          "reset": 4,
          "doc": "This selects which of the 6 NAND lanes/devices is used for ECC byte  (for the NAND group A).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rsvd_7",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 12,
          "name": "byte3_lane_sel_gr_a",
          "access": "rw",
          "reset": 3,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #3  (for the NAND group A).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "rsvd_8",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 8,
          "name": "byte2_lane_sel_gr_a",
          "access": "rw",
          "reset": 2,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #2  (for the NAND group A).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "rsvd_9",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 4,
          "name": "byte1_lane_sel_gr_a",
          "access": "rw",
          "reset": 1,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #1  (for the NAND A group A).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_10",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 0,
          "name": "byte0_lane_sel_gr_a",
          "access": "rw",
          "reset": 0,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #0  (for the NAND group A).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_SEL": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_SEL",
      "name": "EMEMN_NAND_GR_B_LANE_SEL",
      "type": "reg",
      "addr": 3236217096,
      "offset": 264,
      "doc": "EMEMN NAND Group B Lane select/mapping\nThis register is used to select/map group B physical NAND devices/lanes into bytes/ECC/spare. \n\n(*) Important Note: values selected for byte0, byte1, byte2, byte3, ECC, spare MUST be distinct and MUST be between 0-5. In case of programming error where 2 or more of those values are selected to be the same or any value outside of the 0-5 allowed range, HW will ignore this register and use the default configuration : byte0=0, byte1=1, byte2=2, byte3=3, byte4=4, ECC=5, spare=6 instead.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "cfg_key",
          "access": "rw",
          "reset": 0,
          "doc": "Control Key = 0xC\nWrites will only take effect if this field is set to the specified value."
        },
        {
          "nbits": 4,
          "lsb": 24,
          "name": "rsvd_11",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "invalid_sel",
          "access": "ro",
          "reset": 0,
          "doc": "1 = an invalid Group B Lane select mapping has been set by FSW (either values 6-7 was entered for some byte or duplicate lane number selected for different bytes). In this case, the default Lane setting will be used : Byte#0=lane#0, Byte#1=Lane#1, Byte#2=lane#2, Byte#3=lane#3, ECC Byte=Lane#4, Spare=Lane#5."
        },
        {
          "nbits": 3,
          "lsb": 20,
          "name": "spare_lane_sel_gr_b",
          "access": "rw",
          "reset": 5,
          "doc": "This selects which of the 6 NAND lanes/devices is used for spare  (for the NAND group B).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "rsvd_12",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 16,
          "name": "ecc_lane_sel_gr_b",
          "access": "rw",
          "reset": 4,
          "doc": "This selects which of the 6 NAND lanes/devices is used for ECC byte  (for the NAND group B).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rsvd_13",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 12,
          "name": "byte3_lane_sel_gr_b",
          "access": "rw",
          "reset": 3,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #3  (for the NAND group B).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "rsvd_14",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 8,
          "name": "byte2_lane_sel_gr_b",
          "access": "rw",
          "reset": 2,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #2  (for the NAND group B).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "rsvd_15",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 4,
          "name": "byte1_lane_sel_gr_b",
          "access": "rw",
          "reset": 1,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #1  (for the NAND A group B).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_16",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 0,
          "name": "byte0_lane_sel_gr_b",
          "access": "rw",
          "reset": 0,
          "doc": "This selects which of the 6 NAND lanes/devices is used for Data Byte #0  (for the NAND group B).  \nAllowed values:  0 – 5 (6-7 not allowed, duplicates within register not allowed either) (*)"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_STAT": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_STAT",
      "name": "EMEMN_NAND_STAT",
      "type": "reg",
      "addr": 3236217100,
      "offset": 268,
      "doc": "EMEMN NAND Status\nThis register shows status for EMEMN NAND execution",
      "fields": [
        {
          "nbits": 30,
          "lsb": 2,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nand_dma_busy",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN NAND-DMA is busy when high.  This is the EMEMN part of the NAND_DMA only (not including the EMEMP part of the NAND_DMA). So this bit goes high as soon as a valid Control Block has been received by EMEMN and stays high until EMEMN is done with NAND activity and has finished sending Stat/Err BL back to EMEMP."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nand_ctrl_busy",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN NAND low level controller #0 or controller #1 (NGST module) is busy when high. This will go high when NAND device activity starts and return low as soon as NAND activity is finished, so this does not include sending data back to EMEMP or sending Stat/Err BL back to EMEMP."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_CBL_INFO": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_CBL_INFO",
      "name": "EMEMN_NAND_CBL_INFO",
      "type": "reg",
      "addr": 3236217104,
      "offset": 272,
      "doc": "EMEMN NAND CBL Info\nThis register shows information about CBL received from EMEMP.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Received a CBL with parity error"
        },
        {
          "nbits": 2,
          "lsb": 29,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 13,
          "lsb": 16,
          "name": "cbl_echoed_count",
          "access": "ro",
          "reset": 0,
          "doc": "Number of Control Blocks echoed back to EMEMP."
        },
        {
          "nbits": 3,
          "lsb": 13,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 13,
          "lsb": 0,
          "name": "cbl_received_count",
          "access": "ro",
          "reset": 0,
          "doc": "Number of Control Blocks received from EMEMP."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_CBL_W0": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_CBL_W0",
      "name": "EMEMN_NAND_LAST_CBL_W0",
      "type": "reg",
      "addr": 3236217108,
      "offset": 276,
      "doc": "EMEMN NAND Last CBL Word 0\nThis register shows the very first word (WORD_0) of the last CBL received from EMEMP.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "last_cbl_w0",
          "access": "ro",
          "reset": 0,
          "doc": "Copy of word_0 (first word) of the last CBL received from EMEMP."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_1": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_1",
      "name": "rblk_apb_ememn_rsvd_1",
      "type": "mem",
      "addr": 3236217112,
      "offset": 280,
      "doc": "RSVD"
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_RB": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_RB",
      "name": "EMEMN_NAND_RB",
      "type": "reg",
      "addr": 3236217116,
      "offset": 284,
      "doc": "EMEMN NAND Ready-Busy signals state\nThis register reports the state of NAND devices ready/busy signals.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "sgl_nand_rb_gr_sel",
          "access": "rw",
          "reset": 0,
          "doc": "This will select group a or b, for the NAND device which has the RB signal reported in field sgl_nand_rbn."
        },
        {
          "nbits": 3,
          "lsb": 28,
          "name": "sgl_nand_rb_lane_sel",
          "access": "rw",
          "reset": 0,
          "doc": "This will select Lane 0-5, for the NAND device which has the RB signal reported in field sgl_nand_rbn.\nAllowed values 0-5 (others will be mapped to lane 5)"
        },
        {
          "nbits": 3,
          "lsb": 25,
          "name": "sgl_nand_rb_die_sel",
          "access": "rw",
          "reset": 0,
          "doc": "This will select Die 0-7, for the NAND device which has the RB signal reported in field sgl_nand_rbn."
        },
        {
          "nbits": 8,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "sgl_nand_rb",
          "access": "ro",
          "reset": 0,
          "doc": "Single NAND die RB state for the NAND die selected by fields sgle_nand_rb_*_sel"
        },
        {
          "nbits": 2,
          "lsb": 14,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "nand_b_lane_5_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group b, Lane 5,  NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "nand_b_lane_4_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group b, Lane 4,  NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "nand_b_lane_3_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group b, Lane 3,  NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "nand_b_lane_2_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group b,  Lane 2, NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "nand_b_lane_1_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group b, Lane 1, NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "nand_b_lane_0_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group b, Lane 0, NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 2,
          "lsb": 6,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "nand_a_lane_5_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group a, Lane 5,  NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "nand_a_lane_4_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group a, Lane 4,  NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "nand_a_lane_3_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group a, Lane 3,  NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "nand_a_lane_2_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group a,  Lane 2, NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nand_a_lane_1_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group a, Lane 1, NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nand_a_lane_0_rb",
          "access": "ro",
          "reset": 1,
          "doc": "Group a, Lane 0, NAND devices Ready-Busy state.\n1 = all 8 dies in NAND lane device are ready\n0 = 1 or more of the 8 dies in the NAND lane device is busy."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_2": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_2",
      "name": "rblk_apb_ememn_rsvd_2",
      "type": "mem",
      "addr": 3236217120,
      "offset": 288,
      "doc": ""
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_FFB_FIFO_INFO": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_FFB_FIFO_INFO",
      "name": "EMEMN_FFB_FIFO_INFO",
      "type": "reg",
      "addr": 3236217124,
      "offset": 292,
      "doc": "EMEMN FFB FIFO information\nThis register reports EMEMN FFB bridge FIFO states.",
      "fields": [
        {
          "nbits": 9,
          "lsb": 23,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "rsp_dfifo_full",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN FFB Rsp data-FIFO full."
        },
        {
          "nbits": 6,
          "lsb": 16,
          "name": "rsp_dfifo_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN FFB Rsp data-FIFO count."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rx_dfifo_empty",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN FFB RX data-FIFO empty."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 6,
          "lsb": 8,
          "name": "rx_dfifo_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN FFB RX data-FIFO count."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "tx_dfifo_full",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN FFB TX data-FIFO full."
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "tx_dfifo_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "EMEMN FFB TX data-FIFO count."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_3": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_3",
      "name": "rblk_apb_ememn_rsvd_3",
      "type": "mem",
      "addr": 3236217128,
      "offset": 296,
      "doc": ""
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_READ_WCNT": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_READ_WCNT",
      "name": "EMEMN_NAND_READ_WCNT",
      "type": "reg",
      "addr": 3236217136,
      "offset": 304,
      "doc": "Number of Dwords read from NAND\nThis register shows a running count of the number of Dwords (32bit) read from NAND devices (and stored into SRAM/PCI). Any write to this register will clear the counter back to 0.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_read_wcnt_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write to clear counter"
        },
        {
          "nbits": 31,
          "lsb": 0,
          "name": "nand_read_wcnt",
          "access": "ro",
          "reset": 0,
          "doc": "Running counter of number of user Dwords read from NAND and stored in SRAM/transferred to PCI."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_PROG_WCNT": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_PROG_WCNT",
      "name": "EMEMN_NAND_PROG_WCNT",
      "type": "reg",
      "addr": 3236217140,
      "offset": 308,
      "doc": "Number of Dwords programmed to NAND\nThis register shows a running count of the number of Dwords (32bit) programmed NAND devices (from SRAM/PCI). Any write to this register will clear the counter back to 0.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_prog_wcnt_clr",
          "access": "rw",
          "reset": 0,
          "doc": "Write to clear counter"
        },
        {
          "nbits": 31,
          "lsb": 0,
          "name": "nand_prog_wcnt",
          "access": "ro",
          "reset": 0,
          "doc": "Running counter of number of user Dwords programmed to NAND from SRAM/PCI."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_DATA_READ": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_DATA_READ",
      "name": "EMEMN_NAND_LAST_DATA_READ",
      "type": "reg",
      "addr": 3236217144,
      "offset": 312,
      "doc": "last Dword read from NAND\nThis register shows the last Dwords (32bit) read from NAND.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "last_read_data",
          "access": "ro",
          "reset": 0,
          "doc": "Last Dword read from NAND."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_DATA_PROG": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_DATA_PROG",
      "name": "EMEMN_NAND_LAST_DATA_PROG",
      "type": "reg",
      "addr": 3236217148,
      "offset": 316,
      "doc": "last Dword programmed to NAND\nThis register shows the last Dwords (32bit) programmed to NAND.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "last_prog_data",
          "access": "ro",
          "reset": 0,
          "doc": "Last Dword programmed to NAND."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_EXEC_STATUS": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_LAST_EXEC_STATUS",
      "name": "EMEMN_NAND_LAST_EXEC_STATUS",
      "type": "reg",
      "addr": 3236217152,
      "offset": 320,
      "doc": "Status for last NAND_DMA_N execution\nThis register shows the Status for the last execution of the NAND_DMA EMEMN side (also called NAND_DMA_N). In nominal execution this register does not need to be monitored. Register NAND_DMA_ENA should be monitored instead. All the NAND_DMA_N status bits will be sent over to EMEMP, recorded in NAND_DMA_ENA and integrated into the Status Block List stored by EMEMP into SRAM. But when NAND_DMA_N fails due to FFB bridge issues then the NAND_DMA_N will not be able to send Status back to EMEMP. In this case, NAND_DMA EMEMP-side will abort with a timeout. FSW should be reading all FFB-related registers for record of the FFB-error detected and read this register EMEMN_NAND_LAST_EXEC_STATUS to get more insight into the NAND_DMA_N failure.",
      "fields": [
        {
          "nbits": 20,
          "lsb": 12,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "nand_dma_n_fail_id",
          "access": "ro",
          "reset": 0,
          "doc": "Reason for the NAND_DMA N-side (EMEMN) fail condition reported in bit 2 (nand_dma_n_fail)\nSee NAND_DMA_ENA register field nand_dma_n_fail_id  for decoding of this field."
        },
        {
          "nbits": 5,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "nand_dma_n_fail",
          "access": "ro",
          "reset": 0,
          "doc": "NAND_DMA_N failed (NAND_DMA_N execution did not complete properly, full data amount not transferred)."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "nand_dma_n_complete_with_error",
          "access": "ro",
          "reset": 0,
          "doc": "NAND_DMA_N completed with data error(s) (= NAND_DMA_N execution completed, but there were SBE/DBE data error)."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "nand_dma_n_complete",
          "access": "ro",
          "reset": 0,
          "doc": "NAND_DMA_N completed with complete data integrity (= NAND_DMA_N execution completed, no data error)."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_ECC_UERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_ECC_UERR",
      "name": "EMEMN_NAND_GR_A_ECC_UERR",
      "type": "reg",
      "addr": 3236217156,
      "offset": 324,
      "doc": "NAND Group A Uncorrectable Error Status & Count\nThis register shows the NAND group A uncorrectable (DBE/MBE) error count and flag.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_gr_a_uerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one uncorrectable error on NAND group A since last cleared (by ECC_CONTROL)."
        },
        {
          "nbits": 5,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 26,
          "lsb": 0,
          "name": "nand_gr_a_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Error count for NAND group A uncorrectable errors (=DBE/MBE).  This count increments by 1 every time an uncorrectable error is detected during NAND group A read (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\nThis counter does not wrap around and will saturate to 0x3FFFFFF after 67,108,863 errors are detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_ECC_UERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_ECC_UERR",
      "name": "EMEMN_NAND_GR_B_ECC_UERR",
      "type": "reg",
      "addr": 3236217160,
      "offset": 328,
      "doc": "NAND Group B Uncorrectable Error Status & Count\nThis register shows the NAND group A uncorrectable (DBE/MBE) error count and flag.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_gr_b_uerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one uncorrectable error on NAND group B since last cleared (by ECC_CONTROL)."
        },
        {
          "nbits": 5,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 26,
          "lsb": 0,
          "name": "nand_gr_b_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Error count for NAND group B uncorrectable errors (=DBE/MBE).  This count increments by 1 every time an uncorrectable error is detected during NAND group A read (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\nThis counter does not wrap around and will saturate to 0x3FFFFFF after 67,108,863 errors are detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_ECC_CERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_ECC_CERR",
      "name": "EMEMN_NAND_GR_A_ECC_CERR",
      "type": "reg",
      "addr": 3236217164,
      "offset": 332,
      "doc": "NAND Group A Correctable Error Status & Count\nThis register shows the NAND group A correctable (SBE) error count and flag.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_gr_a_cerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one correctable error on NAND group A since last cleared (by ECC_CONTROL)."
        },
        {
          "nbits": 5,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 26,
          "lsb": 0,
          "name": "nand_gr_a_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Error count for NAND group A correctable errors (=SBE).  This count increments by 1 every time a correctable error is detected during NAND group A read (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\nThis counter does not wrap around and will saturate to 0x3FFFFFF after 67,108,863 errors are detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_ECC_CERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_ECC_CERR",
      "name": "EMEMN_NAND_GR_B_ECC_CERR",
      "type": "reg",
      "addr": 3236217168,
      "offset": 336,
      "doc": "NAND Group B Correctable Error Status & Count\nThis register shows the NAND group A correctable (SBE) error count and flag.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_gr_b_cerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "Detected at least one correctable error on NAND group B since last cleared (by ECC_CONTROL)."
        },
        {
          "nbits": 5,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 26,
          "lsb": 0,
          "name": "nand_gr_b_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Error count for NAND group B correctable errors (=SBE).  This count increments by 1 every time a correctable error is detected during NAND group B read (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\nThis counter does not wrap around and will saturate to 0x3FFFFFF after 67,108,863 errors are detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_DMR_UERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_DMR_UERR",
      "name": "EMEMN_NAND_DMR_UERR",
      "type": "reg",
      "addr": 3236217172,
      "offset": 340,
      "doc": "NAND DMR  Uncorrectable Error Status & Count\nThis register shows the NAND DMR  uncorrectable error count and flag.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_dmr_uerr_det",
          "access": "ro",
          "reset": 0,
          "doc": "USER DATA WILL CONTAIN ERROR IF CNT NON-ZERO.\nNAND DMR detected at least one uncorrectable data error due to either :\n* Both dbe grA and dbe grB were asserted simultaneously\n* No dbe on grA, no dbe on grB but dataA!=dataB (no TMO, no all FFs)\n* grA dbe when grB suffered NAND watchdog timeout\n* grB dbe when grA suffered NAND watchdog timeout\n* grA read a fully erased word with dbe on grB\n* grB read a fully erased word with dbe on grA\n\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "nand_dmr_simult_dbe_type",
          "access": "ro",
          "reset": 0,
          "doc": "1= one or more error contributing to nand_dmr_uerr_cnt was due to an error of type : both dbe grA and dbe grB were asserted simultaneously.  Cleared by ECC_CONTROL."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "nand_dmr_no_dbe_miscomp_type",
          "access": "ro",
          "reset": 0,
          "doc": "1= one or more error contributing to nand_dmr_uerr_cnt was due to an error of type : no dbe on grA, no dbe on grB but dataA!=dataB. \n(only flagged if no side got TMO, no side read all FFs)\nNote : data compare is only done if DMR enabled, no side got TMO, no side detected all FFs. Cleared by ECC_CONTROL."
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "nand_dmr_dbe_a_tmo_b",
          "access": "ro",
          "reset": 0,
          "doc": "1= one or more error contributing to nand_dmr_uerr_cnt was due to an error of type : dbe on grA, NAND watchdog timeout on grB. Cleared by ECC_CONTROL."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "nand_dmr_dbe_b_tmo_a",
          "access": "ro",
          "reset": 0,
          "doc": "1= one or more error contributing to nand_dmr_uerr_cnt was due to an error of type : dbe on grB, NAND watchdog timeout on grA. Cleared by ECC_CONTROL."
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "nand_dmr_erased_dbe",
          "access": "ro",
          "reset": 0,
          "doc": "1= one or more error contributing to nand_dmr_uerr_cnt was due to an error of type :\nerased word on one group and DBE reported on other group (=uncorrectable DMR error).  Cleared by ECC_CONTROL."
        },
        {
          "nbits": 26,
          "lsb": 0,
          "name": "nand_dmr_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "DMR uncorrectable error count.\nDue to either :\n* Both dbe grA and dbe grB were asserted simultaneously\n* No dbe on grA, no dbe on grB but dataA!=dataB (no TMO, no all FFs)\n* grA dbe when grB suffered NAND watchdog timeout\n* grB dbe when grA suffered NAND watchdog timeout\n* grA read a fully erased word with dbe on grB\n* grB read a fully erased word with dbe on grA\n\n(requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\nThis counter is critical and should be monitored by FSW.\n\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL. \nThis counter does not wrap around and will saturate to 0x3FFFFFF after 67,108,863 errors are detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_DMR_CMISCOMP": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_DMR_CMISCOMP",
      "name": "EMEMN_NAND_DMR_CMISCOMP",
      "type": "reg",
      "addr": 3236217176,
      "offset": 344,
      "doc": "NAND DMR  Correctable Miscompare Error Status & Count\nThis register shows the NAND DMR  correctable miscompare error count and flag.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "nand_dmr_cmiscomp_det",
          "access": "ro",
          "reset": 0,
          "doc": "NAND DMR detected at least one data correctable miscompare between group A and group B when either NAND group A or group B asserted its DBE/MBE flag but DMR was able to use the other group to correct of the data error (cleared by ECC_CONTROL).\nNote: miscompare will not be flagged if one side reads 0xFF_FFFF_FFFF. Miscompare will not be flagged if one side gets TMO."
        },
        {
          "nbits": 5,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 26,
          "lsb": 0,
          "name": "nand_dmr_cmiscomp_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Error count for NAND DMR correctable miscompare errors NAND group A or group B -but not both- flagged a DBE/MBE resulting in DMR correcting the error by using data from the group which did not flag an uncorrectable error (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\n\nThis will NOT result in a user data error as the DMR will be correcting for this type of error. So this counter is not critical.\nThis counter is cleared by writing the appropriate bits to system page register ECC_CONTROL.\nThis counter does not wrap around and will saturate to 0x3FFFFFF after 67,108,863 errors are detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_ADDR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_ADDR",
      "name": "EMEMN_NAND_FIRST_UERR_ADDR",
      "type": "reg",
      "addr": 3236217180,
      "offset": 348,
      "doc": "Address of first NAND UERR\nThis register shows the full NAND address for the first uncorrectable error (that neither NAND EDAC nor DMR was able to correct). To be non-zero, any field in this register requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "first_uerr_gr",
          "access": "ro",
          "reset": 0,
          "doc": "Shows NAND group (0=A, 1 = B) that originated the first NAND ECC uerr or DMR uncorrectable error.\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 15,
          "lsb": 16,
          "name": "first_uerr_block_addr",
          "access": "ro",
          "reset": 0,
          "doc": "NAND block address of first uncorrectable error.\nUpper 3 bits are die ID within the 8-die stack.\nNote: this shows the address captured on NAND lane corresponding to logical Byte0 when the first error was detected (Byte0 had to be chosen because the design cannot detect which byte was in error)\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "first_uerr_type",
          "access": "ro",
          "reset": 0,
          "doc": "Shows the uncorrectable error type for which we captured the address:\n0x0 = no uncorrectable error detected\n0x1 = address corresponds to error type : simultaneous NAND DBE/MBE error (gr A&B reported DBE/MBE simultaneously)\n0x2 = address corresponds to error type :  DMR uncorrectable miscompare with no DBE/MBE flags from gr A nor B (no TMO, no all FFs).\n0x3 = address corresponds to error type : DBE/MBE on grA, NAND watchdog timeout on grB.\n0x4 = address corresponds to error type : DBE/MBE on grB, NAND watchdog timeout on grA.\n0x5 = Group A DBE with DMR disabled\n0x6 = Group B DBE with DMR disabled \n0xB = DMR uerr : GroupA erased, groupB DBE\n0xC = DMR uerr : GroupB erased, groupA DBE\nOther values = RSVD  \nCleared by ECC_CONTROL."
        },
        {
          "nbits": 6,
          "lsb": 6,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "first_uerr_page_addr",
          "access": "ro",
          "reset": 0,
          "doc": "NAND page address for first uncorrectable error.\nAll lanes use the same page address.\nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_ADDR_PG": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_ADDR_PG",
      "name": "EMEMN_NAND_FIRST_UERR_ADDR_PG",
      "type": "reg",
      "addr": 3236217184,
      "offset": 352,
      "doc": "Address of first NAND UERR within page\nThis register shows the address of the NAND word (using byte addressing) that generated the first uncorrectable error. To be non-zero, any field in this register requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 13,
          "lsb": 15,
          "name": "first_uerr_cb_num",
          "access": "ro",
          "reset": 0,
          "doc": "Control Block number within list (first CB is CB#0) during which the first uncorrectable error was detected.\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 15,
          "lsb": 0,
          "name": "first_uerr_addr_within_page",
          "access": "ro",
          "reset": 0,
          "doc": "NAND address within page accessed of the word that caused the first uncorrectable error (this is word address within the 16k page made of the 4x4k physical pages; to get byte number within the 4k physical NAND device page, divide this field by 4).\nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_GR_A_DATA": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_GR_A_DATA",
      "name": "EMEMN_NAND_FIRST_UERR_GR_A_DATA",
      "type": "reg",
      "addr": 3236217188,
      "offset": 356,
      "doc": "group A NAND data during first UERR\nThis register shows the group A NAND data when the first uncorrectable error was detected (DBE/MBE or DMR uerr).\nTo be non-zero, any field in this register requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "first_uerr_gr_a_data",
          "access": "ro",
          "reset": 0,
          "doc": "Group A data read when the first uncorrectable error was detected (DBE/MBE or DMR uerr). \nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_GR_B_DATA": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_UERR_GR_B_DATA",
      "name": "EMEMN_NAND_FIRST_UERR_GR_B_DATA",
      "type": "reg",
      "addr": 3236217192,
      "offset": 360,
      "doc": "group B NAND data during first UERR\nThis register shows the group B NAND data when the first uncorrectable error was detected (DBE/MBE or DMR uerr).\nTo be non-zero, any field in this register requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "first_uerr_gr_b_data",
          "access": "ro",
          "reset": 0,
          "doc": "Group B data read when the first uncorrectable error was detected (DBE/MBE or DMR uerr). \nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_ADDR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_ADDR",
      "name": "EMEMN_NAND_FIRST_CERR_ADDR",
      "type": "reg",
      "addr": 3236217196,
      "offset": 364,
      "doc": "Address of first CERR\nThis register shows the full NAND address for the first correctable error (SBE or DMR corrected single-sided DBE). To be non-zero, any field in this register requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "first_cerr_gr",
          "access": "ro",
          "reset": 0,
          "doc": "Shows NAND group (0=A, 1 = B) that originated the first NAND ECC cerr. \nNote / corner-cases: \nIf both sides get simultaneous SBE, group A will be reported here\nIf we simultaneously get SBE on one side and DBE on the other side that the DMR can correct then the group with DBE will get reported here\n(this priority scheme is the same for first_cerr_type and first_cerr_block_addr selection)\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 15,
          "lsb": 16,
          "name": "first_cerr_block_addr",
          "access": "ro",
          "reset": 0,
          "doc": "NAND block address for first correctable error.\nUpper 3 bits are die ID within the 8-die stack.\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "first_cerr_type",
          "access": "ro",
          "reset": 0,
          "doc": "Shows the correctable error type for which we captured the address:\n0x0 = no correctable error detected\n0x1 = first error type : NAND group A DBE/MBE that DMR was able to correct\n0x2 = first error type :  NAND group B DBE/ MBE that DMR was able to correct\n0x3 = first error type : NAND group A SBE\n0x4 = first error type :  NAND group B SBE\nOther values = RSVD  \nCleared by ECC_CONTROL."
        },
        {
          "nbits": 6,
          "lsb": 6,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "first_cerr_page_addr",
          "access": "ro",
          "reset": 0,
          "doc": "NAND page address for first correctable error.\nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_ADDR_PG": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_ADDR_PG",
      "name": "EMEMN_NAND_FIRST_CERR_ADDR_PG",
      "type": "reg",
      "addr": 3236217200,
      "offset": 368,
      "doc": "Address of first CERR within page\nThis register shows additional information on the address of the NAND word that generated the first correctable ECC error (SBE or DMR corrected). To be non-zero, any field in this register requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 3,
          "lsb": 28,
          "name": "first_cerr_phys_lane",
          "access": "ro",
          "reset": 0,
          "doc": "Shows physical lane number for the first correctable error. Cleared by ECC_CONTROL."
        },
        {
          "nbits": 13,
          "lsb": 15,
          "name": "first_cerr_cb_num",
          "access": "ro",
          "reset": 0,
          "doc": "Control Block number within list (first CB is CB#0) during which the first correctable error was detected.\nCleared by ECC_CONTROL."
        },
        {
          "nbits": 15,
          "lsb": 0,
          "name": "first_cerr_addr_within_page",
          "access": "ro",
          "reset": 0,
          "doc": "NAND address within page accessed of the word that caused the first correctable error (this is word address within the 16k page made of the 4x4k physical pages; to get byte number within the 4k physical NAND device page, divide this field by 4).\n\nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_RAW_DATA": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_RAW_DATA",
      "name": "EMEMN_NAND_FIRST_CERR_RAW_DATA",
      "type": "reg",
      "addr": 3236217204,
      "offset": 372,
      "doc": "Raw uncorrected data for first CERR\nThis register shows the raw uncorrected data for the first correctable error (SBE or DMR corrected).",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "first_cerr_raw_data",
          "access": "ro",
          "reset": 0,
          "doc": "Raw, uncorrected data read that triggered the first correctable error (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_CORRECTED_DATA": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_FIRST_CERR_CORRECTED_DATA",
      "name": "EMEMN_NAND_FIRST_CERR_CORRECTED_DATA",
      "type": "reg",
      "addr": 3236217208,
      "offset": 376,
      "doc": "Ccorrected data for first CERR\nThis register shows the corrected data for the first correctable error (SBE or DMR orrected).",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "first_cerr_corrected_data",
          "access": "ro",
          "reset": 0,
          "doc": "Corrected data read that triggered the first correctable error (requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable).\nCleared by ECC_CONTROL."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_0_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_0_ERR",
      "name": "EMEMN_NAND_GR_A_LANE_0_ERR",
      "type": "reg",
      "addr": 3236217216,
      "offset": 384,
      "doc": "NAND Group A Lane #0 Error Count\nThis register shows the NAND group A, physical Lane #0 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_a_lane_0_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #0 : correctable (SBE or DMR corrected) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_a_lane_0_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #0 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_1_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_1_ERR",
      "name": "EMEMN_NAND_GR_A_LANE_1_ERR",
      "type": "reg",
      "addr": 3236217228,
      "offset": 396,
      "doc": "NAND Group A Lane #1 Error Count\nThis register shows the NAND group A,  physical Lane #1 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_a_lane_1_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #1 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_a_lane_1_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #1 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_2_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_2_ERR",
      "name": "EMEMN_NAND_GR_A_LANE_2_ERR",
      "type": "reg",
      "addr": 3236217232,
      "offset": 400,
      "doc": "NAND Group A Lane #2 Error Count\nThis register shows the NAND group A, physical Lane #2 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_a_lane_2_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #2 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_a_lane_2_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #2 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_3_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_3_ERR",
      "name": "EMEMN_NAND_GR_A_LANE_3_ERR",
      "type": "reg",
      "addr": 3236217236,
      "offset": 404,
      "doc": "NAND Group A Lane #3 Error Count\nThis register shows the NAND group A, physical Lane #3 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_a_lane_3_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #3 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_a_lane_3_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #3 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_4_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_4_ERR",
      "name": "EMEMN_NAND_GR_A_LANE_4_ERR",
      "type": "reg",
      "addr": 3236217240,
      "offset": 408,
      "doc": "NAND Group A Lane #4 Error Count\nThis register shows the NAND group A,  physical Lane #4 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_a_lane_4_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #4 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_a_lane_4_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #4 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_5_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_A_LANE_5_ERR",
      "name": "EMEMN_NAND_GR_A_LANE_5_ERR",
      "type": "reg",
      "addr": 3236217244,
      "offset": 412,
      "doc": "NAND Group A Lane #5 Error Count\nThis register shows the NAND group A, physical Lane #5 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_a_lane_5_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #5 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_a_lane_5_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group A, NAND lane #5 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_0_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_0_ERR",
      "name": "EMEMN_NAND_GR_B_LANE_0_ERR",
      "type": "reg",
      "addr": 3236217248,
      "offset": 416,
      "doc": "NAND Group B Lane #0 Error Count\nThis register shows the NAND group A, physical Lane #0 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_b_lane_0_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #0 : correctable (SBE or DMR corrected) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_b_lane_0_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #0 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_1_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_1_ERR",
      "name": "EMEMN_NAND_GR_B_LANE_1_ERR",
      "type": "reg",
      "addr": 3236217252,
      "offset": 420,
      "doc": "NAND Group B Lane #1 Error Count\nThis register shows the NAND group A,  physical Lane #1 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_b_lane_1_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #1 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_b_lane_1_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #1 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_2_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_2_ERR",
      "name": "EMEMN_NAND_GR_B_LANE_2_ERR",
      "type": "reg",
      "addr": 3236217256,
      "offset": 424,
      "doc": "NAND Group B Lane #2 Error Count\nThis register shows the NAND group A, physical Lane #2 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_b_lane_2_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #2 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_b_lane_2_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #2 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_3_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_3_ERR",
      "name": "EMEMN_NAND_GR_B_LANE_3_ERR",
      "type": "reg",
      "addr": 3236217260,
      "offset": 428,
      "doc": "NAND Group B Lane #3 Error Count\nThis register shows the NAND group A, physical Lane #3 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_b_lane_3_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #3 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_b_lane_3_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #3 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_4_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_4_ERR",
      "name": "EMEMN_NAND_GR_B_LANE_4_ERR",
      "type": "reg",
      "addr": 3236217264,
      "offset": 432,
      "doc": "NAND Group B Lane #4 Error Count\nThis register shows the NAND group A,  physical Lane #4 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_b_lane_4_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #4 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_b_lane_4_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #4 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_5_ERR": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.EMEMN_NAND_GR_B_LANE_5_ERR",
      "name": "EMEMN_NAND_GR_B_LANE_5_ERR",
      "type": "reg",
      "addr": 3236217268,
      "offset": 436,
      "doc": "NAND Group B Lane #5 Error Count\nThis register shows the NAND group A, physical Lane #5 error count and flag. Requires both ECC global enable and fine NAND ECC enable from ECC_CONTROL.nand_ecc_enable.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "nand_gr_b_lane_5_cerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #5 : correctable (SBE) error count.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "nand_gr_b_lane_5_uerr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Group B, NAND lane #5 : uncorrectable (DBE/MBE) error count.\nWhen DBE happens, all lanes where data does not match on groupA vs grouB will increment their uerr_cnt. If DBEs happened on both groupA & B then all lanes will increment their uerr_cnt because we cannot locate the DBE in this case.\nCleared by ECC_CONTROL.This counter does not wrap around, will saturate."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_4": {
      "id": "emem.EMEM_APB.APB_EMEMN_SYST.rblk_apb_ememn_rsvd_4",
      "name": "rblk_apb_ememn_rsvd_4",
      "type": "mem",
      "addr": 3236217272,
      "offset": 440,
      "doc": ""
    },
    "emem.EMEM_APB.APB_RT_1553": {
      "id": "emem.EMEM_APB.APB_RT_1553",
      "name": "APB_RT_1553",
      "type": "blk",
      "addr": 3236217344,
      "offset": 49664,
      "doc": "BAR0 Space –1553 Registers",
      "children": [
        "emem.EMEM_APB.APB_RT_1553.RTIP_MAP",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP"
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTIP_MAP": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTIP_MAP",
      "name": "RTIP_MAP",
      "type": "blk",
      "addr": 3236217344,
      "offset": 0,
      "doc": "BAR0 Space –1553 RT IP Registers\nEXTRA OFFSET: 0x0",
      "children": [
        "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIPREV",
        "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIP",
        "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIE",
        "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.rtip_csr_map_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIPREV": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIPREV",
      "name": "RTIPREV",
      "type": "reg",
      "addr": 3236217344,
      "offset": 0,
      "doc": "RT IP Rev Register (RTIPREV)\nReset by: POR",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "IPREV_Major",
          "access": "ro",
          "reset": 1,
          "doc": "32 bit is reserved for the revision-ing of the RT IP and is reserved for the following format:\nMajor[12].Minor[12].Patch[8]\nNote that decimal numbering will be used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 12,
          "lsb": 12,
          "name": "IPREV_Minor",
          "access": "ro",
          "reset": 0,
          "doc": "32 bit is reserved for the revision-ing of the RT IP and is reserved for the following format:\nMajor[12].Minor[12].Patch[8]\nNote that decimal numbering will be used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "IPREV_Patch",
          "access": "ro",
          "reset": 0,
          "doc": "32 bit is reserved for the revision-ing of the RT IP and is reserved for the following format:\nMajor[12].Minor[12].Patch[8]\nNote that decimal numbering will be used; so for example the minor revision after 1.9.0 will be 1.10.0 and not 1.0A.0"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIP": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIP",
      "name": "RTIP",
      "type": "reg",
      "addr": 3236217348,
      "offset": 4,
      "doc": "Interrupt Pending Register (IP)\nReset by: POR\n\n\n\n* These two bits cannot be cleared through IP3.  When these interrupts are set they can only be cleared by clearing their corresponding bits in the RT registers.  In self test these bits cannot be set.",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "Clr_PI_Ena",
          "access": "RW-Write-1-to-Set",
          "reset": 0,
          "doc": "Clear Pending Interrupt Enable: When set to 1 during a write, control of Pending interrupt bits is allowed. 0 during Read."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Readback 0."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "RT_DMA_M_Abort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1553RT DMA Master Abort is set to logic 1 when a Master abort has occurred. Can be set in test mode, otherwise it can only be cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "RT_DMA_InvDir",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1553RT DMA Invalid Direction is set to logic 1 when the DMAs least significant bit is not correct for the type of DMA requested by the 1553. Can be set in test mode, otherwise it can only be cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "RT_DMA_Done",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1553RT DMA Complete"
        },
        {
          "nbits": 11,
          "lsb": 16,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Readback 0."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "RT_DBE_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1553 RT Double Bit Error interrupt is set to logic 1 when a double bit error has been detected in the RT RAM. Can be set in test mode, otherwise it can only be cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "RT_SBE_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "1553 RT Single Bit Error interrupt is set to logic 1 when the single bit error count in the RT RAM has reached the predetermined count value in the 1553 EDAC Control and Status Register. Can be set in test mode, otherwise it can only be cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "HI_MEM_DBE_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "HI MEM Double Bit Error interrupt is set to logic 1 when a double bit error has been detected in the external EDAC or data RAM.  This interrupt is only for double bit errors detected when reading data from HiMem. Can be set in test mode, otherwise it can be only cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "HI_MEM_SBE_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "HI MEM Single Bit Error interrupt is set to logic 1 when the single bit error occurs in the HiMEM portion of external RAM. Can be set in test mode, otherwise it can be only cleared with Clear bit above."
        },
        {
          "nbits": 5,
          "lsb": 7,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Readback 0."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "DTSTART_Det",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DTSTART Detected Interrupt is set to logic 1 whenever the negative edge of the DTSTARTn signal is detected. Can be set in test mode, otherwise it can be only cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "XRTI_Det",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "XRTI Detected Interrupt is set to logic 1 every negative edge of the XRTIn signal"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "CHKPT_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Checkpoint Interrupt is set to logic 1 when CHKPT_FLG in the ESCR1 bit is set via the 1553. Can be set in test mode, otherwise it can be only cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "AI_DONE_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Auto Initialization Done interrupt is set to logic 1 when the Auto Initialization has completed its process, ~40us. Can be set in test mode, otherwise it can be only cleared with Clear bit above."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "WDT_EXP_Int",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Watchdog Timer Expired Interrupt is set to logic 1 when the RT Watchdog Timer, when enabled, has not been cleared by the 1553 BC within the 4.04 seconds specified."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "RT_STDINT",
          "access": "ro",
          "reset": 0,
          "doc": "1553RT Standard Interrupt: Set to logic 1 when one or more events in RT9 or RT Descriptor, register occur.  Clearing the STI bit in the RT8 register clears this interrupt.\nThis bit cannot be cleared here.  When this interrupt is set it can only be cleared by clearing its corresponding bits in the RT registers.  In self test this bit cannot be set."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "RT_HPINT",
          "access": "ro",
          "reset": 0,
          "doc": "1553RT High Priority Interrupt: The High-Priority Interrupt is set to logic 1 upon occurrence of events enabled in the RT7 register.  The corresponding bit(s) in RT8 clear this interrupt. ASIA inverts RT interrupt so bit is 1 when the RT HPINTn interrupt is active (logic 0).\nThis bit cannot be cleared here.  When this interrupt is set it can only be cleared by clearing its corresponding bits in the RT registers.  In self test this bit cannot be set."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIE": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.RTIE",
      "name": "RTIE",
      "type": "reg",
      "addr": 3236217352,
      "offset": 8,
      "doc": "Interrupt Enable Register (IE)\nReset by: POR",
      "fields": [
        {
          "nbits": 1,
          "lsb": 31,
          "name": "PI_SelfTst_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Pending Interrupt Self Test Enable: Software must set this bit to allow test software to set Interrupt Pending bits. 0 at reset."
        },
        {
          "nbits": 1,
          "lsb": 30,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Readback 0."
        },
        {
          "nbits": 1,
          "lsb": 29,
          "name": "RT_M_Abort_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553RT DMA Master Abort Interrupt Enable."
        },
        {
          "nbits": 1,
          "lsb": 28,
          "name": "RT_DMA_InvDir_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553RT DMA Invalid Direction Interrupt Enable."
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "RT_DMA_Done_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "DMA Done Interrupt Enable"
        },
        {
          "nbits": 11,
          "lsb": 16,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Readback 0."
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "RT_DBE_Int",
          "access": "rw",
          "reset": 0,
          "doc": "1553 RT Double Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "RT_SBE_Int",
          "access": "rw",
          "reset": 0,
          "doc": "1553 RT Single Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "HI_MEM_DBE_Int",
          "access": "rw",
          "reset": 0,
          "doc": "HI MEM Double Bit Error Interrupt Enable"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "HI_MEM_SBE_Int",
          "access": "rw",
          "reset": 0,
          "doc": "HI MEM Single Bit Error Interrupt Enable"
        },
        {
          "nbits": 5,
          "lsb": 7,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Readback 0."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "DTSTART_Det_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "DTSTART Detected Interrupt enable"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "XRTI_Det_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "XRTI Detected Interrupt enabled"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "CHKPT_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Check Point Interrupt enable"
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "AI_DONE_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Auto Initialization done interrupt enable"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "WDT_EXP_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "Watchdog Timer Expired interrupt enable"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "RT_STDINT_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553RT Standard Interrupt Enable: This bit enables 1553RT_STDINT to drive PCI INTAn 1553RT internal #7 High_Priority interrupt Enable Register must also be controlled to enable high priority interrupts."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "RT_HPINT_Ena",
          "access": "rw",
          "reset": 0,
          "doc": "1553RT High Priority Interrupt Enable: This bit enables 1553RT_HPINT to drive PCI INTAn.  1553RT internal #9 Standard Interrupt Enable Register must be also controlled to enable standard interrupts."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.rtip_csr_map_rsvd_0": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTIP_MAP.rtip_csr_map_rsvd_0",
      "name": "rtip_csr_map_rsvd_0",
      "type": "mem",
      "addr": 3236217356,
      "offset": 12,
      "doc": ""
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP",
      "name": "RTDMA_MAP",
      "type": "blk",
      "addr": 3236217360,
      "offset": 16,
      "doc": "BAR0 Space –1553 RT DMA Registers\nEXTRA OFFSET: 0x10",
      "children": [
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDADR",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDCMS",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDDAT",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDADR",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDCMS",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDDAT",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDSEL",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDSEL",
        "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.rtdma_csr_map_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDADR": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDADR",
      "name": "RTDADR",
      "type": "reg",
      "addr": 3236217360,
      "offset": 0,
      "doc": "RT DMA Address Register (RTDADR)\nThe following 3 registers correspond to the PSUDO PCI DMA engine used to transfer 1 double word by the 1553 RT to the PCI bus.\nThis 32-bit register indicates the starting source/destination address for the PSUDO PCI DMA.  This register is read only.\nReset by: POR",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "rt_dma_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Reads back the starting source/destination address of the DMA.  The least significant bit indicates direction of the DMA.  This is a 32bit address and hence there is no byte enable.  Note for HK FPGA this register is only updated at the start of a 1553 command and not updated per transaction in a multi word 1553 transaction for dma information is not passed back to the 1553.\nIdiosyncrasy: due to legacy RT1553 core, RTDADR shows the NEXT RTDMA address to be accessed (or current address +4). From legacy MSIA core. https://jira.jpl.nasa.gov/projects/AVSE/issues/AVSE-1013"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDCMS": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDCMS",
      "name": "RTDCMS",
      "type": "reg",
      "addr": 3236217364,
      "offset": 4,
      "doc": "RT DMA Status Control Register (RTDCMS)\nReset by: POR",
      "fields": [
        {
          "nbits": 6,
          "lsb": 26,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 25,
          "name": "Health_Stat",
          "access": "ro",
          "reset": 0,
          "doc": "EMEM : This is permanently tied high.\nLEGACY (non-EMEM) This bit is used to indicate the health state of the current string.  At reset this signal is low indicating an unhealthy state, once the LBHEALTHBEAT signals begins to toggle this bit will be set to logic ‘1’ to indicate a healthy string."
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "dma_overflow",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DMA Overflow is set to logic ‘1’ when the DMA engine was unable to transfer the last data to PCI memory prior to receiving the new data.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "dma_underrun",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DMA Under run is set to logic ‘1’ when the DMA engine was unable to transfer the last data from PCI memory in time to send it on the 1553 bus.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "msw_pending",
          "access": "ro",
          "reset": 0,
          "doc": "Most Significant Word pending bit is set to logic ‘1’ when it is pending transfer to DMA engine or PCI memory depending on DMA direction.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "lsw_pending",
          "access": "ro",
          "reset": 0,
          "doc": "Least Significant Word pending bit is set to logic ‘1’ when it is pending transfer to DMA engine or PCI memory depending on DMA direction.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "invalid_dir",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Invalid Direction.  Set to logic ‘1’ when the DMA’s least significant bit is not correct for the type of DMA requested by the 1553 bus.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "d_par_err",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Data Parity Error detected.  Set to logic ‘1’ when a data parity error is detected on the PCI bus during DMA.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)\nIDIOSYNCRASY: due to the relative timing of PCI parity error detection/reporting and RT1553 transfers, the SUBSYSTEM FLAG fail might not be set during the actual RT1553 transfer when the parity happened but starting with the next RT1553 transfer. See Jira https://jira.jpl.nasa.gov/browse/AVSE-1950."
        },
        {
          "nbits": 1,
          "lsb": 18,
          "name": "dma_t_abort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DMA target abort status (hardware set to ‘1’ when it detects a target abort for DMA).  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 17,
          "name": "dma_m_abort",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DMA master abort status (hardware set to ‘1’ when it detects a master abort for DMA).  \nEMEM: this bit will be set in any of those situations:\nPCI initiator m_abort is detected while RTDMA is the master OR\nFFB bridge is down when RTDMA is active OR\nWarm PCI reset was asserted when RTDMA was active and PCI route selected (RTDSEL.route_sel=1)\nThis bit will also assert a bit in the Interrupt Pending Register.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 14,
          "lsb": 3,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "a_par_err_ena",
          "access": "ro",
          "reset": 0,
          "doc": "Address Parity Error Enable is a mirror of bit 2 in the 1553 DMA Control/Status Word.  See section 8.2.3 for functional detail.\nMSIA LEGACY IDIOSYNCRASY: although actually implemented as FSW RW in the design, the force function from this bit is not connected inside the design, this bit does not control any logic."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "d_par_err_ena",
          "access": "ro",
          "reset": 0,
          "doc": "Data Parity Error Enable is a mirror of bit 1 in the 1553 DMA Control/Status Word.  See section 8.2.3 for functional detail. \nMSIA LEGACY IDIOSYNCRASY: although actually implemented as FSW RW in the design, the force function from this bit is not connected inside the design, this bit does not control any logic."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "0 on read"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDDAT": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDDAT",
      "name": "RTDDAT",
      "type": "reg",
      "addr": 3236217368,
      "offset": 8,
      "doc": "RT DMA Data Register (RTDDAT)\nThis register contains the data that was transferred using the 1553 DMA.\nReset by: POR",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "rt_dma_data",
          "access": "ro",
          "reset": 0,
          "doc": "Holds the data that was last transferred using the 1553 DMA."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDADR": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDADR",
      "name": "RTIDADR",
      "type": "reg",
      "addr": 3236217372,
      "offset": 12,
      "doc": "RT Internal DMA Address Register (RTIDADR)\nEMEM ONLY: NO RT INTERNAL DMA IMPLEMENTED, THIS REGISTER IS NOT FUNCTIONAL. \nThe following 3 registers correspond to the PSUDO Internal DMA engine used to transfer 1 double word by the 1553 RT to the internal interface, i.e. NOR or registers.\nThis 32-bit register indicates the starting source/destination address for the internally mapped address.  This register is read only.\nReset by: POR",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "rt_intdma_addr",
          "access": "ro",
          "reset": 0,
          "doc": "Reads back the starting source/destination address of the DMA.  The least significant bit indicates direction of the DMA.  This is a 32bit address and hence there is no byte enable.  Note for HK FPGA this register is only updated at the start of a 1553 command and not updated per transaction in a multi word 1553 transaction for dma information is not passed back to the 1553."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDCMS": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDCMS",
      "name": "RTIDCMS",
      "type": "reg",
      "addr": 3236217376,
      "offset": 16,
      "doc": "RT Internal DMA Status Control Register (RTIDCMS)\nEMEM ONLY: NO RT INTERNAL DMA IMPLEMENTED, THIS REGISTER IS NOT FUNCTIONAL. \nReset by: POR",
      "fields": [
        {
          "nbits": 7,
          "lsb": 25,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 24,
          "name": "intdma_overflow",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DMA Overflow is set to logic ‘1’ when the DMA engine was unable to transfer the last data to PCI memory prior to receiving the new data.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "intdma_underrun",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "DMA Under run is set to logic ‘1’ when the DMA engine was unable to transfer the last data from PCI memory in time to send it on the 1553 bus.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 22,
          "name": "intmsw_pending",
          "access": "ro",
          "reset": 0,
          "doc": "Most Significant Word pending bit is set to logic ‘1’ when it is pending transfer to DMA engine or PCI memory depending on DMA direction.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 21,
          "name": "lintsw_pending",
          "access": "ro",
          "reset": 0,
          "doc": "Least Significant Word pending bit is set to logic ‘1’ when it is pending transfer to DMA engine or PCI memory depending on DMA direction.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 1,
          "lsb": 20,
          "name": "intinvalid_dir",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Invalid Direction.  Set to logic ‘1’ when the DMA’s least significant bit is not correct for the type of DMA requested by the 1553 bus.  This bit will cause SUBSYSTEM FLAG fail to be set in the 1553.  To clear SUBSYSTEM FLAG fail error this bit must be cleared.  To Clear these bits software must write a ‘1’ to the bit position (0 has no effect)"
        },
        {
          "nbits": 20,
          "lsb": 0,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDDAT": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDDAT",
      "name": "RTIDDAT",
      "type": "reg",
      "addr": 3236217380,
      "offset": 20,
      "doc": "RT Internal DMA Data Register (RTIDDAT)\nEMEM ONLY: NO RT INTERNAL DMA IMPLEMENTED, THIS REGISTER IS NOT FUNCTIONAL. \nThis register contains the data that was transferred using the 1553 DMA.\nReset by: POR",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "rt_intdma_data",
          "access": "ro",
          "reset": 0,
          "doc": "Holds the data that was last transferred using the 1553 DMA."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDSEL": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTIDSEL",
      "name": "RTIDSEL",
      "type": "reg",
      "addr": 3236217384,
      "offset": 24,
      "doc": "RT Internal DMA Select Register (RTIDSEL)\nEMEM ONLY: NO RT INTERNAL DMA IMPLEMENTED, THIS REGISTER IS NOT FUNCTIONAL. \n\nReset by: POR",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "dest_sel",
          "access": "rw",
          "reset": 0,
          "doc": "FUNCTIONALITY NOT IMPLEMENTED BECAUSE NO INTERNAL_DMA FOR EMEM."
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "route_sel",
          "access": "rw",
          "reset": 0,
          "doc": "FUNCTIONALITY NOT IMPLEMENTED BECAUSE NO INTERNAL_DMA FOR EMEM."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "idma_present",
          "access": "ro",
          "reset": 0,
          "doc": "0 = internal DMA not present / not implemented \n1 = internal DMA interface present / implemented  / available for use"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDSEL": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.RTDSEL",
      "name": "RTDSEL",
      "type": "reg",
      "addr": 3236217388,
      "offset": 28,
      "doc": "RT DMA Select Register (RTDSEL)\nReset by: POR",
      "fields": [
        {
          "nbits": 24,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "dest_sel",
          "access": "rw",
          "reset": 0,
          "doc": "NEW EMEM ONLY. \nThis filed is used ONLY when route_sel = 0 (= internal route using AHB).  \nFor route_sel=0, dest_sel is required because the RT1553 has no knowledge of the PCI address currently assigned to each EMEM PCI BAR. So the RT1553 user must supply this information using dest_sel.\nFor route_sel=1, dest_sel is IGNORED since the full PCI address from the RT1553 DMA words will carry the BAR/destination information.\n\ndest_sel = 0, w/ route_sel=0 => internal DMA destination will be EMEM registers or RT 1553 intRAM \n(only bits 16:0 from the RT1553 RT-DMA supplied address in 1553 Data words 2&3 will be used by EMEM for this selection – upper bits will get ignored)\n\ndest_sel = 1, w/ route_sel=0 => internal DMA destination = EMEM SRAM \n(only bits 23:0 from the RT1553 RT-DMA supplied address in 1553 Data words 2&3 will be used by EMEM for this selection – upper bits will get ignored)\n\ndest_sel = 2, w/ route_sel=0 => internal DMA destination = EMEM MRAM \n(only bits 26:0 from the RT1553 RT-DMA supplied address in 1553 Data words 2&3 will be used by EMEM for this selection – upper bits will get ignored)\n\nothers = when route_sel=0, internal DMA destination = EMEM registers or RT 1553 intRAM"
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "route_sel",
          "access": "rw",
          "reset": 0,
          "doc": "NEW EMEM ONLY.\n0 = DMA will use AHB (= internal) route \n1 = DMA will use PCI (= external) route"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "dma_present",
          "access": "ro",
          "reset": 0,
          "doc": "0 = DMA not present / not implemented \n1 = DMA interface present / implemented  / available for use"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.rtdma_csr_map_rsvd_0": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTDMA_MAP.rtdma_csr_map_rsvd_0",
      "name": "rtdma_csr_map_rsvd_0",
      "type": "mem",
      "addr": 3236217392,
      "offset": 32,
      "doc": "Reads back 0x0"
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP",
      "name": "RTPRO_MAP",
      "type": "blk",
      "addr": 3236217600,
      "offset": 256,
      "doc": "BAR0 Space –1553 RT Protocol Registers\nEXTRA OFFSET: 0x100",
      "children": [
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT0",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT1",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT2",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT5",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT6",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT7",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT8",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT9",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT10",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.rtpro_csr_map_rsvd_0",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT12",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT13",
        "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.rtpro_csr_map_rsvd_1"
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT0": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT0",
      "name": "RT0",
      "type": "reg",
      "addr": 3236217600,
      "offset": 0,
      "doc": "Internal Control Register (RT0)\nThis register includes all of the control bits for the 1553RT module.  \nReset by: POR, AI condition \n\n\n*SOFT RESET: Refers to the RT Master reset, this reset is triggered by Auto Initialization, please see 15.1 AI Operation, for sources that cause AI.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "DRT",
          "access": "rw",
          "reset": 0,
          "doc": "Diagnostic Register Test Bit. When this bit is set to 1, the Interrupt Status Register (Register 8) may be written and read for test purposes."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "RT_AD31",
          "access": "rw",
          "reset": 0,
          "doc": "When this bit is set to 0, the 1553RT recognizes RT address 31 as a broadcast command. \nWhen this bit is set to 1, the 1553RT treats RT address 31 as a normal terminal address."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "RT_SAD31",
          "access": "rw",
          "reset": 0,
          "doc": "When this bit is set to 0, the 1553RT will recognize a command word either of sub-address 0 or 31 as being a valid mode code. \nWhen this bit is set to 1, the 1553RT only recognizes a command word with a sub-address of 0 as a valid mode code."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "RT2RT_TO",
          "access": "rw",
          "reset": 0,
          "doc": "RT to RT response timeout.\nIf this bit is set to 1, the timer will time-out at 32 microseconds. \nIf this bit is set to 0, the timer will time-out at 16 microseconds."
        },
        {
          "nbits": 3,
          "lsb": 9,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "RT_B_EN",
          "access": "rw",
          "reset": 1,
          "doc": "Remote Terminal Channel B Enable. When set, Channel B operation is enabled."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "RT_A_EN",
          "access": "rw",
          "reset": 1,
          "doc": "Remote Terminal Channel A enable. When set, Channel A operation in enabled."
        },
        {
          "nbits": 6,
          "lsb": 1,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "START_EN",
          "access": "rw",
          "reset": 1,
          "doc": "Start Enable. It enables the RT to receive a valid command. The RT will not start until a valid command is received.  Writing a 0 will not halt the current operation if any.  Mode code reset will still be accepted even if this bit is.not set.  This bit controls operation of the 1553RT as follows:\n\nWrite 1 Start\nWrite 0 Finish Command, then Stop"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT1": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT1",
      "name": "RT1",
      "type": "reg",
      "addr": 3236217604,
      "offset": 4,
      "doc": "Status Register (RT1)\nThe Status Register is a read only register Writes are Ignored. It indicates the present status of the 1553RT module. \nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "RT_ACT",
          "access": "ro",
          "reset": 0,
          "doc": "Remote Terminal Active. This bit indicates that the 1553RT is currently servicing a command"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "RT_TF",
          "access": "ro",
          "reset": 0,
          "doc": "Remote Terminal Flag. This bit reflects the results of writing to Register 10 - Bit 11."
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "RT_SRQ",
          "access": "ro",
          "reset": 0,
          "doc": "Remote Terminal Service Request. This bit reflects the results of writing to Register 10 - Bit 10."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "RT_BSY",
          "access": "ro",
          "reset": 0,
          "doc": "Remote Terminal Busy. This bit reflects the results of writing to Register 10 - Bit 9 or Bit 14."
        },
        {
          "nbits": 2,
          "lsb": 8,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused. Ignored when written. Always read back as zero."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "rsvd_4",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "A_NOT_B_SEL",
          "access": "ro",
          "reset": 1,
          "doc": "(A/~B) Indicates the channel presently in use or the last channel used."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "SUBSYS_INDIC",
          "access": "ro",
          "reset": 1,
          "doc": "Indicates receiving a subsystem fail signal from the host subsystem."
        },
        {
          "nbits": 4,
          "lsb": 1,
          "name": "rsvd_5",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "RT_IN_PROG",
          "access": "ro",
          "reset": 1,
          "doc": "This bit indicates that the Remote Terminal is in operation.  This bit reflects bit 0 of register 0."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT2": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT2",
      "name": "RT2",
      "type": "reg",
      "addr": 3236217608,
      "offset": 8,
      "doc": "Descriptor Space Address Register (RT2)\nReset by: POR, AI condition \n\n\n\nThe Host CPU initializes this register to indicate the starting location of the RT Descriptor Space. The Host must allocate 320 sequential locations following this starting address. This location must start on an nx512 decimal address boundary where n is an integer multiple (n = 0 is a valid number).",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 7,
          "lsb": 9,
          "name": "CCB_DATA_M",
          "access": "rw",
          "reset": 0,
          "doc": "Upper 7 bits of address register to indicate starting address of the Descriptor Space."
        },
        {
          "nbits": 9,
          "lsb": 0,
          "name": "CCB_DATA_L",
          "access": "ro",
          "reset": 0,
          "doc": "These bits are used to as the lower 9 bits of the descriptor table address but are not writable.  They read back zero."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT5": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT5",
      "name": "RT5",
      "type": "reg",
      "addr": 3236217620,
      "offset": 20,
      "doc": "Current Command Register (RT5)\nThis register contains the command currently being processed. When not processing the command, the 1553RT stores the last command received on the 1553B bus. This register is updated by the 1553RT engine when Bit 0 of Register 0 is set. Host updating is allowed if Bit 0 of Register 0 is reset. This allows the 1553RT to comply with level 4 requirements.\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "CC_DATA",
          "access": "ro",
          "reset": 0,
          "doc": "16 bit data for current command register"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT6": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT6",
      "name": "RT6",
      "type": "reg",
      "addr": 3236217624,
      "offset": 24,
      "doc": "Interrupt Log List Pointer (RT6)\nThis register is initialized by the CPU. The Interrupt Log List Pointer indicates the Start of the Interrupt Log List. After each log list entry, the RT module updates this register with the address of the next entry in the list. The software must make sure the Interrupt Log List Pointer does not point out of the RT RAM address range.\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "ILLP_DATA",
          "access": "rw",
          "reset": 336,
          "doc": "Interrupt Log List Pointer.  Reset value of this register is 150h to prevent overwriting the descriptor table when not initialized."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT7": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT7",
      "name": "RT7",
      "type": "reg",
      "addr": 3236217628,
      "offset": 28,
      "doc": "High Priority Interrupt Enable Register (RT7)\nThis register is a read/write register. Setting the bits in this register causes a High-Priority Interrupt when the enabled event occurs. To service the High-priority Interrupt, the user reads the High-Priority-Interrupt Status Register (Register 8) to determine the cause of an interrupt and then writes to Register 8 to clear the appropriate bits.\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 14,
          "lsb": 2,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "HP_MEE",
          "access": "rw",
          "reset": 0,
          "doc": "Message Error Enable. This bit enables a High-Priority Interrupt in RT8 bit 2 upon the occurrence of a message error."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "STE",
          "access": "rw",
          "reset": 0,
          "doc": "Standard Interrupt Enable. Setting this bit will enable the Standard Interrupt in RT8 bit 1 upon the occurrence of a standard interrupt. This bit does not enable the High-Priority."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT8": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT8",
      "name": "RT8",
      "type": "reg",
      "addr": 3236217632,
      "offset": 32,
      "doc": "High-priority Interrupt Status/Reset Register (RT8)\nThe High-Priority Interrupt Status Register indicates the event that caused a High-Priority Interrupt to be asserted. To clear the interrupt signal and reset the bits, write a “1” to the appropriate bit. \nDuring normal operation, the High-Priority Interrupt Status register only supports the read operation or write “1” to clear the status.\nFor diagnostic purpose, the user must set Bit 15 (DRT) of Register 0 to allow the user to write and read back the data written. \nReset by: POR, AI condition \n\n\n\n*Standard Interrupts are:  RT_IBC, RT_IC, or RT_ME",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 14,
          "lsb": 2,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "MEI",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Message Error Interrupt. This bit is set when a message error occurs.  To clear this bit write a ‘1’ to this bit.  Refer to section A.7.4.1 (High Priority Interrupt) for details on the sources of this interrupt."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "STI",
          "access": "RW-Write-1-to-Clear",
          "reset": 0,
          "doc": "Standard Interrupt. Hardware sets this bit to ‘1’ when a standard interrupt has occurred.  Bit 0 of register 7 (RT7) must enabled.  This bit does not control logging of standard related interrupts into the Interrupt Log List.  To clear this bit write a ‘1’ to this bit.  Refer to section A.7.4.2 (Standard Interrupt) for details on source of this interrupt."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT9": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT9",
      "name": "RT9",
      "type": "reg",
      "addr": 3236217636,
      "offset": 36,
      "doc": "Standard Interrupt Enable Register (RT9)\nThe Standard Interrupt Enable register contains all the enable bits for Standard Interrupt Logging (into the Interrupt Log List).\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 10,
          "lsb": 6,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused. Ignored when written. Always read back as zero."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "IBC",
          "access": "rw",
          "reset": 0,
          "doc": "Illegal Broadcast Command. When set, this bit enables a Standard Interrupt to indicate that an Illegal Broadcast Command has been received."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "IC",
          "access": "rw",
          "reset": 0,
          "doc": "Illegal Command. When set, this bit enables a Standard Interrupt to indicate that an illegal command has been received."
        },
        {
          "nbits": 2,
          "lsb": 2,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused = 0"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "MEE",
          "access": "rw",
          "reset": 0,
          "doc": "Message Error Event. The bit enables a Standard Interrupt for message error (Standard Interrupt Message errors caused by Illegal command and Illegal broadcast commands are enabled with IC and IBC bit respectively)."
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused = 0"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT10": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT10",
      "name": "RT10",
      "type": "reg",
      "addr": 3236217640,
      "offset": 40,
      "doc": "Remote Terminal Address Register (RT10)\nThis register allows the user to set the Remote Terminal address via software. The Lock signal feature when set prevents the Remote Terminal Address or the 1553RT mode selection from changing.\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "INST",
          "access": "rw",
          "reset": 0,
          "doc": "Instrumentation bit. Setting this bit sets the RT status word Instrumentation bit."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "BUSY",
          "access": "rw",
          "reset": 0,
          "doc": "Busy bit. Setting this bit sets the RT status word busy bit.  This bit does not inhibit data transfer to the subsystem but will inhibit transfers on the 1553 bus.  See BME for alternate behavior."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "SUBSYS_FLG",
          "access": "rw",
          "reset": 0,
          "doc": "Subsystem Fail.  Setting this bit sets the Subsystem Flag bit in the RT status word.  This bit does not effect operation."
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "TF",
          "access": "rw",
          "reset": 0,
          "doc": "Terminal Flag. Setting this bit sets the RT status word terminal flag bit"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "SR",
          "access": "rw",
          "reset": 0,
          "doc": "Service Request. Setting this bit sets the RT status word service request bit."
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "BME",
          "access": "rw",
          "reset": 0,
          "doc": "Busy Mode Enable. Setting this bit sets the RT status word busy bit.  Setting this bit WILL inhibit both, data transfers to the subsystem, and 1553."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "LOCK_RTA",
          "access": "ro",
          "reset": 0,
          "doc": "Reflects the external pin LOCK_RT_ADR. When set this bit indicates that changes to the RT address are not allowed using internal registers."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "OPAE",
          "access": "ro",
          "reset": 0,
          "doc": "RT Odd Parity Address Error. When set, this bit indicates a Remote terminal Address Parity Error."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "OPA",
          "access": "rw",
          "reset": 0,
          "doc": "Remote Terminal Odd Parity Address. If LOCK_RTA is asserted, this bit reflects the state of the external Odd Parity Address pin. If LOCK_RTA is not asserted, software may write to this bit."
        },
        {
          "nbits": 5,
          "lsb": 0,
          "name": "RTA",
          "access": "rw",
          "reset": 0,
          "doc": "Remote Terminal Address. If LOCK_RTA is asserted, these bits reflect the external Remote Terminal Address pins. If LOCK_RTA is not asserted, software may write to these bits if RT Start Enable is not on."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.rtpro_csr_map_rsvd_0": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.rtpro_csr_map_rsvd_0",
      "name": "rtpro_csr_map_rsvd_0",
      "type": "mem",
      "addr": 3236217644,
      "offset": 44,
      "doc": "Reads back 0x0000DEAD"
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT12": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT12",
      "name": "RT12",
      "type": "reg",
      "addr": 3236217648,
      "offset": 48,
      "doc": "Programmed Reset Register (RT12)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "prog_reset",
          "access": "wo",
          "reset": 0,
          "doc": "The Programmed Reset Register allows the user to reset the sequencer, state machine, encoder and decoder. This is identical to the reset used for the Reset remote Terminal Mode Code except that command processing halts. \nAny write to this register (data = don’t care) address location initiates a one clock wide reset pulse.\nThis register always returns back all zeros."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT13": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.RT13",
      "name": "RT13",
      "type": "reg",
      "addr": 3236217652,
      "offset": 52,
      "doc": "RT Timer Reset Register (RT13)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 16,
          "lsb": 0,
          "name": "timer_reset",
          "access": "wo",
          "reset": 0,
          "doc": "Any write to this register (data = don’t care) address location will generate a clear pulse to reset the RT Time tag timer to zero.\nThe 1553RT’s RT Timer is used to time-tag message transactions. The time tag is generated from a free running eight-bit timer of 64 microsecond resolution. The timer can be reset to zero by simply writing to this register. When the timer is reset, it immediately starts running.\nThis register always returns zeros when read."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.rtpro_csr_map_rsvd_1": {
      "id": "emem.EMEM_APB.APB_RT_1553.RTPRO_MAP.rtpro_csr_map_rsvd_1",
      "name": "rtpro_csr_map_rsvd_1",
      "type": "mem",
      "addr": 3236217656,
      "offset": 56,
      "doc": "Reads back 0x0"
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP",
      "name": "RT_DISC_MAP",
      "type": "blk",
      "addr": 3236217728,
      "offset": 384,
      "doc": "BAR0 Space –1553 RT Discrete Registers\nEXTRA OFFSET: 0x180",
      "children": [
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCMSK",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCKEY",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCCMD",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCSTAT",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.ESCR1",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.ESCR2",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.RTECS",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.RTADR",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.EXECS",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.EXADR",
        "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.rt_disc_csr_map_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCMSK": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCMSK",
      "name": "DISCMSK",
      "type": "reg",
      "addr": 3236217728,
      "offset": 0,
      "doc": "Discrete Mask Register(DISCMSK)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "DISC_MSK",
          "access": "ro",
          "reset": 0,
          "doc": "The bits in this field that are set will allow the corresponding bits in the Discrete Command Register to be written.  This register is cleared when value is written to DISCCMD."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCKEY": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCKEY",
      "name": "DISCKEY",
      "type": "reg",
      "addr": 3236217732,
      "offset": 4,
      "doc": "Discrete Key Register(DISCKEY)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "WatchDogUpper",
          "access": "ro",
          "reset": 0,
          "doc": "Contains the upper bits of a 28 bits watchdog timer and depending on the source clock frequency will have an approximately 500ms resolution for a 33MHz clock and approximately 420ms for a 40MHz clock. (Note: LVS used a 40MHz clock).  It will hold the timeout value if triggered until it’s cleared."
        },
        {
          "nbits": 12,
          "lsb": 0,
          "name": "DISC_KEY",
          "access": "ro",
          "reset": 0,
          "doc": "These bits must be written with the one’s complement of bits 11:0 in the Discrete Mask Register to enable writing to bits 11:0 of the Discrete Command Register.  Hardware will clear these bits after a successful write to Discrete Command Register."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCCMD": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCCMD",
      "name": "DISCCMD",
      "type": "reg",
      "addr": 3236217736,
      "offset": 8,
      "doc": "Discrete Hold Register (DISCCMD)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "WDT_EXP",
          "access": "ro",
          "reset": 0,
          "doc": "This bit sets to logic ‘1’ if the watchdog timer is enabled, and either watchdog timer has expired or if bit 11 of this register is written.   Can only be cleared by 1553 Bus controller by writing a ‘0’ to this bit location, writing a ‘1’ will have no effect."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "WDT_STATn",
          "access": "ro",
          "reset": 0,
          "doc": "This bit sets to logic ‘0’ if the watchdog timer is enabled.  Not affected by local reset."
        },
        {
          "nbits": 2,
          "lsb": 12,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "WatchDogTest",
          "access": "ro",
          "reset": 0,
          "doc": "For test purposes only, this bit forces the watchdog timer to expire when set to logic ‘1’.  PCI will always read back as 0."
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "WatchDogRT_ENn",
          "access": "ro",
          "reset": 0,
          "doc": "Write a 1 to this bit to disable the watchdog timer and a 0 to enable it.  This bit is unaffected by a cPCI reset."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 7,
          "lsb": 1,
          "name": "DISC_CMD_OUT",
          "access": "ro",
          "reset": 0,
          "doc": "The value written here will output to the discrete output port of the ASIA"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "DISC0RST",
          "access": "ro",
          "reset": 0,
          "doc": "If set first causes a reset imminent indication followed by an sfc_reset of the RAD750. This bit is autocleared by the HK."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCSTAT": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.DISCSTAT",
      "name": "DISCSTAT",
      "type": "reg",
      "addr": 3236217740,
      "offset": 12,
      "doc": "Discrete Status Register (DISCSTAT)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "DISC_CMD",
          "access": "ro",
          "reset": 0,
          "doc": "These bits reflect the actual contents of the discrete DISC_CMD_OUT and DISC0RST bits in the Discrete Command.  DISC0RST (bit 8) is a self clearing that is active during the time the output reset line is active ~4us."
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "DISC_STAT_IN",
          "access": "ro",
          "reset": 0,
          "doc": "These 8 bits reflect the actual value of the status input port."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.ESCR1": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.ESCR1",
      "name": "ESCR1",
      "type": "reg",
      "addr": 3236217744,
      "offset": 16,
      "doc": "Error Status and Control Register 1 (ESCR1)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "CNTL_BIT",
          "access": "ro",
          "reset": 0,
          "doc": "Set this bit to a one to enable W1S behavior on writable bits in this register. Set to a 0 to enable W1C behavior. Always reads back 0."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "RTSBE_MSKn",
          "access": "ro",
          "reset": 0,
          "doc": "Set to 0 to inhibit the RT Single Bit Error Interrupt.  This bit is a mirror of the RT_SBE_Ena bit in the Interrupt Pending Register"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "RTDBE_MSKn",
          "access": "ro",
          "reset": 0,
          "doc": "Set to 0 to inhibit the RT Double Bit Error Interrupt.  This bit is a mirror of the RT_DBE_Ena bit in the Interrupt Pending Register"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "HMSBE_MSKn",
          "access": "ro",
          "reset": 0,
          "doc": "Set to 0 to inhibit the HIMEM Single Bit Error Interrupt.  - UNUSED ON LVS"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "HMDBE_MSKn",
          "access": "ro",
          "reset": 0,
          "doc": "Set to 0 to inhibit the HIMEM Double Bit Error Interrupt.  This bit is a mirror of the HI_MEM_DBE_Ena bit in the Interrupt Pending Register  - UNUSED ON LVS"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "CHKPT_MSKn",
          "access": "ro",
          "reset": 0,
          "doc": "Set to 0 to inhibit Checkpoint interrupt. This bit is a mirror of CHKPT_Ena bit in the Interrupt Enable Register"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "RT_SBE",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates an RTRAM Single Bit Error has occurred.  This bit is a mirror of the RT_SBE_Int bit in the Interrupt Pending Register"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "RT_DBE",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates an RTRAM Double Bit Error has occurred.  This bit is a mirror of the RT_DBE_Int bit in the Interrupt Pending Register"
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "HM_SBE",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates a HiMEM Single Bit Error has occurred.  This bit is a mirror of the HiMEM_SBE_Int bit in the Interrupt Pending Register. - UNUSED ON LVS"
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "HM_DBE",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates a HiMEM Double Bit Error has occurred.  This bit is a mirror of the HiMEM_DBE_Int bit in the Interrupt Pending Register. - UNUSED ON LVS"
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "DMA_WR_EN",
          "access": "ro",
          "reset": 0,
          "doc": "PCI DMA Write Enable Bit: When set to ‘1’ this bit will enable the RT PCI DMA WRITE through SA4.  When disabled the RT core will ignore 1553 PCI DMA write commands."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "INTD_WR_EN",
          "access": "ro",
          "reset": 0,
          "doc": "NOR DMA Write Enable Bit: When set to ‘1’ this bit will enable the RT NOR DMA WRITE through SA5.  When disabled the RT core will ignore 1553 NOR DMA write commands."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "CHKPT_FLG",
          "access": "ro",
          "reset": 0,
          "doc": "When set to 1 this bit will cause the PCI Interrupt to become active.  This is used to allow the bus controller to interrupt the PCI host by setting this bit to 1 via the 1553.  Once this bit is set it becomes a is a mirror of the CHKPT_Int bit in the Interrupt Pending Register"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "DMA_ERR_FLG",
          "access": "ro",
          "reset": 0,
          "doc": "This bit indicates that there is an active RT DMA error in the 1553 DMA Status Control Register (RTDCMS).  This bit is cleared by clearing all the error bits in the RTDCMS register"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.ESCR2": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.ESCR2",
      "name": "ESCR2",
      "type": "reg",
      "addr": 3236217748,
      "offset": 20,
      "doc": "Error Status and Control Register 2 (ESCR2)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 1,
          "lsb": 15,
          "name": "CNTL_BIT",
          "access": "rw",
          "reset": 0,
          "doc": "This bit is used to set or clear the rest of the bits, always reads back 0."
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "AI_DONE",
          "access": "ro",
          "reset": 0,
          "doc": "This bit is a mirror of the AI_DONE_INT in the IP3 register.  Auto Initialization Done interrupt is set to logic 1 when the Auto Initialization has completed its process, ~40us.  Cleared when IP3 bit 3 cleared."
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "WDT_MSKn",
          "access": "rw",
          "reset": 0,
          "doc": "Set to 0 to inhibit Watchdog Timer Interrupt. This bit is a mirror of the WDT_Enable in the Interrupt Enable Register"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "rsvd_2",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "DISC_DIS_4to7",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the state of the CDCDIS47 and SDCDIS47 pins.  When either pin is set to 1, writing to Discrete Outputs 4-7 are disabled."
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "DISC_DIS_0to3",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the state of the CDCDIS03 and SDCDIS03 pins.  When either pin is set to 1, writing to Discrete Outputs 0-3 are disabled."
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "WDT_EXP",
          "access": "ro",
          "reset": 0,
          "doc": "Watchdog Timer expiration flag.  This bit is a mirror of the Watchdog_Exp bit in DISCCMD"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "EDAC_EN",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates whether RT or HIMEM EDAC is enabled."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "DMA_WR_PROT_VIOL",
          "access": "ro",
          "reset": 0,
          "doc": "DMA Write Protect Violation: Hardware sets this bit to ‘1’ when a DMA Write was attempted and the DMA_WR_EN bit was clear in ESCR1."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "WDT_EXP_INT_",
          "access": "ro",
          "reset": 0,
          "doc": "Mirrors the Watchdog Timer Interrupt Pending bit."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "INTD_WR_PROT_VIOL",
          "access": "ro",
          "reset": 0,
          "doc": "NOR DMA Write Protect Violation: Hardware sets this bit to ‘1’ when a NOR DMA Write was attempted and the INTD_WR_EN bit was clear in ESCR1."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "rsvd_3",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "WDT_STAT",
          "access": "ro",
          "reset": 0,
          "doc": "Set to 1 when Watchdog Timer is enabled.  The watchdog timer is only enabled when bit 0 of ESCR2 (WDT_PCI_EN) is set to 1 and bit 9 of DISCCMD (WatchDogRT_ENn) is set to 0."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "XRTI_RCVD_FLG",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates whether and XRTI mode code has been received since the last RTI"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "WDT_PCI_EN",
          "access": "rw",
          "reset": 0,
          "doc": "EMEM ONLY: this bit has no functionality any more. PCI enable for WD is always 1=enabled.\nPCI can write a 1 to this bit to enable the watchdog timer, but cannot disable. Note that the watchdog timer needs to be enabled from both the PCI and 1553 in order to be running."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.RTECS": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.RTECS",
      "name": "RTECS",
      "type": "reg",
      "addr": 3236217752,
      "offset": 24,
      "doc": "RT EDAC Control and Status Register (RTECS)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "Function_Code",
          "access": "wo",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1001 Allow EDAC to be disabled/enabled (test mode only)\n0110 Allow SBE_CNT_CNTRL to be modified\n1010 Allow SBE_COUNT to be modified \n\n\nFunction Code (3:0):  Three separate functions may be directed on the remaining bits depending on the state of these bits during the write to this register.   These bits read back as “0000”.  Write a 1 to the associated bit(s) below to invoke the desired Function Code action.*"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "EDAC_DIS_STAT",
          "access": "ro",
          "reset": 0,
          "doc": "EDAC Disabled Status Register bit indicates the status of the RTRAM EDAC logic.  This bit is set to a logic ‘1’ when EDAC has been disabled, see Section 0 for details on disabling/enabling EDAC."
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "EDAC_TEST_DIS",
          "access": "rw",
          "reset": 0,
          "doc": "EDAC Test Disable bit is used to disable/enable EDAC only when the RT is in TEST_MODE.  Writing a logic ‘1’ to this bit will disable EDAC."
        },
        {
          "nbits": 10,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 3,
          "lsb": 13,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 6,
          "lsb": 7,
          "name": "SBE_CNT_CNTRL",
          "access": "rw",
          "reset": 63,
          "doc": "Single Bit Error count control allows you to set the 6 bit value at which single bit interrupt will be generated. If SBE_COUNT = 0, setting SBE_CNT_CNTRL = 0 will cause a Single Bit Error interrupt to set once data is read from memory even though there is no true Single Bit Error."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "RT_DBE_STAT",
          "access": "ro",
          "reset": 0,
          "doc": "RTRAM Double Bit Error status bit.  Mirrored and cleared in Interrupt Pending Register."
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "SBE_COUNT",
          "access": "rw",
          "reset": 0,
          "doc": "Single Bit Error count indicates the number of errors detected in the RT Data Buffers.  This value must be manually set to zero once an interrupt has been set.   If the SBE_COUNT is not manually reset once an interrupt is generated it will continue to count until the value of SBE_CNT_CNTRL and stop counting, no more interrupts will be generated."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.RTADR": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.RTADR",
      "name": "RTADR",
      "type": "reg",
      "addr": 3236217756,
      "offset": 28,
      "doc": "RT RAM EDAC Single/Double Bit Error Address Register (RTADR)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write on a 32bit bus"
        },
        {
          "nbits": 2,
          "lsb": 14,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 14,
          "lsb": 0,
          "name": "RT_EDAC_Addr",
          "access": "rw",
          "reset": 0,
          "doc": "Address capture of single bit or double bit error.  Double bit errors (DBE) latch the offset address (from the start of RTRAM) where a DBE occurred at which time this register will not allow any more addresses to be latched until the DBE bit associated with this interrupt is cleared.  Single bit error (SBE) addresses also get latched in this register will be overwritten if another SBE or DBE is detected. \n\nNote: This register if written will read a 1 bit left shifted value"
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.EXECS": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.EXECS",
      "name": "EXECS",
      "type": "reg",
      "addr": 3236217760,
      "offset": 32,
      "doc": "External Memory EDAC Control and Status Register (EXECS)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "Function_Code",
          "access": "wo",
          "reset": 0,
          "doc": "Function_Code(3:0) Function\n1001 Allow EDAC to be disabled/enabled (test mode only)\n0110 Allow SBE_CNT_CNTRL to be modified\n1010 Allow SBE_COUNT to be modified \n\n\nFunction Code (3:0):  Three separate functions may be directed on the remaining bits depending on the state of these bits during the write to this register.   These bits read back as “0000”.  Write a 1 to the associated bit(s) below to invoke the desired Function Code action.*"
        },
        {
          "nbits": 1,
          "lsb": 27,
          "name": "EDAC_DIS_STAT",
          "access": "ro",
          "reset": 0,
          "doc": "EDAC Disabled Status Register bit indicates the status of the RTRAM EDAC logic.  This bit is set to a logic ‘1’ when EDAC has been disabled, see Section 0 for details on disabling/enabling EDAC."
        },
        {
          "nbits": 1,
          "lsb": 26,
          "name": "EDAC_TEST_DIS",
          "access": "rw",
          "reset": 0,
          "doc": "EDAC Test Disable bit is used to disable/enable EDAC only when the RT is in TEST_MODE.  Writing a logic ‘1’ to this bit will disable EDAC."
        },
        {
          "nbits": 10,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 3,
          "lsb": 13,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 6,
          "lsb": 7,
          "name": "SBE_CNT_CNTRL",
          "access": "rw",
          "reset": 63,
          "doc": "Single Bit Error count control allows you to set the 6 bit value at which single bit interrupt will be generated. If SBE_COUNT = 0, setting SBE_CNT_CNTRL = 0 will cause a Single Bit Error interrupt to set once data is read from memory even though there is no true Single Bit Error."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "EX_DBE_STAT",
          "access": "ro",
          "reset": 0,
          "doc": "RTRAM Double Bit Error status bit.  Mirrored and cleared in Interrupt Pending Register."
        },
        {
          "nbits": 6,
          "lsb": 0,
          "name": "SBE_COUNT",
          "access": "rw",
          "reset": 0,
          "doc": "Single Bit Error count indicates the number of errors detected in the RT Data Buffers.  This value must be manually set to zero once an interrupt has been set.   If the SBE_COUNT is not manually reset once an interrupt is generated it will continue to count until the value of SBE_CNT_CNTRL and stop counting, no more interrupts will be generated."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.EXADR": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.EXADR",
      "name": "EXADR",
      "type": "reg",
      "addr": 3236217764,
      "offset": 36,
      "doc": "External Memory EDAC Single/Double Bit Error Address Register (EXADR)\nReset by: POR, AI condition",
      "fields": [
        {
          "nbits": 19,
          "lsb": 13,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Unused – 0 on read; ignored on write"
        },
        {
          "nbits": 13,
          "lsb": 0,
          "name": "EX_EDAC_Addr",
          "access": "ro",
          "reset": 0,
          "doc": "Address capture of single bit or double bit error.  Double bit errors (DBE) latch the offset address (from the start of Memory) where a DBE occurred at which time this register will not allow any more addresses to be latched until the DBE bit associated with this interrupt is cleared.  Single bit error (SBE) addresses also get latched in this register will be overwritten if another SBE or DBE is detected."
        }
      ]
    },
    "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.rt_disc_csr_map_rsvd_0": {
      "id": "emem.EMEM_APB.APB_RT_1553.RT_DISC_MAP.rt_disc_csr_map_rsvd_0",
      "name": "rt_disc_csr_map_rsvd_0",
      "type": "mem",
      "addr": 3236217768,
      "offset": 40,
      "doc": "Reads back 0x0"
    },
    "emem.EMEM_APB.APB_EMEMN_FFB": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB",
      "name": "APB_EMEMN_FFB",
      "type": "blk",
      "addr": 3236217856,
      "offset": 50176,
      "doc": "EMEMN Bridge registers\nBy default, all registers go back to their reset value upon POR reset as well as PCI reset assertion. A few number of error-reporting registers must survive PCI reset, in this case column “Ignores PCI rst” will show YES.\n\n\n\n\n\nRegisters detailed descriptions",
      "children": [
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ID_REV",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR1",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR2",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR3",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_SCRPD",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER1",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER2",
        "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER3",
        "emem.EMEM_APB.APB_EMEMN_FFB.rblk_apb_ememn_ffb_rsvd_0"
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ID_REV": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ID_REV",
      "name": "EMEMN_FFB_ID_REV",
      "type": "reg",
      "addr": 3236217856,
      "offset": 0,
      "doc": "FFB ID/Revision Register\nThis register reports EMEMP or EMEMN FFB bridge status. There is a single register type, described below, and 2 instances of it, one in EMEMP and one in EMEMN.",
      "fields": [
        {
          "nbits": 16,
          "lsb": 16,
          "name": "Id",
          "access": "ro",
          "reset": 49147,
          "doc": "Indicates the ID and revision of this FFB module"
        },
        {
          "nbits": 8,
          "lsb": 8,
          "name": "major",
          "access": "ro",
          "reset": 1,
          "doc": "Major revision"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "minor",
          "access": "ro",
          "reset": 1,
          "doc": "Minor reivision"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR1": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR1",
      "name": "EMEMN_FFB_ESCR1",
      "type": "reg",
      "addr": 3236217860,
      "offset": 4,
      "doc": "FFB Error Status Control Register 1",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "cmd",
          "access": "rw",
          "reset": 0,
          "doc": "On write:\n0xC0 – clear cmd_perr\n0xC1 – clear data_perr\n0xC2 – clear rd_rsp_tmout\n0xC3 – clear unexp_rd_rsp\n0xC4 – clear rx_ovfl\n0xC5 – clear fc_ovfl\n0xC6 – clear tx_blkd\n0xC7 – clear mlfd_pkt\n0xC8 – clear sync_in_active\n0xC9 – clear response cmd fifo parity error\n0xCA – clear response data fifo parity error\n0xCB – clear tx cmd fifo parity error\n0xCC – clear tx data fifo parity error\n0xCD – clear rx cmd fifo parity error\n0xCE – clear rx data fifo parity error\n0xCF – reset resync counter \nOn read: last written value"
        },
        {
          "nbits": 4,
          "lsb": 20,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 19,
          "name": "resync_cnt_ovfl",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a resync counter overflow is detected"
        },
        {
          "nbits": 4,
          "lsb": 15,
          "name": "resync_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Counter of resync events that have occurred since last reset"
        },
        {
          "nbits": 1,
          "lsb": 14,
          "name": "rsp_cmd_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in response command fifo"
        },
        {
          "nbits": 1,
          "lsb": 13,
          "name": "rsp_data_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in response data fifo"
        },
        {
          "nbits": 1,
          "lsb": 12,
          "name": "tx_cmd_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in transmit command fifo"
        },
        {
          "nbits": 1,
          "lsb": 11,
          "name": "tx_data_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in transmit data fifo"
        },
        {
          "nbits": 1,
          "lsb": 10,
          "name": "rx_cmd_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in receive command fifo"
        },
        {
          "nbits": 1,
          "lsb": 9,
          "name": "rx_data_fifo_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected in receive data fifo"
        },
        {
          "nbits": 1,
          "lsb": 8,
          "name": "sync_in_active",
          "access": "ro",
          "reset": 0,
          "doc": "A sync was received while in active state."
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "mlfd_pkt",
          "access": "ro",
          "reset": 0,
          "doc": "A malformed packet was received."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "tx_blkd",
          "access": "ro",
          "reset": 0,
          "doc": "Transmit timeout has occurred due to lack of credit (10ms timeout)."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fc_ovfl",
          "access": "ro",
          "reset": 0,
          "doc": "A flow-control credit overflow has occurred, i.e. received more credit than initially negotiated."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "rx_ovfl",
          "access": "ro",
          "reset": 0,
          "doc": "The other FFB used more credits than was made available (read command or write command/data)."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "unexp_rd_rsp",
          "access": "ro",
          "reset": 0,
          "doc": "An unexpected read response was received (no read request in flight)"
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rd_rsp_tmout",
          "access": "ro",
          "reset": 0,
          "doc": "A read completion timeout has occurred"
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "data_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected on a data word"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "cmd_perr",
          "access": "ro",
          "reset": 0,
          "doc": "Set when a parity error is detected on a cmd word"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR2": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR2",
      "name": "EMEMN_FFB_ESCR2",
      "type": "reg",
      "addr": 3236217864,
      "offset": 8,
      "doc": "FFB Error Status Control Register 2",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "cmd",
          "access": "rw",
          "reset": 0,
          "doc": "On write:\n0xE0/0xC0 – set/clear perr_dis\n0xE2/0xC2 – set/clear rd_rsp_tmout_dis\n0xE3/0xC3 – set/clear unexp_rd_rsp_dis\n0xE4/0xC4– set/clear rx_ovfl_dis\n0xE5/0xC5 – set/clear fc_ovfl_dis\n0xE6/0xC6 – set/clear tx_blkd_dis\n0xE7/0xC7 – set/clear mlfd_pkt_dis\nOn read: last written value"
        },
        {
          "nbits": 16,
          "lsb": 8,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 7,
          "name": "mlfd_pkt_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to mlfd_pkt (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 6,
          "name": "tx_blkd_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to tx_blkd (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 5,
          "name": "fc_ovfl_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to fc_ovfl (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 4,
          "name": "rx_ovfl_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to rx_ovfl (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 3,
          "name": "unexp_rd_rsp_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to unexp_rd_rsp_dis (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 2,
          "name": "rd_rsp_tmout_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable response to rd_rsp_tmout (flag error only)."
        },
        {
          "nbits": 1,
          "lsb": 1,
          "name": "rsvd_1",
          "access": "rsvd",
          "reset": 0,
          "doc": "Reserved"
        },
        {
          "nbits": 1,
          "lsb": 0,
          "name": "perr_dis",
          "access": "ro",
          "reset": 0,
          "doc": "When set, disable parity checking."
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR3": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_ESCR3",
      "name": "EMEMN_FFB_ESCR3",
      "type": "reg",
      "addr": 3236217868,
      "offset": 12,
      "doc": "FFB Error Status Control Register 3",
      "fields": [
        {
          "nbits": 8,
          "lsb": 24,
          "name": "cmd",
          "access": "rw",
          "reset": 0,
          "doc": "On write:\n0x77 – unlock test mode (locked by default)\n0x33 – lock test mode\n0x73 – when test mode is unlocked, force resync\n0x7C – when test mode is unlocked, inject a sync packet to RX module\n0x7D – Inject Parity Error\n0x7B – Inject Transmit blocked\n0x7E – Inject read response timeout\nOn read: last written value"
        },
        {
          "nbits": 1,
          "lsb": 23,
          "name": "test_mode",
          "access": "ro",
          "reset": 0,
          "doc": "0 – test mode disabled; 1 – test mode enabled"
        },
        {
          "nbits": 7,
          "lsb": 16,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 4,
          "lsb": 12,
          "name": "tx_sync_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of sync packets transmitted since reset, saturates to 0xF"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "rx_sync_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of sync packets received since reset, saturates to 0xF"
        },
        {
          "nbits": 4,
          "lsb": 4,
          "name": "tx_perr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of parity errors transmitted since reset, saturates to 0xF"
        },
        {
          "nbits": 4,
          "lsb": 0,
          "name": "rx_perr_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Number of parity errors observed since reset, saturates to 0xF"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_SCRPD": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_SCRPD",
      "name": "EMEMN_FFB_SCRPD",
      "type": "reg",
      "addr": 3236217872,
      "offset": 16,
      "doc": "32-bit unsigned integer",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "value",
          "access": "rw",
          "reset": 0,
          "doc": "A value between 0 and 232-1"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER1": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER1",
      "name": "EMEMN_FFB_FPER1",
      "type": "reg",
      "addr": 3236217876,
      "offset": 20,
      "doc": "FFB Fifo Parity Error Register 1",
      "fields": [
        {
          "nbits": 4,
          "lsb": 28,
          "name": "fifo_perr_src",
          "access": "ro",
          "reset": 0,
          "doc": "Indicates the FIFO that had the parity error associated with the data in FFB_FPER1-FFB_FPER3 \n0x1 – rx cmd fifo saw a parity error\n0x2 – rx data fifo saw a parity error\n0x3 – tx cmd fifo saw a parity error\n0x4 – tx data fifo saw a parity error\n0x5 – rsp cmd fifo saw a parity error\n0x6 – rsp data fifo saw a parity error"
        },
        {
          "nbits": 11,
          "lsb": 17,
          "name": "rsvd_0",
          "access": "rsvd",
          "reset": 0,
          "doc": ""
        },
        {
          "nbits": 1,
          "lsb": 16,
          "name": "cmd_fifo_err",
          "access": "ro",
          "reset": 0,
          "doc": "Error bit from last good cmd fifo"
        },
        {
          "nbits": 2,
          "lsb": 14,
          "name": "cmd_fifo_src",
          "access": "ro",
          "reset": 0,
          "doc": "Source from last good cmd fifo"
        },
        {
          "nbits": 2,
          "lsb": 12,
          "name": "cmd_fifo_dest",
          "access": "ro",
          "reset": 0,
          "doc": "Destination from last good cmd fifo"
        },
        {
          "nbits": 4,
          "lsb": 8,
          "name": "cmd_fifo_tag",
          "access": "ro",
          "reset": 0,
          "doc": "Tag from last good cmd fifo"
        },
        {
          "nbits": 8,
          "lsb": 0,
          "name": "cmd_fifo_wd_cnt",
          "access": "ro",
          "reset": 0,
          "doc": "Word count from last good cmd fifo"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER2": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER2",
      "name": "EMEMN_FFB_FPER2",
      "type": "reg",
      "addr": 3236217880,
      "offset": 24,
      "doc": "FFB Fifo Parity Error Register 2",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "cmd_fifo_data",
          "access": "ro",
          "reset": 0,
          "doc": "Data from last good cmd fifo"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER3": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.EMEMN_FFB_FPER3",
      "name": "EMEMN_FFB_FPER3",
      "type": "reg",
      "addr": 3236217884,
      "offset": 28,
      "doc": "FFB Fifo Parity Error Register 3",
      "fields": [
        {
          "nbits": 32,
          "lsb": 0,
          "name": "data_fifo_data",
          "access": "ro",
          "reset": 0,
          "doc": "Data from last good data fifo"
        }
      ]
    },
    "emem.EMEM_APB.APB_EMEMN_FFB.rblk_apb_ememn_ffb_rsvd_0": {
      "id": "emem.EMEM_APB.APB_EMEMN_FFB.rblk_apb_ememn_ffb_rsvd_0",
      "name": "rblk_apb_ememn_ffb_rsvd_0",
      "type": "mem",
      "addr": 3236217888,
      "offset": 32,
      "doc": "Reserved register space"
    },
    "emem.EMEM_APB.blk_apb_rsvd_5": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_5",
      "name": "blk_apb_rsvd_5",
      "type": "mem",
      "addr": 3236225024,
      "offset": 57344,
      "doc": "8kB RTRAM/intRAM (muxed in with EMEMN registers traffic to save resource on transit between EMEMP and EMEMN)"
    },
    "emem.EMEM_APB.blk_apb_rsvd_6": {
      "id": "emem.EMEM_APB.blk_apb_rsvd_6",
      "name": "blk_apb_rsvd_6",
      "type": "mem",
      "addr": 3236225028,
      "offset": 57348,
      "doc": ""
    }
  }
}